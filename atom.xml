<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[The NewIdea]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.tnidea.com/"/>
  <updated>2016-01-08T16:25:39.000Z</updated>
  <id>http://www.tnidea.com/</id>
  
  <author>
    <name><![CDATA[Carey Tzou]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[ImitateLogin新增插件机制以及又一个社交网站的支持]]></title>
    <link href="http://www.tnidea.com/imitate-login-support-plugin-now.html"/>
    <id>http://www.tnidea.com/imitate-login-support-plugin-now.html</id>
    <published>2016-01-08T16:00:00.000Z</published>
    <updated>2016-01-08T16:25:39.000Z</updated>
    <content type="html"><![CDATA[<p>我的文章里已经多次介绍 <a href="https://github.com/ziyunhx/imitate-login" target="_blank" rel="external">imitate-login</a> ，这是我最近一直在维护的一个使用c#模拟社交网站登录的开源项目，现在新增了对插件的支持以及一个新的网站（由于某种原因，会在文章结束部分介绍；而且仅会出现在博客中）。希望喜欢的读者可以通过 <strong>Star &amp; fork</strong> 来支持我，我也会据此来决定时间的分配。</p>
 <a id="more"></a>
<p>说点无关的东西，最近把博客从 GitHub Page 迁移到了 Azure，为了减轻域名与服务器的费用，在文章的正文开头和结尾放了点小广告，如果影响了你的阅读体验，请自行使用 Adblock Plus。 </p>
<p>好了，言归正常！<a href="https://github.com/ziyunhx/imitate-login" target="_blank" rel="external">imitate-login</a> 现在已经提供了对插件的支持；目前有两个部分使用到了插件机制，登录自身实现以及登录过程中的验证码识别过程；其中登录过程仅支持 MEF（Managed Extensibility Framework）模式，而验证码识别过程支持 Thrift RPC (Apache Thrift)、HTTP RESTful (POST/GET)、MEF 三种方式。下面将介绍这三种插件的开发与配置方式，所有代码均已经在 <a href="https://github.com/ziyunhx/imitate-login/tree/master/Extensions" target="_blank" rel="external">Extensions</a> 。</p>
<h3 id="Thrift_RPC">Thrift RPC</h3><p>在 Imitate Login 的库中有通过 Thrift 文件生成的类 ThriftOperation，如果你使用其它语言开发，请通过 Thrift 生成对应的类，下面将介绍使用C#来开发插件。</p>
<p>首先，创建一个控制台应用程序，新增一个类继承 ThriftOperation.Iface 并实现，这里直接 return 一下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">class demo : ThriftOperation.Iface</span><br><span class="line">&#123;</span><br><span class="line">    public string Operation(OperationObj operationObj)</span><br><span class="line">    &#123;</span><br><span class="line">        return "1234";</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在主函数里增加一个创建 Thrift 服务端得方法：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> port = <span class="number">7801</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">string</span> str = ConfigurationManager.AppSettings[<span class="string">"ServerPort"</span>];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">string</span>.IsNullOrEmpty(str))</span><br><span class="line">        <span class="keyword">int</span>.TryParse(str, <span class="keyword">out</span> port);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (args != <span class="keyword">null</span> &amp;&amp; args.Length == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span>.TryParse(args[<span class="number">0</span>], <span class="keyword">out</span> port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Start(port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"><span class="keyword">int</span> port</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    TServerSocket serverTransport = <span class="keyword">new</span> TServerSocket(port, <span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">    ThriftOperation.Processor processor = <span class="keyword">new</span> ThriftOperation.Processor(<span class="keyword">new</span> demo());</span><br><span class="line">    TServer server = <span class="keyword">new</span> TSimpleServer(processor, serverTransport);</span><br><span class="line">    Console.WriteLine(<span class="string">"Starting server on port &#123;0&#125; ..."</span>, port);</span><br><span class="line">    server.Serve();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用时，你需要先启动该插件程序，然后将下面配置部分合并放到程序运行目录的 extension.conf 文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#10;    &#34;ExtendType&#34;: 3,&#10;    &#34;SupportSite&#34;: [2],&#10;    &#34;Path&#34;: null,&#10;    &#34;Host&#34;: &#34;127.0.0.1&#34;,&#10;    &#34;Port&#34;: 7801,&#10;    &#34;UrlFormat&#34;: null,&#10;    &#34;HttpMethod&#34;: null&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>你可以使用 <a href="https://github.com/ziyunhx/imitate-login/tree/master/Tools/PluginConfigBuild" target="_blank" rel="external">PluginConfigBuild</a> 工具来生成配置文件，此处不再解释具体细节。</p>
<h3 id="HTTP_RESTful">HTTP RESTful</h3><p>另外一种插件方式即使用通用的 Http RESTful API 来实现，如果通过 GET 方法，你仅能传入一个枚举用来表明网站以及一个字符串作为参数；如果你通过 POST 方法，需要通过 Thrift 获得一个 OperationObj 类的定义，当然 C# 可以通过直接引用 <a href="https://github.com/ziyunhx/imitate-login" target="_blank" rel="external">imitate-login</a> 库来获得。API 的编写方法不再累述，接下来你需要将以下配置部分合并放到程序运行目录的 extension.conf 文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#10;    &#34;ExtendType&#34;: 2,&#10;    &#34;SupportSite&#34;: [6],&#10;    &#34;Path&#34;: null,&#10;    &#34;Host&#34;: null,&#10;    &#34;Port&#34;: 0,&#10;    &#34;UrlFormat&#34;: &#34;http://localhost:2920/Mail/SendMail?loginSite=&#123;0&#125;&#38;imageUrl=&#123;1&#125;&#34;,&#10;    &#34;HttpMethod&#34;: &#34;GET&#34;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="MEF">MEF</h3><p>MEF 是微软在 .NET 4.0 以后原生提供的一种插件模式；使用该方法需要用到 IMEFOperation 类，你需要通过引用 <a href="https://github.com/ziyunhx/imitate-login" target="_blank" rel="external">imitate-login</a> 得到，demo 代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[Export(<span class="keyword">typeof</span>(IMEFOperation))]</span><br><span class="line">[ExportMetadata(<span class="string">"loginSite"</span>, LoginSite.Baidu)]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">demo</span> : <span class="title">IMEFOperation</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">Operate</span>(<span class="params"><span class="keyword">string</span> imageUrl = <span class="string">""</span>, Image image = <span class="keyword">null</span>, <span class="keyword">params</span> <span class="keyword">string</span>[] param</span>)</span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"1234"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式需要在配置文件中指定插件的存放位置，位置支持相对运行目录或绝对目录；本例为将该插件生成的 dll 拷贝到程序运行目录下的 Extensions 目录中，配置文件如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#10;    &#34;ExtendType&#34;: 1,&#10;    &#34;SupportSite&#34;: [5, 1],&#10;    &#34;Path&#34;: &#34;Extensions&#34;,&#10;    &#34;Host&#34;: null,&#10;    &#34;Port&#34;: 0,&#10;    &#34;UrlFormat&#34;: null,&#10;    &#34;HttpMethod&#34;: null&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>所有的配置文件均可以通过 <a href="https://github.com/ziyunhx/imitate-login/tree/master/Tools/PluginConfigBuild" target="_blank" rel="external">PluginConfigBuild</a> 工具来生成，其中 SupportSite 为支持的登录网站的枚举数组。</p>
<hr>
<p>以下内容将仅在博客中展示！</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 博客正文广告 -->
<ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-6541442242935379" data-ad-slot="9453052931" data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<p>为了展示插件机制，我将微信网页版的登录增加到了库中；该方式为登录时将二维码通过邮件发送到指定的邮箱，人工使用手机微信扫描后登录微信。该方法仅供展示插件机制，无生成环境使用价值，请轻喷！</p>
<p>修改 <a href="https://github.com/ziyunhx/imitate-login/tree/master/Extensions/MailNotication" target="_blank" rel="external">MailNotication</a> 插件的 web.config 中的发信邮箱与收信邮箱设置，在 IIS 中部署好WebAPI，配置好插件配置文件，即可测试微信登录功能。</p>
<hr>
<p>好了，接下来需要什么自己动手试试吧！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>我的文章里已经多次介绍 <a href="https://github.com/ziyunhx/imitate-login">imitate-login</a> ，这是我最近一直在维护的一个使用c#模拟社交网站登录的开源项目，现在新增了对插件的支持以及一个新的网站（由于某种原因，会在文章结束部分介绍；而且仅会出现在博客中）。希望喜欢的读者可以通过 <strong>Star &amp; fork</strong> 来支持我，我也会据此来决定时间的分配。</p>]]>
    
    </summary>
    
      <category term=".NET" scheme="http://www.tnidea.com/tags/NET/"/>
    
      <category term="C#" scheme="http://www.tnidea.com/tags/C/"/>
    
      <category term="social network" scheme="http://www.tnidea.com/tags/social-network/"/>
    
      <category term="thrift" scheme="http://www.tnidea.com/tags/thrift/"/>
    
      <category term="wechat" scheme="http://www.tnidea.com/tags/wechat/"/>
    
      <category term="微信" scheme="http://www.tnidea.com/tags/%E5%BE%AE%E4%BF%A1/"/>
    
      <category term="插件机制" scheme="http://www.tnidea.com/tags/%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6/"/>
    
      <category term="爬虫" scheme="http://www.tnidea.com/categories/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Icinga2监控Linux和Windows服务器]]></title>
    <link href="http://www.tnidea.com/icinga2-monitor-other-machine.html"/>
    <id>http://www.tnidea.com/icinga2-monitor-other-machine.html</id>
    <published>2016-01-05T16:00:00.000Z</published>
    <updated>2016-01-06T16:02:29.000Z</updated>
    <content type="html"><![CDATA[<p>Icinga2可以通过Agent来监控其它设备，这些设备包含各种操作系统的服务器以及网络设备。一些简单的网络指标监控是不需要创建Agent的，例如ping和ssh；但是某些无法通过网络获取的指标则需要在被监测服务器创建一个监控代理来将指标返回给监控服务器。本文将介绍如何在Linux和Windows服务器上安装和配置Agent来实现多机器的监控。</p>
<a id="more"></a>
<h1 id="配置监控服务器">配置监控服务器</h1><p>在配置远程监控代理之前，你首先需要设置一下主节点；这个设置过程主要是完成了一下几个步骤：</p>
<ul>
<li>为主节点生成SSL加密的CA证书；</li>
<li>启用 API 功能，在配置文件增加本地 Endpoint 和 Zone 的配置；</li>
<li>设置防火墙允许通信端口（默认为 5665）。</li>
</ul>
<p>你可以使用命令行界面来设置一个主节点，它需要以root权限来执行，如果你是使用该命令来设置主节点，注意第一个选项需要选择NO（n）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># icinga2 node wizard&#10;Welcome to the Icinga 2 Setup Wizard!&#10;&#10;We&#39;ll guide you through all required configuration details.&#10;&#10;Please specify if this is a satellite setup (&#39;n&#39; installs a master setup) [Y/n]: n&#10;Starting the Master setup routine...&#10;Please specifiy the common name (CN) [icinga2-node1.localdomain]: &#10;Checking the &#39;api&#39; feature...&#10;&#39;api&#39; feature not enabled, running &#39;api setup&#39; now.&#10;information/cli: Generating new CA.&#10;&#10;information/base: Writing private key to &#39;/var/lib/icinga2/ca/ca.key&#39;.&#10;information/base: Writing X509 certificate to &#39;/var/lib/icinga2/ca/ca.crt&#39;.&#10;information/cli: Initializing serial file in &#39;/var/lib/icinga2/ca/serial.txt&#39;.&#10;information/cli: Generating new CSR in &#39;/etc/icinga2/pki/icinga2-node1.localdomain.csr&#39;.&#10;&#10;information/base: Writing private key to &#39;/etc/icinga2/pki/icinga2-node1.localdomain.key&#39;.&#10;information/base: Writing certificate signing request to &#39;/etc/icinga2/pki/icinga2-node1.localdomain.csr&#39;.&#10;information/cli: Signing CSR with CA and writing certificate to &#39;/etc/icinga2/pki/icinga2-node1.localdomain.crt&#39;.&#10;&#10;information/cli: Copying CA certificate to &#39;/etc/icinga2/pki/ca.crt&#39;.&#10;&#10;information/cli: Adding new ApiUser &#39;root&#39; in &#39;/etc/icinga2/conf.d/api-users.conf&#39;.&#10;&#10;information/cli: Enabling the ApiListener feature.&#10;&#10;Enabling feature api. Make sure to restart Icinga 2 for these changes to take effect.&#10;information/cli: Dumping config items to file &#39;/etc/icinga2/zones.conf&#39;.&#10;Please specify the API bind host/port (optional):&#10;Bind Host []: &#10;Bind Port []: &#10;information/cli: Updating constants.conf.&#10;information/cli: Updating constants file &#39;/etc/icinga2/constants.conf&#39;.&#10;information/cli: Updating constants file &#39;/etc/icinga2/constants.conf&#39;.&#10;Done.&#10;&#10;Now restart your Icinga 2 daemon to finish the installation!</span><br></pre></td></tr></table></figure>
<p>验证配置文件，检查该步骤是否成功：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># egrep &#39;NodeName|TicketSalt&#39; /etc/icinga2/constants.conf&#10;# cat /etc/icinga2/zones.conf&#10;/*&#10; * Generated by Icinga 2 node setup commands&#10; * on 2015-02-09 15:21:49 +0100&#10; */&#10;object Endpoint &#34;icinga2-node1.localdomain&#34; &#123;&#10;&#125;&#10;&#10;object Zone &#34;master&#34; &#123;&#10;    //this is the local node master named  = &#34;master&#34;&#10;    endpoints = [ &#34;icinga2-node1.localdomain&#34; ]&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>验证完成后重启 Icinga2。</p>
<p>在主节点使用命令行生成 ticket，其中 icinga2-node2.localdomain 为远程节点的 CN：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># icinga2 pki ticket --cn icinga2-node2.localdomain</span><br></pre></td></tr></table></figure>
<h1 id="监控Linux服务器">监控Linux服务器</h1><p>Linux的远程节点安装与主节点相同，安装完Icinga2后，使用 icinga2 node wizard 配置远程节点，此处在第一次选择时直接使用回车选择默认选项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># icinga2 node wizard&#10;Welcome to the Icinga 2 Setup Wizard!&#10;We&#39;ll guide you through all required configuration details.&#10;&#10;Please specify if this is a satellite setup (&#39;n&#39; installs a master setup) [Y/n]:&#10;Starting the Node setup routine...&#10;Please specifiy the common name (CN) [icinga2-node2.localdomain]:&#10;Please specifiy the local zone name [icinga2-node2.localdomain]:&#10;Please specify the master endpoint(s) this node should connect to:&#10;Master Common Name (CN from your master setup): icinga2-node1.localdomain&#10;Please fill out the master connection information:&#10;Master endpoint host (optional, your master&#39;s IP address or FQDN): 192.168.56.101&#10;Master endpoint port (optional) []:&#10;Add more master endpoints? [y/N]&#10;Please specify the master connection for CSR auto-signing (defaults to master endpoint host):&#10;Host [192.168.56.101]:&#10;Port [5665]:&#10;information/base: Writing private key to &#39;/etc/icinga2/pki/icinga2-node2.localdomain.key&#39;.&#10;information/base: Writing X509 certificate to &#39;/etc/icinga2/pki/icinga2-node2.localdomain.crt&#39;.&#10;information/cli: Generating self-signed certifiate:&#10;information/cli: Fetching public certificate from master (192.168.56.101, 5665):&#10;&#10;information/cli: Writing trusted certificate to file &#39;/etc/icinga2/pki/trusted-master.crt&#39;.&#10;information/cli: Stored trusted master certificate in &#39;/etc/icinga2/pki/trusted-master.crt&#39;.&#10;&#10;Please specify the request ticket generated on your Icinga 2 master.&#10; (Hint: # icinga2 pki ticket --cn &#39;icinga2-node2.localdomain&#39;): ead2d570e18c78abf285d6b85524970a0f69c22d&#10;information/cli: Processing self-signed certificate request. Ticket &#39;ead2d570e18c78abf285d6b85524970a0f69c22d&#39;.&#10;&#10;information/cli: Writing signed certificate to file &#39;/etc/icinga2/pki/icinga2-node2.localdomain.crt&#39;.&#10;information/cli: Writing CA certificate to file &#39;/etc/icinga2/pki/ca.crt&#39;.&#10;Please specify the API bind host/port (optional):&#10;Bind Host []:&#10;Bind Port []:&#10;information/cli: Disabling the Notification feature.&#10;Disabling feature notification. Make sure to restart Icinga 2 for these changes to take effect.&#10;information/cli: Enabling the Apilistener feature.&#10;Enabling feature api. Make sure to restart Icinga 2 for these changes to take effect.&#10;information/cli: Created backup file &#39;/etc/icinga2/features-available/api.conf.orig&#39;.&#10;information/cli: Generating local zones.conf.&#10;information/cli: Dumping config items to file &#39;/etc/icinga2/zones.conf&#39;.&#10;information/cli: Created backup file &#39;/etc/icinga2/zones.conf.orig&#39;.&#10;information/cli: Updating constants.conf.&#10;information/cli: Created backup file &#39;/etc/icinga2/constants.conf.orig&#39;.&#10;information/cli: Updating constants file &#39;/etc/icinga2/constants.conf&#39;.&#10;information/cli: Updating constants file &#39;/etc/icinga2/constants.conf&#39;.&#10;Done.&#10;&#10;Now restart your Icinga 2 daemon to finish the installation!</span><br></pre></td></tr></table></figure>
<p>安装设置过程完成了以下过程：</p>
<ul>
<li>生成一个新的自签名证书并拷贝到 /etc/icinga2/pki；</li>
<li>保存主节点证书到信任证书； </li>
<li>生成一个客户端节点的本地空间和终结点配置；</li>
<li>禁用客户端通知功能；</li>
<li>启用API功能，设置 bind_host 和 bind_port；</li>
<li>在 constants.conf 文件设置 NodeName 常量。</li>
</ul>
<p>验证配置文件并重启 Icinga2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># grep &#39;NodeName&#39; /etc/icinga2/constants.conf&#10;&#10;# cat /etc/icinga2/zones.conf&#10;/*&#10; * Generated by Icinga 2 node setup commands&#10; * on 2015-02-09 16:56:10 +0100&#10; */&#10;&#10;object Endpoint &#34;icinga2-node1.localdomain&#34; &#123;&#10;    host = &#34;192.168.56.101&#34;&#10;&#125;&#10;&#10;object Zone &#34;master&#34; &#123;&#10;    endpoints = [ &#34;icinga2-node1.localdomain&#34; ]&#10;&#125;&#10;&#10;object Endpoint &#34;icinga2-node2.localdomain&#34; &#123;&#10;&#125;&#10;&#10;object Zone &#34;icinga2-node2.localdomain&#34; &#123;&#10;    //this is the local node = &#34;icinga2-node2.localdomain&#34;&#10;    endpoints = [ &#34;icinga2-node2.localdomain&#34; ]&#10;    parent = &#34;master&#34;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h1 id="监控Windows服务器">监控Windows服务器</h1><p>下载 Icinga2 的安装包，网址：<a href="http://packages.icinga.org/windows/" target="_blank" rel="external">http://packages.icinga.org/windows/</a> 。</p>
<p>系统环境需求：</p>
<p>Windows Vista/Server 2008 或者更高；<br>Microsoft .NET Framework 2.0。</p>
<p>通过图形界面配置主节点的IP与端口，配置完成后会创建一个服务，使用以下命令进行配置文件验证：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:&#62; icinga2.exe daemon -C</span><br></pre></td></tr></table></figure>
<p>配置完成远程节点后，你可以在主节点使用以下命令发现节点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># icinga2 node list&#10;Node &#39;icinga2-node2.localdomain&#39; (last seen: Mon Feb  9 16:58:21 2015)&#10;    * Host &#39;icinga2-node2.localdomain&#39;&#10;        * Service &#39;ping4&#39;&#10;        * Service &#39;ping6&#39;&#10;        * Service &#39;ssh&#39;&#10;        * Service &#39;http&#39;&#10;        * Service &#39;disk&#39;&#10;        * Service &#39;disk /&#39;&#10;        * Service &#39;icinga&#39;&#10;        * Service &#39;load&#39;&#10;        * Service &#39;procs&#39;&#10;        * Service &#39;swap&#39;&#10;        * Service &#39;users&#39;</span><br></pre></td></tr></table></figure>
<p>如果未发现你配置的节点，请确保远程节点重启过。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Icinga2可以通过Agent来监控其它设备，这些设备包含各种操作系统的服务器以及网络设备。一些简单的网络指标监控是不需要创建Agent的，例如ping和ssh；但是某些无法通过网络获取的指标则需要在被监测服务器创建一个监控代理来将指标返回给监控服务器。本文将介绍如何在Linux和Windows服务器上安装和配置Agent来实现多机器的监控。</p>]]>
    
    </summary>
    
      <category term="CentOS" scheme="http://www.tnidea.com/tags/CentOS/"/>
    
      <category term="Icinga Web2" scheme="http://www.tnidea.com/tags/Icinga-Web2/"/>
    
      <category term="Icinga2" scheme="http://www.tnidea.com/tags/Icinga2/"/>
    
      <category term="服务器监控" scheme="http://www.tnidea.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%91%E6%8E%A7/"/>
    
      <category term="运维" scheme="http://www.tnidea.com/categories/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Storm适配器(.Net)升级说明以及一些性能数据]]></title>
    <link href="http://www.tnidea.com/dot-net-storm-adapter-upgrade.html"/>
    <id>http://www.tnidea.com/dot-net-storm-adapter-upgrade.html</id>
    <published>2015-12-04T16:00:00.000Z</published>
    <updated>2015-12-05T12:52:05.000Z</updated>
    <content type="html"><![CDATA[<p> <a href="https://github.com/ziyunhx/storm-net-adapter" title="storm-net-adapter" target="_blank" rel="external">storm-net-adapter</a> 是一个使用C#编写的 Apache Storm 适配器；用于在 .Net 环境下开发 Storm 原生支持的拓扑，以及通过DRPC来远程跨语言使用集群计算资源。距离首次介绍已经更新了3个版本，带来了数项功能与性能的改进！下面将对改进部分进行说明。</p>
<a id="more"></a>
<p> 首先，在V1.2版本加入了对DRPC的支持；通过使用DRPC，你可以方便调用任何使用Storm支持语言编写的Topology，你仅需将它们部署到集群。详细介绍可以通过 <a href="http://www.tnidea.com/dot-net-drpc-storm.html">.NET使用DRPC远程调用运行在Storm上的拓扑</a> 和 <a href="http://www.tnidea.com/call-dot-net-drpc-program.html">使用DRPC调用.NET开发的Storm拓扑</a> 来了解。<br> 在刚刚发布的V1.4版本中，对DRPC的支持进一步增强，默认使用线程池来管理连接。在之前的版本中，单机单进程环境下，如果所有并发使用各自连接，并发100的环境下长时间运行会出现连接数过大导致失败；如果使用单连接加锁模式，在并发30的情况下延时以及在5000ms以上。通过使用线程池来控制（默认配置），在生产环境下，峰值200并发的条件下，使用外网访问DRPC的延时保持在200ms内；每日调用量保持在2500万次，单个小时调用量峰值在300万次。Storm集群使用Docker部署在单台服务器上，部署方式可以查看 <a href="http://www.tnidea.com/deploy-storm-by-docker.html">使用Docker快速部署Storm环境</a>。下面是连续10天Storm运行的截图：</p>
<p> <img src="http://www.tnidea.com/media/image/storm-run-status-1.png" alt="Storm UI"></p>
<p> <img src="http://www.tnidea.com/media/image/storm-run-status-2.png" alt="Storm Topology"></p>
<p> 当然，你也可以通过设置 reconnect 和 maxIdle 参数来决定是否使用线程池特性以及最大线程数。</p>
<p> 在V1.3版本，解决了一些在linux环境下运行的Bug，默认demo使用mono来驱动，并将Storm版本选用了0.9.6版本。</p>
<p> 在V1.4版本中，移除了项目对于Json.Net的依赖，采用SimpleJson作为替代；现在，再也不用慢慢等待Nuget的龟速了。另外，该类库支持.Net 3.5及以上；这是由于最新的Thrift并不支持.Net 3.5以下的版本，如果你需要使用更低版本的.Net，你可以从Apache Thrift官方网站下载源码修改后自行编译。</p>
<p> 好了，在未来的版本中，我们还计划增加直接通过.Net打包发布Topology的支持，如果你有什么希望增加或完善的部分，可以通过博客留言、公众号评论、GitHub或邮件与我交流！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p> <a href="https://github.com/ziyunhx/storm-net-adapter" title="storm-net-adapter">storm-net-adapter</a> 是一个使用C#编写的 Apache Storm 适配器；用于在 .Net 环境下开发 Storm 原生支持的拓扑，以及通过DRPC来远程跨语言使用集群计算资源。距离首次介绍已经更新了3个版本，带来了数项功能与性能的改进！下面将对改进部分进行说明。</p>]]>
    
    </summary>
    
      <category term=".NET" scheme="http://www.tnidea.com/tags/NET/"/>
    
      <category term="C#" scheme="http://www.tnidea.com/tags/C/"/>
    
      <category term="DRPC" scheme="http://www.tnidea.com/tags/DRPC/"/>
    
      <category term="Topology" scheme="http://www.tnidea.com/tags/Topology/"/>
    
      <category term="csharp" scheme="http://www.tnidea.com/tags/csharp/"/>
    
      <category term="storm" scheme="http://www.tnidea.com/tags/storm/"/>
    
      <category term="Storm" scheme="http://www.tnidea.com/categories/Storm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用ImitateLogin模拟登录百度]]></title>
    <link href="http://www.tnidea.com/login-baidu-throught-imitate-login.html"/>
    <id>http://www.tnidea.com/login-baidu-throught-imitate-login.html</id>
    <published>2015-11-29T16:00:00.000Z</published>
    <updated>2015-11-30T16:23:54.000Z</updated>
    <content type="html"><![CDATA[<p>在之前的文章中，我已经介绍过一个社交网站模拟登录的类库：<a href="https://github.com/ziyunhx/imitate-login" target="_blank" rel="external">imitate-login</a> ，这是一个通过c#的HttpWebRequest来模拟网站登录的库，之前实现了微博网页版和微博Wap版；现在，模拟百度登录的部分也已经完成。由于个人时间的限制，加上目前有多个项目在同时进行，因此更新频率会根据项目关注度来决定（<strong>Star &amp; fork</strong>）。</p>
 <a id="more"></a>
<p>这个类库的使用方法非常简单，仅对外提供一个方法： </p>
<p><code>LoginResult Login(1: string userName, 2: string password, 3: LoginSite loginSite);</code> </p>
<p>这个方法位于ImitateLogin的LoginHelper类中，使用之前需要先对其进行实例化。通过传入 用户名、密码以及登录的网站，返回一个包含登录结果状态、描述信息和Cookies字典的类。它通过 Thrift 来实现多语言的支持。</p>
<p>下面将通过介绍模拟百度登录的实现来介绍如何进行扩充与二次开发：</p>
<p>首先，创建百度登录类 BaiduLogin.cs 继承 ILogin 接口；实现其生成的 DoLogin 方法。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">region</span> ILogin implementation</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LoginResult <span class="title">DoLogin</span>(<span class="params"><span class="keyword">string</span> UserName, <span class="keyword">string</span> Password</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> CookieContainer cookies &#123; <span class="keyword">set</span>; <span class="keyword">get</span>;&#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endregion</span></span></span><br></pre></td></tr></table></figure>
<p>然后我们通过监听百度登录过程中的网络请求，梳理出修改过Cookies和最终提交登录所需的参数的请求。</p>
<p>Step1: 访问以下链接生成初始Cookies：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">HttpHelper.GetHttpContent(<span class="string">"https://passport.baidu.com/passApi/html/_blank.html"</span>, cookies: cookies, cookiesDomain: <span class="string">"passport.baidu.com"</span>);</span><br></pre></td></tr></table></figure>
<p>Step2: 获取最终登录提交所需的token：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. Get the token.</span></span><br><span class="line"><span class="keyword">string</span> token_url = <span class="keyword">string</span>.Format(<span class="string">"https://passport.baidu.com/v2/api/?getapi&amp;tpl=mn&amp;apiver=v3&amp;tt=&#123;0&#125;&amp;class=login&amp;gid=&#123;1&#125;&amp;logintype=dialogLogin&amp;callback=bd__cbs__&#123;2&#125;"</span>, TimeHelper.ConvertDateTimeInt(DateTime.Now), Guid.NewGuid().ToString().ToUpper(), build_callback());</span><br><span class="line"><span class="keyword">string</span> prepareContent = HttpHelper.GetHttpContent(token_url, <span class="keyword">null</span>, cookies, referer: <span class="string">"https://www.baidu.com/"</span>, encode: Encoding.GetEncoding(<span class="string">"GB2312"</span>), cookiesDomain: <span class="string">"passport.baidu.com"</span>);</span><br><span class="line"><span class="comment">//string prepareJson = prepareContent.Split('(')[1].Split(')')[0];</span></span><br><span class="line"><span class="keyword">dynamic</span> prepareJson = JsonConvert.DeserializeObject(prepareContent.Split(<span class="string">'('</span>)[<span class="number">1</span>].Split(<span class="string">')'</span>)[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">string</span> token = prepareJson.data.token;</span><br></pre></td></tr></table></figure>
<p>其中 build_callback 为随机生成6位字母或数字的组合的方法。</p>
<p>Step3: 获取用于加密密码的publickey：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2. Get public key</span></span><br><span class="line"><span class="keyword">string</span> pubkey_url = <span class="string">"https://passport.baidu.com/v2/getpublickey?token=&#123;0&#125;&amp;tpl=mn&amp;apiver=v3&amp;tt=&#123;1&#125;&amp;gid=&#123;2&#125;&amp;callback=bd__cbs__&#123;3&#125;"</span>;</span><br><span class="line"><span class="keyword">string</span> pubkeyContent = HttpHelper.GetHttpContent(<span class="keyword">string</span>.Format(pubkey_url, token, TimeHelper.ConvertDateTimeInt(DateTime.Now), Guid.NewGuid().ToString().ToUpper(), build_callback()), <span class="keyword">null</span>, cookies, referer: <span class="string">"https://www.baidu.com/"</span>, encode: Encoding.GetEncoding(<span class="string">"GB2312"</span>), cookiesDomain: <span class="string">"passport.baidu.com"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">dynamic</span> pubkeyJson = JsonConvert.DeserializeObject(pubkeyContent.Split(<span class="string">'('</span>)[<span class="number">1</span>].Split(<span class="string">')'</span>)[<span class="number">0</span>]);</span><br><span class="line">rsa_pub_baidu = pubkeyJson.pubkey;</span><br><span class="line"><span class="keyword">string</span> KEY = pubkeyJson.key;</span><br></pre></td></tr></table></figure>
<p>Step4: 模拟执行最终的登录：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3. Build post data</span></span><br><span class="line"><span class="keyword">string</span> login_data = <span class="string">"staticpage=https%3A%2F%2Fwww.baidu.com%2Fcache%2Fuser%2Fhtml%2Fv3Jump.html&amp;charset=UTF-8&amp;token=&#123;0&#125;&amp;tpl=mn&amp;subpro=&amp;apiver=v3&amp;tt=&#123;1&#125;&amp;codestring=&amp;safeflg=0&amp;u=https%3A%2F%2Fwww.baidu.com%2F&amp;isPhone=&amp;detect=1&amp;gid=&#123;2&#125;&amp;quick_user=0&amp;logintype=dialogLogin&amp;logLoginType=pc_loginDialog&amp;idc=&amp;loginmerge=true&amp;splogin=rate&amp;username=&#123;3&#125;&amp;password=&#123;4&#125;&amp;verifycode=&amp;mem_pass=on&amp;rsakey=&#123;5&#125;&amp;crypttype=12&amp;ppui_logintime=&#123;6&#125;&amp;countrycode=&amp;callback=parent.bd__pcbs__&#123;7&#125;"</span>;</span><br><span class="line">login_data = <span class="keyword">string</span>.Format(login_data, token, TimeHelper.ConvertDateTimeInt(DateTime.Now), Guid.NewGuid().ToString().ToUpper(), HttpUtility.UrlEncode(UserName), HttpUtility.UrlEncode(get_pwa_rsa(Password)), HttpUtility.UrlEncode(KEY), stopwatch.ElapsedMilliseconds, build_callback());</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. Post the login data</span></span><br><span class="line"><span class="keyword">string</span> login_url = <span class="string">"https://passport.baidu.com/v2/api/?login"</span>;</span><br><span class="line">HttpHelper.GetHttpContent(login_url, login_data, cookies, referer: <span class="string">"https://www.baidu.com/"</span>, cookiesDomain: <span class="string">"passport.baidu.com"</span>);</span><br></pre></td></tr></table></figure>
<p>stopwatch 是一个记录从最初执行到最终提交之前的耗时的一个计时器，get_pwa_rsa 为加密密码的方法。</p>
<p>Step5：验证最终的登录结果：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span> home_url = <span class="string">"https://www.baidu.com"</span>;</span><br><span class="line"><span class="keyword">string</span> result = HttpHelper.GetHttpContent(home_url, cookies: cookies, cookiesDomain: <span class="string">"passport.baidu.com"</span>);</span><br><span class="line"><span class="comment">//5. Verifty the login result</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">string</span>.IsNullOrWhiteSpace(result) || result.Contains(<span class="string">"账号存在异常"</span>) || !result.Contains(<span class="string">"bds.comm.user=\""</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LoginResult() &#123; Result = ResultType.AccounntLimit, Msg = <span class="string">"Fail, Msg: Login fail! Maybe you account is disable or captcha is needed."</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step6：创建返回结果类：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">LoginResult loginResult = <span class="keyword">new</span> LoginResult() &#123; Result = ResultType.Success, Msg = <span class="string">"Success"</span>, Cookies = HttpHelper.GetAllCookies(cookies) &#125;;</span><br></pre></td></tr></table></figure>
<p>至此，模拟登录部分的代码就完成了，为了能够被其它程序调用，你还需要在 LoginSite 的枚举中新增一条来标识这个登录方法，此处增加了一个 Baidu = 5，并设置 [Description(“Baidu”)]。</p>
<p>然后在 LoginHelper.cs 的 Login 方法中的 switch (loginSite) 里增加一个 case：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> LoginSite.Baidu:</span><br><span class="line">    LoginClass = <span class="keyword">new</span> BaiduLogin ();</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>好了，大功告成！Todo List中还有淘宝、QQ、Facebook、Twitter、Google要做呢，我还想加入GitHub、Wechat…<br>现在，你可以帮我了吗？</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在之前的文章中，我已经介绍过一个社交网站模拟登录的类库：<a href="https://github.com/ziyunhx/imitate-login">imitate-login</a> ，这是一个通过c#的HttpWebRequest来模拟网站登录的库，之前实现了微博网页版和微博Wap版；现在，模拟百度登录的部分也已经完成。由于个人时间的限制，加上目前有多个项目在同时进行，因此更新频率会根据项目关注度来决定（<strong>Star &amp; fork</strong>）。</p>]]>
    
    </summary>
    
      <category term=".NET" scheme="http://www.tnidea.com/tags/NET/"/>
    
      <category term="Baidu" scheme="http://www.tnidea.com/tags/Baidu/"/>
    
      <category term="C#" scheme="http://www.tnidea.com/tags/C/"/>
    
      <category term="csharp" scheme="http://www.tnidea.com/tags/csharp/"/>
    
      <category term="social network" scheme="http://www.tnidea.com/tags/social-network/"/>
    
      <category term="thrift" scheme="http://www.tnidea.com/tags/thrift/"/>
    
      <category term="爬虫" scheme="http://www.tnidea.com/categories/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Docker快速部署Storm环境]]></title>
    <link href="http://www.tnidea.com/deploy-storm-by-docker.html"/>
    <id>http://www.tnidea.com/deploy-storm-by-docker.html</id>
    <published>2015-11-17T16:00:00.000Z</published>
    <updated>2015-11-18T13:34:33.000Z</updated>
    <content type="html"><![CDATA[<p>Storm的部署虽然不是特别麻烦，但是在生产环境中，为了提高部署效率，方便管理维护，使用Docker来统一管理部署是一个不错的选择。下面是我开源的一个新的项目，一个配置好了storm与mono环境的Docker镜像编排：<a href="https://github.com/ziyunhx/storm-mono-docker" target="_blank" rel="external">storm-mono-docker</a>。</p>
<a id="more"></a>
<p>这个项目得益于<a href="https://github.com/ptgoetz/storm-vagrant" target="_blank" rel="external">https://github.com/ptgoetz/storm-vagrant</a>和<a href="https://github.com/wurstmeister/storm-docker" target="_blank" rel="external">https://github.com/wurstmeister/storm-docker</a>；在此感谢他们的付出！<br>项目使用的Docker镜像托管在 <a href="https://index.docker.io" target="_blank" rel="external">https://index.docker.io</a>。</p>
<h2 id="准备工作">准备工作</h2><ul>
<li><p>安装 Docker Engine，<a href="https://docs.docker.com/" target="_blank" rel="external">https://docs.docker.com/</a></p>
</li>
<li><p>安装 docker-compose <a href="http://docs.docker.com/compose/install/" target="_blank" rel="external">http://docs.docker.com/compose/install/</a></p>
</li>
<li><p>克隆git项目： </p>
<pre><code>git clone <span class="string">https:</span><span class="comment">//github.com/ziyunhx/storm-mono-docker</span>
</code></pre></li>
</ul>
<h2 id="使用">使用</h2><p>首先将命令行目录切换到刚刚克隆下来的git项目目录；</p>
<p>通过以下命令启动集群：</p>
<pre><code>docker-compose up <span class="operator">-d</span>
</code></pre><ul>
<li>你也可以使用 docker-compose up 命令来将结果输出到当前命令行界面，但是在你结束它之前无法进行任何其它操作，而一旦命令行退出，所有的容器都将停止。而 docker-compose up -d 将在后台启动所有容器。</li>
</ul>
<p>停止这个集群的所有容器：</p>
<pre><code>docker-compose <span class="keyword">stop</span>
</code></pre><p>容器一旦停止，下次直接启动将无法正常链接容器，导致storm运行异常，你可以在结束后使用以下命令结束和移除所有的Docker缓存：</p>
<pre><code>docker kill $<span class="comment">(docker ps -q)</span> ; docker rm $<span class="comment">(docker ps -a -q)</span>
</code></pre><p>增加更多的supervisors：</p>
<pre><code>docker-compose scale supervisor=<span class="number">4</span>
</code></pre><p>使用以下命令删除所有的镜像文件（小心，这会让你下一次启动时花费更多时间下载容器，仅在不想继续使用时执行）：</p>
<pre><code>docker rmi $<span class="comment">(docker images -q -a)</span>
</code></pre><h2 id="重新构建和更新">重新构建和更新</h2><p>你可以在修改Dockerfile后使用以下命令来重新构建镜像：rebuild.sh ；</p>
<p>使用以下命令来更新镜像到最新版本：refresh.sh 。</p>
<h2 id="问与答">问与答</h2><h3 id="如何访问Storm_UI来查看运行状况？">如何访问Storm UI来查看运行状况？</h3><p>在docker-compose.yml中有下面这段配置：</p>
<pre><code><span class="attribute">ui</span>:
  <span class="attribute">image</span>: ziyunhx/storm-ui
      <span class="attribute">ports</span>:
        - <span class="string">"49080:8080"</span>
</code></pre><p>它告诉我们将Docker镜像的8080端口映射到了主机的49080，因此你可以通过访问 <a href="http://localhost:49080" target="_blank" rel="external">http://localhost:49080</a> 来访问。如果你使用 boot2docker ，你可以通过以下命令得到虚拟机的IP：</p>
<pre><code>$ <span class="keyword">boot2docker </span><span class="literal">ip</span>
<span class="label">The</span> VM<span class="string">'s Host only interface IP address is: 192.168.59.103</span>
</code></pre><p>返回的结果就是你的IP，本例中可以通过 <a href="http://192.168.59.103:49080" target="_blank" rel="external">http://192.168.59.103:49080</a> 来访问。</p>
<h3 id="如何部署提交一个topology？">如何部署提交一个topology？</h3><p>如果 nimbus 的IP与端口不是默认的，你需要指定它们后来提交，本例中可以使用以下命令：</p>
<pre><code>storm jar target/your-topology-fat-jar<span class="class">.jar</span> com<span class="class">.your</span><span class="class">.package</span><span class="class">.AndTopology</span> topology-name -c nimbus.host=<span class="number">192.168</span>.<span class="number">59.103</span> -c nimbus<span class="class">.thrift</span><span class="class">.port</span>=<span class="number">49627</span>
</code></pre><p>如果上述命令没有起作用，你可以在本地的Storm配置文件（storm.yaml）配置以下项：</p>
<pre><code>nimbus<span class="class">.host</span>: <span class="string">"192.168.59.103"</span>    
nimbus<span class="class">.thrift</span><span class="class">.port</span>: <span class="number">49627</span>
</code></pre><p>然后执行以下命令提交：</p>
<pre><code>storm jar target/your-topology-fat-jar<span class="class">.jar</span> com<span class="class">.your</span><span class="class">.package</span><span class="class">.AndTopology</span> topology-name
</code></pre><h3 id="如何连接我的容器?">如何连接我的容器?</h3><p>通过使用 docker-compose ps 找到你希望连接的容器的ssh端口，然后通过ssh连接：</p>
<pre><code>$ ssh root@`boot2docker ip` -p <span class="variable">$CONTAINER</span>_PORT
</code></pre><p>密码是 ‘ziyunhxpass’ （位于：<a href="https://registry.hub.docker.com/u/ziyunhx/base/dockerfile/）。" target="_blank" rel="external">https://registry.hub.docker.com/u/ziyunhx/base/dockerfile/）。</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Storm的部署虽然不是特别麻烦，但是在生产环境中，为了提高部署效率，方便管理维护，使用Docker来统一管理部署是一个不错的选择。下面是我开源的一个新的项目，一个配置好了storm与mono环境的Docker镜像编排：<a href="https://github.com/ziyunhx/storm-mono-docker">storm-mono-docker</a>。</p>]]>
    
    </summary>
    
      <category term=".NET" scheme="http://www.tnidea.com/tags/NET/"/>
    
      <category term="C#" scheme="http://www.tnidea.com/tags/C/"/>
    
      <category term="Docker" scheme="http://www.tnidea.com/tags/Docker/"/>
    
      <category term="csharp" scheme="http://www.tnidea.com/tags/csharp/"/>
    
      <category term="mono" scheme="http://www.tnidea.com/tags/mono/"/>
    
      <category term="storm" scheme="http://www.tnidea.com/tags/storm/"/>
    
      <category term="Storm" scheme="http://www.tnidea.com/categories/Storm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[安装与配置Icinga Web2]]></title>
    <link href="http://www.tnidea.com/setting-up-icinga-web2.html"/>
    <id>http://www.tnidea.com/setting-up-icinga-web2.html</id>
    <published>2015-10-29T16:00:00.000Z</published>
    <updated>2015-10-29T15:03:56.000Z</updated>
    <content type="html"><![CDATA[<p>Icinga Web2是Icinga2的Web前端展示界面之一，它也是支持Icinga2的Web界面中我个人最喜欢的。通过Icinga Web2，你可以方便的展示与管理你的监控，也可以自定义一些显示模块。本文将介绍Icinga Web2的安装与配置，其中部分经验可能在Icinga2的其它Web界面也适用。</p>
<a id="more"></a>
<h3 id="设置包管理库">设置包管理库</h3><p>你需要使用以下命令将Icinga2的所在的包管理库加入到你的系统中，如果你按照我之前的文章操作的话，其实这步已经做过了。</p>
<p>Debian (debmon):</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -O - http://debmon.org/debmon/repo.key 2&#62;/dev/null | apt-key add -&#10;echo &#39;deb http://debmon.org/debmon debmon-wheezy main&#39; &#62;/etc/apt/sources.list.d/debmon.list&#10;apt-get update</span><br></pre></td></tr></table></figure>
<p>Ubuntu Trusty:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -O - http://packages.icinga.org/icinga.key | apt-key add -&#10;add-apt-repository &#39;deb http://packages.icinga.org/ubuntu icinga-trusty main&#39;&#10;apt-get update</span><br></pre></td></tr></table></figure>
<p>如果你使用的是其它的Ubuntu版本，只需要将trusty替换成你实际环境的名字。</p>
<p>RHEL 和 CentOS:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm --import http://packages.icinga.org/icinga.key&#10;curl -o /etc/yum.repos.d/ICINGA-release.repo http://packages.icinga.org/epel/ICINGA-release.repo&#10;yum makecache</span><br></pre></td></tr></table></figure>
<p>Fedora:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm --import http://packages.icinga.org/icinga.key&#10;curl -o /etc/yum.repos.d/ICINGA-release.repo http://packages.icinga.org/fedora/ICINGA-release.repo&#10;yum makecache</span><br></pre></td></tr></table></figure>
<p>SLES 11:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zypper ar http://packages.icinga.org/SUSE/ICINGA-release-11.repo&#10;zypper ref</span><br></pre></td></tr></table></figure>
<p>SLES 12:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zypper ar http://packages.icinga.org/SUSE/ICINGA-release.repo&#10;zypper ref</span><br></pre></td></tr></table></figure>
<p>openSUSE:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zypper ar http://packages.icinga.org/openSUSE/ICINGA-release.repo&#10;zypper ref</span><br></pre></td></tr></table></figure>
<p>RHEL/CentOS的软件包依赖于EPEL，确保你已经配置了它！这步应该在安装Icinga2时已经完成。<br>Debian wheezy的软件包依赖于wheezy-packports库，请在安装前启用它。</p>
<h3 id="安装_Icinga_Web2">安装 Icinga Web2</h3><p>你可以通过系统的包管理器来安装Icinga Web2，下面是一些系统的具体命令：</p>
<p>Debian 和 Ubuntu:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install icingaweb2</span><br></pre></td></tr></table></figure>
<p>RHEL, CentOS 和 Fedora:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install icingaweb2 icingacli</span><br></pre></td></tr></table></figure>
<p>Debian wheezy/RHEL/CentOS用户请仔细阅读包管理库的提示。</p>
<p>SLES 和 openSUSE:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zypper install icingaweb2 icingacli</span><br></pre></td></tr></table></figure>
<h3 id="配置Icinga_Web2">配置Icinga Web2</h3><p>你可以通过Icinga Web2配置向导，或者直接通过执行命令来完成配置，本文仅介绍通过配置向导来完成配置，如果需要使用命令行来完成，请查看 Icinga Web 2官方文档。</p>
<p>STEP 1: 通过icingacli创建一个token，用来安装Icinga Web2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">icingacli setup token create&#10;icingacli setup token show</span><br></pre></td></tr></table></figure>
<p>STEP 2: 使用浏览器访问 <a href="http://127.0.0.1/icingaweb2/setup" target="_blank" rel="external">http://127.0.0.1/icingaweb2/setup</a> （将IP替换为实际IP或域名），将上一步命令行得到的token输入到Steup Token的输入框中，继续下一步。</p>
<p> <img src="http://www.tnidea.com/media/image/icinga-websetup-1.png" alt="Image"></p>
<p>STEP 3: 根据需要选择需要安装的模块，我这边选择了除翻译外的所有模块。</p>
<p> <img src="http://www.tnidea.com/media/image/icinga-websetup-2.png" alt="Image"></p>
<p>STEP 4: 根据系统检查结果，解决需要修改的项，全部完成后刷新确认。</p>
<p> <img src="http://www.tnidea.com/media/image/icinga-websetup-3.png" alt="Image"></p>
<p>本例中，需要解决的有PHP时区，LDAP，PDO-MySQL，PDO-PostgreSQL问题。PDO-MySQL，PDO-PostgreSQL只需要重启Web服务器即可解决。</p>
<p>修改PHP时区：<br><code>使用 vi 打开 /etc/php.ini；查找 date.timezone，删除最前面的分号，在结尾增加时区标签，这里使用： Asia/Shanghai 。</code></p>
<p>启用LDAP：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install php-ldap</span><br></pre></td></tr></table></figure></p>
<p>重启Web服务器，CentOS 7直接使用 systemctl restart httpd 重启。<br>现在界面上所有的状态应该都已经变成了绿色，继续下一步吧，后面没有特别讲到的步骤都是直接点击下一步的！</p>
<p>STEP 5: 配置Icinga Web2数据库</p>
<p> <img src="http://www.tnidea.com/media/image/icinga-websetup-4.png" alt="Image"></p>
<p>此处直接填写我们创建的icingaweb2数据库的信息，默认情况下用户名和密码都是icingaweb2。由于我们并没有给予icingaweb2用户创建表的权限，因此你还需要给一个有创建数据库和表权限的用户。</p>
<p><img src="http://www.tnidea.com/media/image/icinga-websetup-5.png" alt="Image"></p>
<p>STEP 6: 创建一个Icinga Web2的管理员账号</p>
<p><img src="http://www.tnidea.com/media/image/icinga-websetup-6.png" alt="Image"></p>
<p>STEP 7: 配置Icinga IDO数据库信息</p>
<p><img src="http://www.tnidea.com/media/image/icinga-websetup-7.png" alt="Image"></p>
<p>此处直接填写我们创建的icinga数据库的信息，默认情况下用户名和密码都是icinga。</p>
<p>ok! 一切就绪，登陆进去瞅瞅吧！</p>
<p><img src="http://www.tnidea.com/media/image/icinga-websetup-8.png" alt="Image"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Icinga Web2是Icinga2的Web前端展示界面之一，它也是支持Icinga2的Web界面中我个人最喜欢的。通过Icinga Web2，你可以方便的展示与管理你的监控，也可以自定义一些显示模块。本文将介绍Icinga Web2的安装与配置，其中部分经验可能在Icinga2的其它Web界面也适用。</p>]]>
    
    </summary>
    
      <category term="CentOS" scheme="http://www.tnidea.com/tags/CentOS/"/>
    
      <category term="Icinga Web2" scheme="http://www.tnidea.com/tags/Icinga-Web2/"/>
    
      <category term="Icinga2" scheme="http://www.tnidea.com/tags/Icinga2/"/>
    
      <category term="服务器监控" scheme="http://www.tnidea.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%91%E6%8E%A7/"/>
    
      <category term="运维" scheme="http://www.tnidea.com/categories/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[安装Icinga Web2所需服务]]></title>
    <link href="http://www.tnidea.com/prepare-for-setting-up-icinga-web2.html"/>
    <id>http://www.tnidea.com/prepare-for-setting-up-icinga-web2.html</id>
    <published>2015-10-24T16:00:00.000Z</published>
    <updated>2015-10-29T13:01:55.000Z</updated>
    <content type="html"><![CDATA[<p>Icinga Web2是Icinga2的Web前端展示界面之一，它也是支持Icinga2的Web界面中我个人最喜欢的。通过Icinga Web2，你可以方便的展示与管理你的监控，也可以自定义一些显示模块。本文将介绍Icinga Web2的安装与配置，其中部分经验可能在Icinga2的其它Web界面也适用。</p>
<a id="more"></a>
<p>Icinga2通过DB IDO模块将所有配置与状态信息都保存在一个数据库中，这些数据会被Icinga Web2，Icinga Reporting或Icinga Web 1.x使用。</p>
<p>目前Icinga2支持使用MySQL和PostgreSQL作为后端数据库，本文仅介绍MySQL作为后端数据库的情况，如果你使用PostgreSQL，请依据官方文档配置好PostgreSQL。</p>
<h3 id="安装MySQL数据库服务">安装MySQL数据库服务</h3><p>Debian/Ubuntu:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ apt-get install mysql-server mysql-client</span><br></pre></td></tr></table></figure>
<p>RHEL/CentOS 5/6:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ yum install mysql-server mysql&#10;$ chkconfig mysqld on&#10;$ service mysqld start&#10;$ mysql_secure_installation</span><br></pre></td></tr></table></figure>
<p>RHEL/CentOS 7 和 Fedora:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ yum install mariadb-server mariadb&#10;$ systemctl enable mariadb&#10;$ systemctl start mariadb&#10;$ mysql_secure_installation</span><br></pre></td></tr></table></figure>
<p>SUSE:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ zypper install mysql mysql-client&#10;$ chkconfig mysqld on&#10;$ service mysqld start</span><br></pre></td></tr></table></figure>
<p>FreeBSD:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pkg install mysql56-server&#10;$ sysrc mysql_enable=yes&#10;$ service mysql-server restart&#10;$ mysql_secure_installation</span><br></pre></td></tr></table></figure>
<h3 id="安装MySQL的IDO模块">安装MySQL的IDO模块</h3><p>通过默认的包管理器安装icinga2-ido-mysql包：</p>
<p>Debian/Ubuntu:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ apt-get install icinga2-ido-mysql</span><br></pre></td></tr></table></figure>
<p>RHEL/CentOS:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ yum install icinga2-ido-mysql</span><br></pre></td></tr></table></figure>
<p>SUSE:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ zypper install icinga2-ido-mysql</span><br></pre></td></tr></table></figure>
<p>FreeBSD:</p>
<p>FreeBSD的MySQL IDO模块已经包含在icinga2包中，位于 /usr/local/share/icinga2-ido-mysql/schema/mysql.sql。</p>
<p>注意：Debian/Ubuntu的包中提供了一个数据库配置向导，你可以根据个人喜好来选择是否使用它。</p>
<h3 id="设置MySQL数据库">设置MySQL数据库</h3><p>为Icinga 2设置一个MySQL数据库:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mysql -u root -p&#10;&#10;mysql&#62;  CREATE DATABASE icinga;&#10;        GRANT SELECT, INSERT, UPDATE, DELETE, DROP, CREATE VIEW, INDEX, EXECUTE ON icinga.* TO &#39;icinga&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;icinga&#39;;</span><br></pre></td></tr></table></figure>
<p>在创建数据库完成后，使用以下命令导入Icinga2 IDO数据库结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mysql -u root -p icinga &#60; /usr/share/icinga2-ido-mysql/schema/mysql.sql</span><br></pre></td></tr></table></figure>
<p>为了使用Icinga Web2，我们为Icinga Web2也创建一个空的数据库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mysql -u root -p&#10;&#10;mysql&#62;  CREATE DATABASE icingaweb2;&#10;        GRANT SELECT, INSERT, UPDATE, DELETE, DROP, CREATE VIEW, INDEX, EXECUTE ON icingaweb2.* TO &#39;icingaweb2&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;icingaweb2&#39;;&#10;        quit</span><br></pre></td></tr></table></figure>
<p>启用MySQL IDO模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ icinga2 feature enable ido-mysql</span><br></pre></td></tr></table></figure>
<p>启用后别忘了重启Icinga2服务：</p>
<p>Debian/Ubuntu, RHEL/CentOS 6 和 SUSE:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ service icinga2 restart</span><br></pre></td></tr></table></figure>
<p>RHEL/CentOS 7 和 Fedora:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ systemctl restart icinga2</span><br></pre></td></tr></table></figure>
<p>FreeBSD:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ service icinga2 restart</span><br></pre></td></tr></table></figure>
<h3 id="安装Web服务">安装Web服务</h3><p>Debian/Ubuntu:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ apt-get install apache2</span><br></pre></td></tr></table></figure>
<p>RHEL/CentOS 6:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ yum install httpd&#10;$ chkconfig httpd on&#10;$ service httpd start</span><br></pre></td></tr></table></figure>
<p>RHEL/CentOS 7/Fedora:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ yum install httpd&#10;$ systemctl enable httpd&#10;$ systemctl start httpd</span><br></pre></td></tr></table></figure>
<p>SUSE:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ zypper install apache2&#10;$ chkconfig on&#10;$ service apache2 start</span><br></pre></td></tr></table></figure>
<p>FreeBSD (nginx，你也可以使用 apache24 来作为Web服务)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pkg install nginx php56-gettext php56-ldap php56-openssl php56-mysql php56-pdo_mysql php56-pgsql php56-pdo_pgsql php56-sockets php56-gd pecl-imagick pecl-intl&#10;$ sysrc php_fpm_enable=yes&#10;$ sysrc nginx_enable=yes&#10;$ sed -i &#39;&#39; &#34;s/listen\ =\ 127.0.0.1:9000/listen\ =\ \/var\/run\/php5-fpm.sock/&#34; /usr/local/etc/php-fpm.conf&#10;$ sed -i &#39;&#39; &#34;s/;listen.owner/listen.owner/&#34; /usr/local/etc/php-fpm.conf&#10;$ sed -i &#39;&#39; &#34;s/;listen.group/listen.group/&#34; /usr/local/etc/php-fpm.conf&#10;$ sed -i &#39;&#39; &#34;s/;listen.mode/listen.mode/&#34; /usr/local/etc/php-fpm.conf&#10;$ service php-fpm start&#10;$ service nginx start</span><br></pre></td></tr></table></figure>
<h3 id="配置防火墙规则">配置防火墙规则</h3><p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ iptables -A INPUT -p tcp -m tcp --dport 80 -j ACCEPT&#10;$ service iptables save</span><br></pre></td></tr></table></figure>
<p>RHEL/CentOS 7 使用下面命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ firewall-cmd --add-service=http&#10;$ firewall-cmd --permanent --add-service=http</span><br></pre></td></tr></table></figure>
<h3 id="配置额外的命令通道">配置额外的命令通道</h3><p>Web接口和一些其它模块通过额外的命令通道来向Icinga2发送命令，你可以使用下面的命令启用它： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ icinga2 feature enable command</span><br></pre></td></tr></table></figure>
<p>同样，你需要重启Icinga2服务来使它生效。</p>
<p>默认情况下，icingacmd用户组拥有读写命令通道文件的权限，因此你需要使用下面的命令将Web服务的用户加入到该组：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ usermod -a -G icingacmd www-data</span><br></pre></td></tr></table></figure>
<p>FreeBSD: www用户组拥有文件的读写权限，你不需要额外操作什么。</p>
<p>Debian包使用nagios作为默认用户名和用户组，因此你需要将上述命令中的icingacmd修改为nagios。</p>
<p>Web服务的用户名在不同的环境下是不同的，因此你可以尝试修改www-data为wwwrun、www、或者 apache。</p>
<p>你可以使用以下命令来检测是否成功将用户加入到icingacmd用户组：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ id &#60;your-webserver-user&#62;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>Icinga Web2是Icinga2的Web前端展示界面之一，它也是支持Icinga2的Web界面中我个人最喜欢的。通过Icinga Web2，你可以方便的展示与管理你的监控，也可以自定义一些显示模块。本文将介绍Icinga Web2的安装与配置，其中部分经验可能在Icinga2的其它Web界面也适用。</p>]]>
    
    </summary>
    
      <category term="CentOS" scheme="http://www.tnidea.com/tags/CentOS/"/>
    
      <category term="Icinga Web2" scheme="http://www.tnidea.com/tags/Icinga-Web2/"/>
    
      <category term="Icinga2" scheme="http://www.tnidea.com/tags/Icinga2/"/>
    
      <category term="服务器监控" scheme="http://www.tnidea.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%91%E6%8E%A7/"/>
    
      <category term="运维" scheme="http://www.tnidea.com/categories/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Icinga2和Icinga Web2搭建监控服务]]></title>
    <link href="http://www.tnidea.com/monitor-system-by-icinga2.html"/>
    <id>http://www.tnidea.com/monitor-system-by-icinga2.html</id>
    <published>2015-10-09T16:00:00.000Z</published>
    <updated>2015-10-11T16:00:41.000Z</updated>
    <content type="html"><![CDATA[<p>监控是系统运维的基础，Icinga是一个开源的监控系统框架，通过其广泛的插件支持，你可以监控几乎任何你能想到的网络资源；也可以在超过临界值时给予通知，根据监控数据生产报表。本文主要介绍其搭建过程，大部分内容翻译自官方文档。</p>
<a id="more"></a>
<p>在使用Icinga2前，我们曾经自己编写过监控框架，也用过其它的类似监控系统和在线服务。功能都大同小异，现在之所以选择Icinga2 + Icinga Web2来构建整个系统的监控平台主要是由于其高度可自定义性以及广泛的插件。但是由于该版本发布时间比较短，国内少有将最新版本用于生产环境，导致文档较少，很多问题需要自行摸索。写这个系列文章也是想将自己遇到的坑列出来让其它人少走弯路。</p>
<p>下面将介绍Icinga2与Icinga Web2的安装，所有的操作步骤均仅在CentOS 7上验证（特殊说明的除外），不保证其它系统下的完备性。</p>
<h2 id="安装Icinga2">安装Icinga2</h2><h3 id="设置Icinga2安装源">设置Icinga2安装源</h3><p>首先你要根据你的系统选择执行下面的命令将Icinga2的项目库地址加入到包管理中。</p>
<p>Debian (debmon):</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ wget -O - http://debmon.org/debmon/repo.key 2&#62;/dev/null | apt-key add -&#10;$ echo &#39;deb http://debmon.org/debmon debmon-jessie main&#39; &#62;/etc/apt/sources.list.d/debmon.list&#10;$ apt-get update</span><br></pre></td></tr></table></figure>
<p>Ubuntu (PPA):</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ add-apt-repository ppa:formorer/icinga&#10;$ apt-get update</span><br></pre></td></tr></table></figure>
<p>RHEL/CentOS:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ rpm --import http://packages.icinga.org/icinga.key&#10;$ curl -o /etc/yum.repos.d/ICINGA-release.repo http://packages.icinga.org/epel/ICINGA-release.repo&#10;$ yum makecache</span><br></pre></td></tr></table></figure>
<ul>
<li>这个软件包依赖于<a href="http://fedoraproject.org/wiki/EPEL" title="EPEL" target="_blank" rel="external">EPEL库</a>中的其它软件包，请确保以及允许了<a href="http://fedoraproject.org/wiki/EPEL" title="EPEL" target="_blank" rel="external">EPEL库</a>。CentOS 7可以直接通过以下命令来安装：$ yum install epel-release</li>
</ul>
<p>Fedora:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ rpm --import http://packages.icinga.org/icinga.key&#10;$ curl -o /etc/yum.repos.d/ICINGA-release.repo http://packages.icinga.org/fedora/ICINGA-release.repo&#10;$ yum makecache</span><br></pre></td></tr></table></figure>
<p>SLES 11:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ zypper ar http://packages.icinga.org/SUSE/ICINGA-release-11.repo&#10;$ zypper ref</span><br></pre></td></tr></table></figure>
<ul>
<li>这个软件包依赖于openssl1，它是SLES 11安全模块的一部分。</li>
</ul>
<p>SLES 12:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ zypper ar http://packages.icinga.org/SUSE/ICINGA-release.repo&#10;$ zypper ref</span><br></pre></td></tr></table></figure>
<p>openSUSE:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ zypper ar http://packages.icinga.org/openSUSE/ICINGA-release.repo&#10;$ zypper ref</span><br></pre></td></tr></table></figure>
<h3 id="安装Icinga2-1">安装Icinga2</h3><p>Debian/Ubuntu:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ apt-get install icinga2</span><br></pre></td></tr></table></figure>
<p>RHEL/CentOS 5/6:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ yum install icinga2&#10;$ chkconfig icinga2 on&#10;$ service icinga2 start</span><br></pre></td></tr></table></figure>
<p>RHEL/CentOS 7 和 Fedora:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ yum install icinga2&#10;$ systemctl enable icinga2&#10;$ systemctl start icinga2</span><br></pre></td></tr></table></figure>
<p>SLES/openSUSE:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ zypper install icinga2</span><br></pre></td></tr></table></figure>
<h3 id="在安装过程中启用功能">在安装过程中启用功能</h3><p>在默认安装中，启用了checker mainlog notification这三个功能，你可以通过执行以下命令来获取当前开启和关闭的所有功能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ icinga2 feature list</span><br></pre></td></tr></table></figure>
<p>如果你希望开启或关闭某个功能，可以enable/disable命令，例如我们现在开启command功能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ icinga2 feature enable command</span><br></pre></td></tr></table></figure>
<ul>
<li>如果你启用了某个功能导致在接下来的启动过程中出现错误，记得回来关闭掉！</li>
</ul>
<h3 id="文件默认位置">文件默认位置</h3><table>
<thead>
<tr>
<th>路径</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>/etc/icinga2</td>
<td>包含Icinga2所有的配置文件</td>
</tr>
<tr>
<td>/etc/init.d/icinga2</td>
<td>Icinga2的启动脚本</td>
</tr>
<tr>
<td>/usr/sbin/icinga2</td>
<td>Icinga2程序目录</td>
</tr>
<tr>
<td>/usr/share/doc/icinga2</td>
<td>Icinga2的文档目录</td>
</tr>
<tr>
<td>/usr/share/icinga2/include</td>
<td>模板库和插件命令配置</td>
</tr>
<tr>
<td>/var/run/icinga2</td>
<td>程序运行PID文件</td>
</tr>
<tr>
<td>/var/run/icinga2/cmd</td>
<td>命令通道和状态套接字</td>
</tr>
<tr>
<td>/var/cache/icinga2</td>
<td>缓存、调试、状态文件</td>
</tr>
<tr>
<td>/var/spool/icinga2</td>
<td>用于性能数据脱机文件</td>
</tr>
<tr>
<td>/var/lib/icinga2</td>
<td>状态文件，集群日志，本地证书和配置文件</td>
</tr>
<tr>
<td>/var/log/icinga2</td>
<td>CompatLogger功能产生的日志文件以及相关工具目录</td>
</tr>
</tbody>
</table>
<h2 id="安装Check插件">安装Check插件</h2><p>Icinga2只是一个监控框架，如果没有插件，它将不知道如何检查外部服务。Icinga2是从nagios发展而来，因此它兼容nagios的插件。你可以直接使用包管理工具来安装插件包，下表将列出插件包得名称和默认安装路径。</p>
<table>
<thead>
<tr>
<th>操作系统</th>
<th>包名称</th>
<th>安装路径</th>
</tr>
</thead>
<tbody>
<tr>
<td>RHEL/CentOS (EPEL)</td>
<td>nagios-plugins-all</td>
<td>/usr/lib/nagios/plugins 或 /usr/lib64/nagios/plugins</td>
</tr>
<tr>
<td>Debian</td>
<td>nagios-plugins</td>
<td>/usr/lib/nagios/plugins</td>
</tr>
<tr>
<td>FreeBSD</td>
<td>nagios-plugins</td>
<td>/usr/local/libexec/nagios</td>
</tr>
<tr>
<td>OS X (MacPorts)</td>
<td>nagios-plugins</td>
<td>/opt/local/libexec</td>
</tr>
</tbody>
</table>
<p>根据安装目录的差异，你可能需要修改Icinga2的配置来指定插件包得安装位置。配置文件为 /etc/icinga2/constants.conf，修改PluginDir的值为插件目录即可。</p>
<h2 id="运行Icinga2">运行Icinga2</h2><h3 id="启动脚本">启动脚本</h3><p>根据上面的文件位置表格，我们知道Icinga2的默认启动脚本位于： /etc/init.d/icinga2。</p>
<p>具体命令使用格式为 /etc/init.d/icinga2 {start|stop|restart|reload|checkconfig|status} ；命令具体含义与一般服务相同。</p>
<p>对于部分操作系统，例如：Fedora，openSUSE 和 RHEL/CentOS 7 可以使用服务来操作，Icinga2在安装时已经安装了必要的服务。</p>
<p>例如你可以使用以下命令来检查Icinga2的运行状态：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ systemctl status icinga2</span><br></pre></td></tr></table></figure>
<p>将Icinga2设置为自启动：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ systemctl enable icinga2</span><br></pre></td></tr></table></figure>
<p>以及重启Icinga2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ systemctl restart icinga2</span><br></pre></td></tr></table></figure>
<p>如果启动出错，别忘了检查插件以及配置文件，你也可以使用 journalctl -xn 来查看错误信息。由于篇幅过长，Icinga Web2的安装与配置将放到下篇博客中！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>监控是系统运维的基础，Icinga是一个开源的监控系统框架，通过其广泛的插件支持，你可以监控几乎任何你能想到的网络资源；也可以在超过临界值时给予通知，根据监控数据生产报表。本文主要介绍其搭建过程，大部分内容翻译自官方文档。</p>]]>
    
    </summary>
    
      <category term="CentOS" scheme="http://www.tnidea.com/tags/CentOS/"/>
    
      <category term="Icinga Web2" scheme="http://www.tnidea.com/tags/Icinga-Web2/"/>
    
      <category term="Icinga2" scheme="http://www.tnidea.com/tags/Icinga2/"/>
    
      <category term="服务器监控" scheme="http://www.tnidea.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%91%E6%8E%A7/"/>
    
      <category term="运维" scheme="http://www.tnidea.com/categories/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用DRPC调用.NET开发的Storm拓扑]]></title>
    <link href="http://www.tnidea.com/call-dot-net-drpc-program.html"/>
    <id>http://www.tnidea.com/call-dot-net-drpc-program.html</id>
    <published>2015-09-11T16:00:00.000Z</published>
    <updated>2015-10-29T13:01:55.000Z</updated>
    <content type="html"><![CDATA[<p> 在上一篇文章里介绍了.Net版本的DRPC的类库，结尾处的例子使用了Java版 BasicDRPCTopology ，本文我将介绍如何使用C#来开发 Storm Topology 并供远程DRPC调用，这篇文章将作为.Net Storm系列文章的一个暂时的结束，新的文章将随着 <a href="https://github.com/ziyunhx/storm-net-adapter" title="storm-net-adapter" target="_blank" rel="external">storm-net-adapter</a> 新特性来更新!</p>
<a id="more"></a>
<p> 在开始介绍具体代码之前，我们先回顾一下DRPC的数据流图：</p>
<p> <img src="http://www.tnidea.com/media/image/drpc-workflow.png" alt="DRPC-workflow"></p>
<p> 从图中可以看到，DRPC实际上并不会影响的具体的业务逻辑代码的编写，只是在传入参数中增加了一个 request-id 用于辨别任务，在结束时增加了一个 return-info 用来返回结果。那么，在Bolt的编写中，我们为每一个Bolt的输入输出增加一个 id 参数来标识任务，在结束时额外增加一个返回结果的参数。我们还是写一个简单的字符操作的例子。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Storm;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">StormSample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SimpleDRPC</span> : <span class="title">IBolt</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> Context ctx;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span>  Implements of delegate "newPlugin", which is used to create a instance of this spout/bolt</span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="ctx"&gt;</span>Context instance<span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;returns&gt;</span><span class="xmlDocTag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SimpleDRPC <span class="title">Get</span>(<span class="params">Context ctx</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SimpleDRPC(ctx);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SimpleDRPC</span>(<span class="params">Context ctx</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            Context.Logger.Info(<span class="string">"SimpleDRPC constructor called"</span>);</span><br><span class="line">            <span class="keyword">this</span>.ctx = ctx;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Declare Input and Output schemas</span></span><br><span class="line">            Dictionary&lt;<span class="keyword">string</span>, List&lt;Type&gt;&gt; inputSchema = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, List&lt;Type&gt;&gt;();</span><br><span class="line">            inputSchema.Add(<span class="string">"default"</span>, <span class="keyword">new</span> List&lt;Type&gt;() &#123; <span class="keyword">typeof</span>(<span class="keyword">string</span>), <span class="keyword">typeof</span>(<span class="keyword">object</span>) &#125;);</span><br><span class="line">            Dictionary&lt;<span class="keyword">string</span>, List&lt;Type&gt;&gt; outputSchema = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, List&lt;Type&gt;&gt;();</span><br><span class="line">            outputSchema.Add(<span class="string">"default"</span>, <span class="keyword">new</span> List&lt;Type&gt;() &#123; <span class="keyword">typeof</span>(<span class="keyword">string</span>), <span class="keyword">typeof</span>(<span class="keyword">object</span>) &#125;);</span><br><span class="line">            <span class="keyword">this</span>.ctx.DeclareComponentSchema(<span class="keyword">new</span> ComponentStreamSchema(inputSchema, outputSchema));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params">StormTuple tuple</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            Context.Logger.Info(<span class="string">"SimpleDRPC Execute enter"</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">string</span> sentence = tuple.GetString(<span class="number">0</span>) + <span class="string">"!"</span>;</span><br><span class="line">            <span class="keyword">this</span>.ctx.Emit(<span class="string">"default"</span>, <span class="keyword">new</span> List&lt;StormTuple&gt; &#123; tuple &#125;, <span class="keyword">new</span> List&lt;<span class="keyword">object</span>&gt; &#123; sentence, tuple.GetValue(<span class="number">1</span>) &#125;);</span><br><span class="line">            Context.Logger.Info(<span class="string">"SimpleDRPC Execute exit"</span>);</span><br><span class="line">            ApacheStorm.Ack(tuple);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Prepare</span>(<span class="params">Config stormConf, TopologyContext context</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码需要引用<a href="https://github.com/ziyunhx/storm-net-adapter" title="storm-net-adapter" target="_blank" rel="external">storm-net-adapter</a>，详细信息可以查看我之前的文章，下面我们来使用Java定义这个DRPC Topology:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Licensed to the Apache Software Foundation (ASF) under one</span><br><span class="line"> * or more contributor license agreements.  See the NOTICE file</span><br><span class="line"> * distributed with this work for additional information</span><br><span class="line"> * regarding copyright ownership.  The ASF licenses this file</span><br><span class="line"> * to you under the Apache License, Version 2.0 (the</span><br><span class="line"> * "License"); you may not use this file except in compliance</span><br><span class="line"> * with the License.  You may obtain a copy of the License at</span><br><span class="line"> *</span><br><span class="line"> * http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line"> *</span><br><span class="line"> * Unless required by applicable law or agreed to in writing, software</span><br><span class="line"> * distributed under the License is distributed on an "AS IS" BASIS,</span><br><span class="line"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line"> * See the License for the specific language governing permissions and</span><br><span class="line"> * limitations under the License.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">package</span> storm.starter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> backtype.storm.Config;</span><br><span class="line"><span class="keyword">import</span> backtype.storm.LocalCluster;</span><br><span class="line"><span class="keyword">import</span> backtype.storm.LocalDRPC;</span><br><span class="line"><span class="keyword">import</span> backtype.storm.StormSubmitter;</span><br><span class="line"><span class="keyword">import</span> backtype.storm.drpc.DRPCSpout;</span><br><span class="line"><span class="keyword">import</span> backtype.storm.drpc.LinearDRPCTopologyBuilder;</span><br><span class="line"><span class="keyword">import</span> backtype.storm.drpc.ReturnResults;</span><br><span class="line"><span class="keyword">import</span> backtype.storm.spout.ShellSpout;</span><br><span class="line"><span class="keyword">import</span> backtype.storm.task.ShellBolt;</span><br><span class="line"><span class="keyword">import</span> backtype.storm.topology.IRichBolt;</span><br><span class="line"><span class="keyword">import</span> backtype.storm.topology.IRichSpout;</span><br><span class="line"><span class="keyword">import</span> backtype.storm.topology.OutputFieldsDeclarer;</span><br><span class="line"><span class="keyword">import</span> backtype.storm.topology.TopologyBuilder;</span><br><span class="line"><span class="keyword">import</span> backtype.storm.tuple.Fields;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * This topology demonstrates Storm's stream groupings and multilang capabilities.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DrpcTestTopologyCsharp</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDRPC</span> <span class="keyword">extends</span> <span class="title">ShellBolt</span> <span class="keyword">implements</span> <span class="title">IRichBolt</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">SimpleDRPC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">super</span>(<span class="string">"cmd"</span>, <span class="string">"/k"</span>, <span class="string">"CALL"</span>, <span class="string">"StormSample.exe"</span>, <span class="string">"SimpleDRPC"</span>);</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="annotation">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer declarer)</span> </span>&#123;</span><br><span class="line">			declarer.declare(<span class="keyword">new</span> Fields(<span class="string">"id"</span>, <span class="string">"result"</span>));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="annotation">@Override</span></span><br><span class="line">		<span class="keyword">public</span> Map&lt;String, Object&gt; getComponentConfiguration() &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	  	TopologyBuilder builder = <span class="keyword">new</span> TopologyBuilder();</span><br><span class="line">		  </span><br><span class="line">	  	DRPCSpout drpcSpout = <span class="keyword">new</span> DRPCSpout(<span class="string">"simpledrpc"</span>);</span><br><span class="line">	    builder.setSpout(<span class="string">"drpc-input"</span>, drpcSpout,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	    builder.setBolt(<span class="string">"simple"</span>, <span class="keyword">new</span> SimpleDRPC(), <span class="number">2</span>)</span><br><span class="line">	    		.noneGrouping(<span class="string">"drpc-input"</span>);</span><br><span class="line">	    </span><br><span class="line">	    builder.setBolt(<span class="string">"return"</span>, <span class="keyword">new</span> ReturnResults(),<span class="number">1</span>)</span><br><span class="line">		.noneGrouping(<span class="string">"simple"</span>);</span><br><span class="line"></span><br><span class="line">	    Config conf = <span class="keyword">new</span> Config();</span><br><span class="line">	    conf.setDebug(<span class="keyword">true</span>);</span><br><span class="line">	    conf.setMaxTaskParallelism(<span class="number">1</span>);</span><br><span class="line">	    </span><br><span class="line">	    <span class="keyword">try</span></span><br><span class="line">	    &#123;</span><br><span class="line">	    	StormSubmitter.submitTopology(<span class="string">"drpc-q"</span>, conf,builder.createTopology());</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">catch</span> (Exception e)</span><br><span class="line">	    &#123;</span><br><span class="line">	    	e.printStackTrace();</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 相关代码已经集成到<a href="https://github.com/ziyunhx/storm-net-adapter/tree/master/storm-starter" target="_blank" rel="external">storm-starter</a>中，部署并启动该Topology，然后使用C#或其它语言调用：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">DRPCClient client = <span class="keyword">new</span> DRPCClient(<span class="string">"localhost"</span>, <span class="number">3772</span>);</span><br><span class="line"><span class="keyword">string</span> result = client.execute(<span class="string">"simpledrpc"</span>, <span class="string">"hello word"</span>);</span><br></pre></td></tr></table></figure>
<p> 下面是一些其它语言DRPC项目的搜集：</p>
<ul>
<li>C#/.Net    Storm.Net.Apapter <a href="https://github.com/ziyunhx/storm-net-adapter" target="_blank" rel="external">https://github.com/ziyunhx/storm-net-adapter</a></li>
<li>Java    Storm 官方包 <a href="http://storm.apache.org/" target="_blank" rel="external">http://storm.apache.org/</a></li>
<li>Python    storm-drpc-client <a href="https://pypi.python.org/pypi/storm-drpc-client" target="_blank" rel="external">https://pypi.python.org/pypi/storm-drpc-client</a></li>
<li>Php    php-drpc <a href="https://github.com/mithunsatheesh/php-drpc" target="_blank" rel="external">https://github.com/mithunsatheesh/php-drpc</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p> 在上一篇文章里介绍了.Net版本的DRPC的类库，结尾处的例子使用了Java版 BasicDRPCTopology ，本文我将介绍如何使用C#来开发 Storm Topology 并供远程DRPC调用，这篇文章将作为.Net Storm系列文章的一个暂时的结束，新的文章将随着 <a href="https://github.com/ziyunhx/storm-net-adapter" title="storm-net-adapter">storm-net-adapter</a> 新特性来更新!</p>]]>
    
    </summary>
    
      <category term=".NET" scheme="http://www.tnidea.com/tags/NET/"/>
    
      <category term="C#" scheme="http://www.tnidea.com/tags/C/"/>
    
      <category term="DRPC" scheme="http://www.tnidea.com/tags/DRPC/"/>
    
      <category term="Topology" scheme="http://www.tnidea.com/tags/Topology/"/>
    
      <category term="csharp" scheme="http://www.tnidea.com/tags/csharp/"/>
    
      <category term="storm" scheme="http://www.tnidea.com/tags/storm/"/>
    
      <category term="Storm" scheme="http://www.tnidea.com/categories/Storm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[.NET使用DRPC远程调用运行在Storm上的拓扑]]></title>
    <link href="http://www.tnidea.com/dot-net-drpc-storm.html"/>
    <id>http://www.tnidea.com/dot-net-drpc-storm.html</id>
    <published>2015-08-11T16:00:00.000Z</published>
    <updated>2015-09-28T12:13:59.000Z</updated>
    <content type="html"><![CDATA[<p> Distributed RPC（DRPC）是Storm构建在Thrift协议上的RPC的实现，DRPC使得你可以通过多种语言远程的使用Storm集群的计算能力。DRPC并非Storm的基础特性，但它确实非常有用。DRPC的整个过程与一般的RPC没有区别，客户端只需要调用一个远程的方法并等待返回结果。主要工作已经被DRPC Server封装，服务端在这个过程中完成了以下步骤：</p>
<a id="more"></a>
<ul>
<li>从客户端接收一个RPC请求；</li>
<li>将请求发送到storm topology；</li>
<li>从storm topology接收结果；</li>
<li><p>将结果发回给等待的客户端。</p>
<p><img src="http://www.tnidea.com/media/image/drpc-workflow.png" alt="image"></p>
<p><a href="https://github.com/ziyunhx/storm-net-adapter" title="storm-net-adapter" target="_blank" rel="external">storm-net-adapter</a>现在已经完成了对DRPC的支持，因此你可以使用dotNet编写代码远程调用任何支持语言编写的支持DRPC的Topology，当然你也可以使用dotNet编写Topology供其它语言通过DRPC调用。</p>
<p>DRPC是<a href="https://github.com/ziyunhx/storm-net-adapter" title="storm-net-adapter" target="_blank" rel="external">storm-net-adapter</a>新增加的特性，因此需要使用最新的类库，你可以使用源代码自行编译，或者下载最新的<a href="https://github.com/ziyunhx/storm-net-adapter/releases" title="Release" target="_blank" rel="external">Release</a>，还可以使用Nuget获取最新版本。</p>
<p> PM&gt; Install-Package Storm.Net.Adapter</p>
<p>推荐大家使用Nuget获取，方便管理依赖项。下面将介绍如何通过DRPC调用运行在Storm集群的方法，在这之前，你需要已经熟悉Storm环境的搭建与集群部署，不了解的可以先看我之前的文章。为了尽可能的简单，我们使用了Storm官方的BasicDRPCTopology，这个是一个简单的使用JAVA编写的DRPC Topology，它的功能仅仅是在传入的单词后面增加一个感叹号。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Licensed to the Apache Software Foundation (ASF) under one</span><br><span class="line"> * or more contributor license agreements.  See the NOTICE file</span><br><span class="line"> * distributed with this work for additional information</span><br><span class="line"> * regarding copyright ownership.  The ASF licenses this file</span><br><span class="line"> * to you under the Apache License, Version 2.0 (the</span><br><span class="line"> * "License"); you may not use this file except in compliance</span><br><span class="line"> * with the License.  You may obtain a copy of the License at</span><br><span class="line"> *</span><br><span class="line"> * http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line"> *</span><br><span class="line"> * Unless required by applicable law or agreed to in writing, software</span><br><span class="line"> * distributed under the License is distributed on an "AS IS" BASIS,</span><br><span class="line"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line"> * See the License for the specific language governing permissions and</span><br><span class="line"> * limitations under the License.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">package</span> storm.starter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> backtype.storm.Config;</span><br><span class="line"><span class="keyword">import</span> backtype.storm.LocalCluster;</span><br><span class="line"><span class="keyword">import</span> backtype.storm.LocalDRPC;</span><br><span class="line"><span class="keyword">import</span> backtype.storm.StormSubmitter;</span><br><span class="line"><span class="keyword">import</span> backtype.storm.drpc.LinearDRPCTopologyBuilder;</span><br><span class="line"><span class="keyword">import</span> backtype.storm.topology.BasicOutputCollector;</span><br><span class="line"><span class="keyword">import</span> backtype.storm.topology.OutputFieldsDeclarer;</span><br><span class="line"><span class="keyword">import</span> backtype.storm.topology.base.BaseBasicBolt;</span><br><span class="line"><span class="keyword">import</span> backtype.storm.tuple.Fields;</span><br><span class="line"><span class="keyword">import</span> backtype.storm.tuple.Tuple;</span><br><span class="line"><span class="keyword">import</span> backtype.storm.tuple.Values;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * This topology is a basic example of doing distributed RPC on top of Storm. It implements a function that appends a</span><br><span class="line"> * "!" to any string you send the DRPC function.</span><br><span class="line"> * &lt;p/&gt;</span><br><span class="line"> * See https://github.com/nathanmarz/storm/wiki/Distributed-RPC for more information on doing distributed RPC on top of</span><br><span class="line"> * Storm.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicDRPCTopology</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExclaimBolt</span> <span class="keyword">extends</span> <span class="title">BaseBasicBolt</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Tuple tuple, BasicOutputCollector collector)</span> </span>&#123;</span><br><span class="line">      String input = tuple.getString(<span class="number">1</span>);</span><br><span class="line">      collector.emit(<span class="keyword">new</span> Values(tuple.getValue(<span class="number">0</span>), input + <span class="string">"!"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer declarer)</span> </span>&#123;</span><br><span class="line">      declarer.declare(<span class="keyword">new</span> Fields(<span class="string">"id"</span>, <span class="string">"result"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    LinearDRPCTopologyBuilder builder = <span class="keyword">new</span> LinearDRPCTopologyBuilder(<span class="string">"exclamation"</span>);</span><br><span class="line">    builder.addBolt(<span class="keyword">new</span> ExclaimBolt(), <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    Config conf = <span class="keyword">new</span> Config();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (args == <span class="keyword">null</span> || args.length == <span class="number">0</span>) &#123;</span><br><span class="line">      LocalDRPC drpc = <span class="keyword">new</span> LocalDRPC();</span><br><span class="line">      LocalCluster cluster = <span class="keyword">new</span> LocalCluster();</span><br><span class="line"></span><br><span class="line">      cluster.submitTopology(<span class="string">"drpc-demo"</span>, conf, builder.createLocalTopology(drpc));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (String word : <span class="keyword">new</span> String[]&#123; <span class="string">"hello"</span>, <span class="string">"goodbye"</span> &#125;) &#123;</span><br><span class="line">        System.out.println(<span class="string">"Result for \""</span> + word + <span class="string">"\": "</span> + drpc.execute(<span class="string">"exclamation"</span>, word));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      cluster.shutdown();</span><br><span class="line">      drpc.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      conf.setNumWorkers(<span class="number">2</span>);</span><br><span class="line">      StormSubmitter.submitTopologyWithProgressBar(args[<span class="number">0</span>], conf, builder.createRemoteTopology());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 相关代码已经集成到<a href="https://github.com/ziyunhx/storm-net-adapter/tree/master/storm-starter" target="_blank" rel="external">storm-starter</a>中，下面我们还需要修改一下Storm的配置文件：</p>
<pre><code>drpc.servers:
 -<span class="ruby"> <span class="string">"drpc1.foo.com"</span>
</span> -<span class="ruby"> <span class="string">"drpc2.foo.com"</span></span>
</code></pre><p> 将drpc1.foo.com替换成你接下来要启动drpc服务机器的IP或者域名，你可以只保留一条，也可以继续增加服务的数量。</p>
<p> 在你刚刚填写的IP所在服务器上启动drpc服务：</p>
<pre><code><span class="variable">$ </span>storm drpc
</code></pre><p> 使用storm命令提交Topology：</p>
<pre><code>$ storm jar storm-starter-*<span class="class">.jar</span> storm<span class="class">.starter</span><span class="class">.BasicDRPCTopology</span> drpc-test
</code></pre><p> 然后我们就可以在Csharp上编写代码调用了：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">DRPCClient client = <span class="keyword">new</span> DRPCClient(<span class="string">"localhost"</span>, <span class="number">3772</span>);</span><br><span class="line"><span class="keyword">string</span> result = client.execute(<span class="string">"exclamation"</span>, <span class="string">"hello word"</span>);</span><br></pre></td></tr></table></figure>
<p> 替换 localhost 为你的drpc服务器的地址，exclamation为你在java中设置的LinearDRPCTopologyBuilder的名称；我也在项目中新增了一个控制台程序<a href="https://github.com/ziyunhx/storm-net-adapter/tree/master/samples/Storm.DRPC.Demo" target="_blank" rel="external">Storm.DRPC.Demo</a>以便大家用于测试！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p> Distributed RPC（DRPC）是Storm构建在Thrift协议上的RPC的实现，DRPC使得你可以通过多种语言远程的使用Storm集群的计算能力。DRPC并非Storm的基础特性，但它确实非常有用。DRPC的整个过程与一般的RPC没有区别，客户端只需要调用一个远程的方法并等待返回结果。主要工作已经被DRPC Server封装，服务端在这个过程中完成了以下步骤：</p>]]>
    
    </summary>
    
      <category term=".NET" scheme="http://www.tnidea.com/tags/NET/"/>
    
      <category term="C#" scheme="http://www.tnidea.com/tags/C/"/>
    
      <category term="DRPC" scheme="http://www.tnidea.com/tags/DRPC/"/>
    
      <category term="Topology" scheme="http://www.tnidea.com/tags/Topology/"/>
    
      <category term="csharp" scheme="http://www.tnidea.com/tags/csharp/"/>
    
      <category term="storm" scheme="http://www.tnidea.com/tags/storm/"/>
    
      <category term="Storm" scheme="http://www.tnidea.com/categories/Storm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Open Auth辅助库（使用ImitateLogin实现登录）]]></title>
    <link href="http://www.tnidea.com/open-auth-assist-project.html"/>
    <id>http://www.tnidea.com/open-auth-assist-project.html</id>
    <published>2015-08-09T16:00:00.000Z</published>
    <updated>2015-09-23T15:26:42.000Z</updated>
    <content type="html"><![CDATA[<p> 网络上越来越多的公司进行着自己的平台化策略，其中绝大多数都已Web API的方式对外提供服务，为了方便的使用这些服务，你不得不引用许多相关的类库，但是API的本质其实仅仅是一些约定的网络请求，我们大多数情况仅仅使用API提供的少数几个功能，因此，我稍微修改了下微博的c#的类库，加入了<a href="https://github.com/ziyunhx/imitate-login" title="ImitateLogin" target="_blank" rel="external">ImitateLogin</a>库来模拟登录，形成了<a href="https://github.com/ziyunhx/open-auth-assist" title="open-auth-assist" target="_blank" rel="external">open-auth-assist</a>库。</p>
<a id="more"></a>
<p> <a href="https://github.com/ziyunhx/open-auth-assist" target="_blank" rel="external">open-auth-assist</a>的目的是将现有的API的类库使用一种通用的方式来代替，同时又不增加太多的额外工作。另外这个项目也可以算作我的另一个开源项目<a href="https://github.com/ziyunhx/imitate-login" target="_blank" rel="external">ImitateLogin</a>的一个Demo。</p>
<p> 这个类库的绝大多数代码都源于 <a href="http://weibosdk.codeplex.com/" title="WeiboSDK" target="_blank" rel="external">weiboSDK</a> 这个项目，由于作者不准备再更新，而且没有继续提供模拟登录的功能，所以我拿过来修改了下开源出来（已获得原作者同意），目前仅完成了微博部分的实现，由于这个项目依赖于<a href="https://github.com/ziyunhx/imitate-login" target="_blank" rel="external">ImitateLogin</a>，因此只有<a href="https://github.com/ziyunhx/imitate-login" target="_blank" rel="external">ImitateLogin</a>完成的网站才会增加支持；<a href="https://github.com/ziyunhx/imitate-login" target="_blank" rel="external">ImitateLogin</a>本身并没有太多的技术难度，仅仅需要熟悉网络请求和一些耐心来解决各种客户端加密，所以如果大家有时间，也希望能一起为这个项目贡献一些代码，谢谢！</p>
<p> 下面将简单介绍下如何使用<a href="https://github.com/ziyunhx/open-auth-assist" target="_blank" rel="external">open-auth-assist</a>来实现微博API的调用。</p>
<p> 首先，我们需要实例化一个OpenAuthAssist类：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> openAuth = <span class="keyword">new</span> SinaWeiboClient(<span class="string">"1402038860"</span>, <span class="string">"62e1ddd4f6bc33077c796d5129047ca2"</span>, <span class="string">"http://qcyn.sina.com.cn"</span>);</span><br></pre></td></tr></table></figure>
<p> 例子中使用的appkey使用了原作者例子中的key。</p>
<p> 接下来我们登录需要进行操作的用户：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">openAuth.DoLogin(<span class="string">"username"</span>, <span class="string">"password"</span>);</span><br></pre></td></tr></table></figure>
<p> 然后我们来使用Weibo提供的获取用户时间轴的API来展示如何使用Get：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = openAuth.HttpGet(<span class="string">"statuses/friends_timeline.json"</span>, <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">object</span>&gt;</span><br><span class="line">		&#123;</span><br><span class="line">			&#123;<span class="string">"count"</span>, <span class="number">5</span>&#125;,</span><br><span class="line">			&#123;<span class="string">"page"</span>, <span class="number">1</span>&#125;,</span><br><span class="line">			&#123;<span class="string">"base_app"</span> , <span class="number">0</span>&#125;</span><br><span class="line">		&#125;);</span><br></pre></td></tr></table></figure>
<p> 我们发送一条微博来展示Post方法的调用：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result2 = openAuth.HttpPost(<span class="string">"statuses/update.json"</span>, <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">object</span>&gt;</span><br><span class="line">		&#123;</span><br><span class="line">			&#123;<span class="string">"status"</span> , <span class="keyword">string</span>.Format(<span class="string">"post from OpenAuth.Assist! @&#123;0:HH:mm:ss&#125;"</span>, DateTime.Now)&#125;</span><br><span class="line">		&#125;);</span><br></pre></td></tr></table></figure>
<p> 接下来，好好享受吧！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p> 网络上越来越多的公司进行着自己的平台化策略，其中绝大多数都已Web API的方式对外提供服务，为了方便的使用这些服务，你不得不引用许多相关的类库，但是API的本质其实仅仅是一些约定的网络请求，我们大多数情况仅仅使用API提供的少数几个功能，因此，我稍微修改了下微博的c#的类库，加入了<a href="https://github.com/ziyunhx/imitate-login" title="ImitateLogin">ImitateLogin</a>库来模拟登录，形成了<a href="https://github.com/ziyunhx/open-auth-assist" title="open-auth-assist">open-auth-assist</a>库。</p>]]>
    
    </summary>
    
      <category term=".NET" scheme="http://www.tnidea.com/tags/NET/"/>
    
      <category term="C#" scheme="http://www.tnidea.com/tags/C/"/>
    
      <category term="ImitateLogin" scheme="http://www.tnidea.com/tags/ImitateLogin/"/>
    
      <category term="OpenAuth" scheme="http://www.tnidea.com/tags/OpenAuth/"/>
    
      <category term="csharp" scheme="http://www.tnidea.com/tags/csharp/"/>
    
      <category term="open-auth-assist" scheme="http://www.tnidea.com/tags/open-auth-assist/"/>
    
      <category term="爬虫" scheme="http://www.tnidea.com/categories/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[.Net使用HttpWebRequest模拟浏览器]]></title>
    <link href="http://www.tnidea.com/http-helper-at-csharp.html"/>
    <id>http://www.tnidea.com/http-helper-at-csharp.html</id>
    <published>2015-07-09T16:00:00.000Z</published>
    <updated>2015-10-07T08:16:21.000Z</updated>
    <content type="html"><![CDATA[<p> 在编写网络爬虫时，HttpWebRequest几乎可以完成绝大多数网站的抓取，为了更好的使用这一技术，我将常用的几个功能进行了封装，以方便调用。这个类已经在多个项目中得到使用，主要解决了Cookies相关的一些问题；如果有其它方面的问题可以提出来，我会进一步完善。</p>
<a id="more"></a>
<p> 目前HttpHelper包含了以下几个方面：</p>
<ul>
<li>GetHttpContent：通过Get或Post来获取网页的Html</li>
<li>SetCookie：根据response中头部的set-cookie对cookie进行设置，能识别httponly</li>
<li>GetAllCookies：将CookieContainer转换为键值对，方便存储和跨程序间调用</li>
<li>ConvertToCookieContainer：将键值对转换回CookieContainer供程序调用</li>
<li><p>BuildPostData：通过一个需要post的html构建出postdata</p>
<p>代码如下：</p>
</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Specialized;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.IO.Compression;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Net;</span><br><span class="line"><span class="keyword">using</span> System.Net.Security;</span><br><span class="line"><span class="keyword">using</span> System.Security.Cryptography.X509Certificates;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Text.RegularExpressions;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> HtmlAgilityPack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">TNIdea.Common.Helper</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HttpHelper</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">const</span> <span class="keyword">string</span> CharsetReg = <span class="string">@"(meta.*?charset=""?(?&lt;Charset&gt;[^\s""'&gt;]+)""?)|(xml.*?encoding=""?(?&lt;Charset&gt;[^\s""&gt;]+)""?)"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> 获取网页的内容</span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="url"&gt;</span>Url<span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="postData"&gt;</span>Post的信息<span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="cookies"&gt;</span>Cookies<span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="userAgent"&gt;</span>浏览器标识<span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="referer"&gt;</span>来源页<span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="cookiesDomain"&gt;</span>Cookies的Domian参数，配合cookies使用；为空则取url的Host<span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="encode"&gt;</span>编码方式，用于解析html<span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;returns&gt;</span><span class="xmlDocTag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">string</span> <span class="title">GetHttpContent</span>(<span class="params"><span class="keyword">string</span> url, <span class="keyword">string</span> postData = <span class="keyword">null</span>, CookieContainer cookies = <span class="keyword">null</span>, <span class="keyword">string</span> userAgent = <span class="string">""</span>, <span class="keyword">string</span> referer = <span class="string">""</span>, <span class="keyword">string</span> cookiesDomain = <span class="string">""</span>, Encoding encode = <span class="keyword">null</span></span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                HttpWebResponse httpResponse = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="keyword">string</span>.IsNullOrWhiteSpace(postData))</span><br><span class="line">                    httpResponse = CreatePostHttpResponse(url, postData, cookies: cookies, userAgent: userAgent, referer: referer);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    httpResponse = CreateGetHttpResponse(url, cookies: cookies, userAgent: userAgent, referer: referer);</span><br><span class="line"></span><br><span class="line">                <span class="preprocessor">#<span class="keyword">region</span> 根据Html头判断</span></span><br><span class="line">                <span class="keyword">string</span> Content = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//缓冲区长度</span></span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">int</span> N_CacheLength = <span class="number">10000</span>;</span><br><span class="line">                <span class="comment">//头部预读取缓冲区，字节形式</span></span><br><span class="line">                <span class="keyword">var</span> bytes = <span class="keyword">new</span> List&lt;<span class="keyword">byte</span>&gt;();</span><br><span class="line">                <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//头部预读取缓冲区，字符串</span></span><br><span class="line">                String cache = <span class="keyword">string</span>.Empty;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//创建流对象并解码</span></span><br><span class="line">                Stream ResponseStream;</span><br><span class="line">                <span class="keyword">switch</span> (httpResponse.ContentEncoding.ToUpperInvariant())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">"GZIP"</span>:</span><br><span class="line">                        ResponseStream = <span class="keyword">new</span> GZipStream(</span><br><span class="line">                            httpResponse.GetResponseStream(), CompressionMode.Decompress);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">"DEFLATE"</span>:</span><br><span class="line">                        ResponseStream = <span class="keyword">new</span> DeflateStream(</span><br><span class="line">                            httpResponse.GetResponseStream(), CompressionMode.Decompress);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        ResponseStream = httpResponse.GetResponseStream();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">while</span> (</span><br><span class="line">                        !(cache.EndsWith(<span class="string">"&lt;/head&gt;"</span>, StringComparison.OrdinalIgnoreCase)</span><br><span class="line">                          || count &gt;= N_CacheLength))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">var</span> b = (<span class="keyword">byte</span>)ResponseStream.ReadByte();</span><br><span class="line">                        <span class="keyword">if</span> (b &lt; <span class="number">0</span>) <span class="comment">//end of stream</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        bytes.Add(b);</span><br><span class="line"></span><br><span class="line">                        count++;</span><br><span class="line">                        cache += (<span class="keyword">char</span>)b;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (encode == <span class="keyword">null</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">try</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span> (httpResponse.CharacterSet == <span class="string">"ISO-8859-1"</span> || httpResponse.CharacterSet == <span class="string">"zh-cn"</span>)</span><br><span class="line">                            &#123;</span><br><span class="line">                                Match match = Regex.Match(cache, CharsetReg, RegexOptions.IgnoreCase | RegexOptions.Multiline);</span><br><span class="line">                                <span class="keyword">if</span> (match.Success)</span><br><span class="line">                                &#123;</span><br><span class="line">                                    <span class="keyword">try</span></span><br><span class="line">                                    &#123;</span><br><span class="line">                                        <span class="keyword">string</span> charset = match.Groups[<span class="string">"Charset"</span>].Value;</span><br><span class="line">                                        encode = Encoding.GetEncoding(charset);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    <span class="keyword">catch</span> &#123; &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    encode = Encoding.GetEncoding(<span class="string">"GB2312"</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                encode = Encoding.GetEncoding(httpResponse.CharacterSet);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">catch</span> &#123; &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//缓冲字节重新编码，然后再把流读完</span></span><br><span class="line">                    <span class="keyword">var</span> Reader = <span class="keyword">new</span> StreamReader(ResponseStream, encode);</span><br><span class="line">                    Content = encode.GetString(bytes.ToArray(), <span class="number">0</span>, count) + Reader.ReadToEnd();</span><br><span class="line">                    Reader.Close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> ex.ToString();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">finally</span></span><br><span class="line">                &#123;</span><br><span class="line">                    httpResponse.Close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="preprocessor">#<span class="keyword">endregion</span> 根据Html头判断</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//获取返回的Cookies，支持httponly</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">string</span>.IsNullOrWhiteSpace(cookiesDomain))</span><br><span class="line">                    cookiesDomain = httpResponse.ResponseUri.Host;</span><br><span class="line"></span><br><span class="line">                cookies = <span class="keyword">new</span> CookieContainer();</span><br><span class="line">                CookieCollection httpHeaderCookies = SetCookie(httpResponse, cookiesDomain);</span><br><span class="line">                cookies.Add(httpHeaderCookies ?? httpResponse.Cookies);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> Content;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">string</span>.Empty;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> 创建GET方式的HTTP请求 </span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="url"&gt;</span><span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="timeout"&gt;</span><span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="userAgent"&gt;</span><span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="cookies"&gt;</span><span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="referer"&gt;</span><span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;returns&gt;</span><span class="xmlDocTag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HttpWebResponse <span class="title">CreateGetHttpResponse</span>(<span class="params"><span class="keyword">string</span> url, <span class="keyword">int</span> timeout = <span class="number">60000</span>, <span class="keyword">string</span> userAgent = <span class="string">""</span>, CookieContainer cookies = <span class="keyword">null</span>, <span class="keyword">string</span> referer = <span class="string">""</span></span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            HttpWebRequest request = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (url.StartsWith(<span class="string">"https"</span>, StringComparison.OrdinalIgnoreCase))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//对服务端证书进行有效性校验（非第三方权威机构颁发的证书，如自己生成的，不进行验证，这里返回true）</span></span><br><span class="line">                ServicePointManager.ServerCertificateValidationCallback = <span class="keyword">new</span> RemoteCertificateValidationCallback(CheckValidationResult);</span><br><span class="line">                request = WebRequest.Create(url) <span class="keyword">as</span> HttpWebRequest;</span><br><span class="line">                <span class="comment">//request.ProtocolVersion = HttpVersion.Version10;    //http版本，默认是1.1,这里设置为1.0</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                request = WebRequest.Create(url) <span class="keyword">as</span> HttpWebRequest;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            request.Referer = referer;</span><br><span class="line">            request.Method = <span class="string">"GET"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置代理UserAgent和超时</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">string</span>.IsNullOrWhiteSpace(userAgent))</span><br><span class="line">                userAgent = <span class="string">"Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/34.0.1847.116 Safari/537.36"</span>;</span><br><span class="line"></span><br><span class="line">            request.UserAgent = userAgent;</span><br><span class="line">            request.Timeout = timeout;</span><br><span class="line">            request.KeepAlive = <span class="keyword">true</span>;</span><br><span class="line">            request.AllowAutoRedirect = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cookies == <span class="keyword">null</span>)</span><br><span class="line">                cookies = <span class="keyword">new</span> CookieContainer();</span><br><span class="line">            request.CookieContainer = cookies;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> request.GetResponse() <span class="keyword">as</span> HttpWebResponse;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> 创建POST方式的HTTP请求</span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="url"&gt;</span><span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="postData"&gt;</span><span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="timeout"&gt;</span><span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="userAgent"&gt;</span><span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="cookies"&gt;</span><span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="referer"&gt;</span><span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;returns&gt;</span><span class="xmlDocTag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HttpWebResponse <span class="title">CreatePostHttpResponse</span>(<span class="params"><span class="keyword">string</span> url, <span class="keyword">string</span> postData, <span class="keyword">int</span> timeout = <span class="number">60000</span>, <span class="keyword">string</span> userAgent = <span class="string">""</span>, CookieContainer cookies = <span class="keyword">null</span>, <span class="keyword">string</span> referer = <span class="string">""</span></span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            HttpWebRequest request = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//如果是发送HTTPS请求  </span></span><br><span class="line">            <span class="keyword">if</span> (url.StartsWith(<span class="string">"https"</span>, StringComparison.OrdinalIgnoreCase))</span><br><span class="line">            &#123;</span><br><span class="line">                ServicePointManager.ServerCertificateValidationCallback = <span class="keyword">new</span> RemoteCertificateValidationCallback(CheckValidationResult);</span><br><span class="line">                request = WebRequest.Create(url) <span class="keyword">as</span> HttpWebRequest;</span><br><span class="line">                <span class="comment">//request.ProtocolVersion = HttpVersion.Version10;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                request = WebRequest.Create(url) <span class="keyword">as</span> HttpWebRequest;</span><br><span class="line">            &#125;</span><br><span class="line">            request.Referer = referer;</span><br><span class="line">            request.Method = <span class="string">"POST"</span>;</span><br><span class="line">            request.ContentType = <span class="string">"application/x-www-form-urlencoded"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置代理UserAgent和超时</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">string</span>.IsNullOrWhiteSpace(userAgent))</span><br><span class="line">                request.UserAgent = <span class="string">"Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1985.125 Safari/537.36"</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                request.UserAgent = userAgent;</span><br><span class="line">            request.Timeout = timeout;</span><br><span class="line">            request.KeepAlive = <span class="keyword">true</span>;</span><br><span class="line">            request.AllowAutoRedirect = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cookies == <span class="keyword">null</span>)</span><br><span class="line">                cookies = <span class="keyword">new</span> CookieContainer();</span><br><span class="line">            request.CookieContainer = cookies;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//发送POST数据  </span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">string</span>.IsNullOrWhiteSpace(postData))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] data = Encoding.UTF8.GetBytes(postData);</span><br><span class="line">                request.ContentLength = data.Length;</span><br><span class="line">                <span class="keyword">using</span> (Stream stream = request.GetRequestStream())</span><br><span class="line">                &#123;</span><br><span class="line">                    stream.Write(data, <span class="number">0</span>, data.Length);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//string[] values = request.Headers.GetValues("Content-Type");</span></span><br><span class="line">            <span class="keyword">return</span> request.GetResponse() <span class="keyword">as</span> HttpWebResponse;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> 验证证书</span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="sender"&gt;</span><span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="certificate"&gt;</span><span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="chain"&gt;</span><span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="errors"&gt;</span><span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;returns&gt;</span>是否验证通过<span class="xmlDocTag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">CheckValidationResult</span>(<span class="params"><span class="keyword">object</span> sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors errors</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (errors == SslPolicyErrors.None)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> 根据response中头部的set-cookie对request中的cookie进行设置</span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="setCookie"&gt;</span>The set cookie.<span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="defaultDomain"&gt;</span>The default domain.<span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;returns&gt;</span><span class="xmlDocTag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> CookieCollection <span class="title">SetCookie</span>(<span class="params">HttpWebResponse response, <span class="keyword">string</span> defaultDomain</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">string</span>[] setCookie = response.Headers.GetValues(<span class="string">"Set-Cookie"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// there is bug in it,the datetime in "set-cookie" will be sepreated in two pieces.</span></span><br><span class="line">                List&lt;<span class="keyword">string</span>&gt; a = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;(setCookie);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = setCookie.Length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (a[i].Substring(a[i].Length - <span class="number">3</span>) == <span class="string">"GMT"</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        a[i - <span class="number">1</span>] = a[i - <span class="number">1</span>] + <span class="string">", "</span> + a[i];</span><br><span class="line">                        a.RemoveAt(i);</span><br><span class="line">                        i--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                setCookie = a.ToArray&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line">                CookieCollection cookies = <span class="keyword">new</span> CookieCollection();</span><br><span class="line">                <span class="keyword">foreach</span> (<span class="keyword">string</span> str <span class="keyword">in</span> setCookie)</span><br><span class="line">                &#123;</span><br><span class="line">                    NameValueCollection hs = <span class="keyword">new</span> NameValueCollection();</span><br><span class="line">                    <span class="keyword">foreach</span> (<span class="keyword">string</span> i <span class="keyword">in</span> str.Split(<span class="string">';'</span>))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">int</span> index = i.IndexOf(<span class="string">"="</span>);</span><br><span class="line">                        <span class="keyword">if</span> (index &gt; <span class="number">0</span>)</span><br><span class="line">                            hs.Add(i.Substring(<span class="number">0</span>, index).Trim(), i.Substring(index + <span class="number">1</span>).Trim());</span><br><span class="line">                        <span class="function"><span class="keyword">else</span></span><br><span class="line">                            <span class="title">switch</span> (<span class="params">i</span>)</span><br><span class="line">                            </span>&#123;</span><br><span class="line">                                <span class="keyword">case</span> <span class="string">"HttpOnly"</span>:</span><br><span class="line">                                    hs.Add(<span class="string">"HttpOnly"</span>, <span class="string">"True"</span>);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                <span class="keyword">case</span> <span class="string">"Secure"</span>:</span><br><span class="line">                                    hs.Add(<span class="string">"Secure"</span>, <span class="string">"True"</span>);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Cookie ck = <span class="keyword">new</span> Cookie();</span><br><span class="line">                    <span class="keyword">foreach</span> (<span class="keyword">string</span> Key <span class="keyword">in</span> hs.AllKeys)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">switch</span> (Key.ToLower().Trim())</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">"path"</span>:</span><br><span class="line">                                ck.Path = hs[Key];</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">"expires"</span>:</span><br><span class="line">                                ck.Expires = DateTime.Parse(hs[Key]);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">"domain"</span>:</span><br><span class="line">                                ck.Domain = hs[Key];</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">"httpOnly"</span>:</span><br><span class="line">                                ck.HttpOnly = <span class="keyword">true</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">"secure"</span>:</span><br><span class="line">                                ck.Secure = <span class="keyword">true</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">default</span>:</span><br><span class="line">                                ck.Name = Key;</span><br><span class="line">                                ck.Value = hs[Key];</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (ck.Domain == <span class="string">""</span>) ck.Domain = defaultDomain;</span><br><span class="line">                    <span class="keyword">if</span> (ck.Name != <span class="string">""</span>) cookies.Add(ck);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> cookies;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> 遍历CookieContainer</span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="cookieContainer"&gt;</span><span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;returns&gt;</span>List of cookie<span class="xmlDocTag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">string</span>&gt; GetAllCookies(CookieContainer cookieContainer)</span><br><span class="line">        &#123;</span><br><span class="line">            Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">string</span>&gt; cookies = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">string</span>&gt;();</span><br><span class="line"></span><br><span class="line">            Hashtable table = (Hashtable)cookieContainer.GetType().InvokeMember(<span class="string">"m_domainTable"</span>,</span><br><span class="line">                System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.GetField |</span><br><span class="line">                System.Reflection.BindingFlags.Instance, <span class="keyword">null</span>, cookieContainer, <span class="keyword">new</span> <span class="keyword">object</span>[] &#123; &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">string</span> pathList <span class="keyword">in</span> table.Keys)</span><br><span class="line">            &#123;</span><br><span class="line">                StringBuilder _cookie = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                SortedList cookieColList = (SortedList)table[pathList].GetType().InvokeMember(<span class="string">"m_list"</span>,</span><br><span class="line">                    System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.GetField</span><br><span class="line">                    | System.Reflection.BindingFlags.Instance, <span class="keyword">null</span>, table[pathList], <span class="keyword">new</span> <span class="keyword">object</span>[] &#123; &#125;);</span><br><span class="line">                <span class="keyword">foreach</span> (CookieCollection colCookies <span class="keyword">in</span> cookieColList.Values)</span><br><span class="line">                    <span class="keyword">foreach</span> (Cookie c <span class="keyword">in</span> colCookies)</span><br><span class="line">                        _cookie.Append(c.Name + <span class="string">"="</span> + c.Value + <span class="string">";"</span>);</span><br><span class="line"></span><br><span class="line">                cookies.Add(pathList, _cookie.ToString().TrimEnd(<span class="string">';'</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cookies;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> convert cookies string to CookieContainer</span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="cookies"&gt;</span><span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;returns&gt;</span><span class="xmlDocTag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CookieContainer <span class="title">ConvertToCookieContainer</span>(<span class="params">Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">string</span>&gt; cookies</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            CookieContainer cookieContainer = <span class="keyword">new</span> CookieContainer();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> cookie <span class="keyword">in</span> cookies)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">string</span>[] strEachCookParts = cookie.Value.Split(<span class="string">';'</span>);</span><br><span class="line">                <span class="keyword">int</span> intEachCookPartsCount = strEachCookParts.Length;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">foreach</span> (<span class="keyword">string</span> strCNameAndCValue <span class="keyword">in</span> strEachCookParts)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="keyword">string</span>.IsNullOrEmpty(strCNameAndCValue))</span><br><span class="line">                    &#123;</span><br><span class="line">                        Cookie cookTemp = <span class="keyword">new</span> Cookie();</span><br><span class="line">                        <span class="keyword">int</span> firstEqual = strCNameAndCValue.IndexOf(<span class="string">"="</span>);</span><br><span class="line">                        <span class="keyword">string</span> firstName = strCNameAndCValue.Substring(<span class="number">0</span>, firstEqual);</span><br><span class="line">                        <span class="keyword">string</span> allValue = strCNameAndCValue.Substring(firstEqual + <span class="number">1</span>, strCNameAndCValue.Length - (firstEqual + <span class="number">1</span>));</span><br><span class="line">                        cookTemp.Name = firstName;</span><br><span class="line">                        cookTemp.Value = allValue;</span><br><span class="line">                        cookTemp.Path = <span class="string">"/"</span>;</span><br><span class="line">                        cookTemp.Domain = cookie.Key;</span><br><span class="line">                        cookieContainer.Add(cookTemp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cookieContainer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">string</span> <span class="title">BuildPostData</span>(<span class="params"><span class="keyword">string</span> htmlContent</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            HtmlDocument htmlDoc = <span class="keyword">new</span> HtmlDocument();</span><br><span class="line">            htmlDoc.LoadHtml(htmlContent);</span><br><span class="line">            <span class="comment">//Get the form node collection.</span></span><br><span class="line">            HtmlNode htmlNode = htmlDoc.DocumentNode.SelectSingleNode(<span class="string">"//form"</span>);</span><br><span class="line">            HtmlNodeCollection htmlInputs = htmlNode.SelectNodes(<span class="string">"//input"</span>);</span><br><span class="line"></span><br><span class="line">            StringBuilder postData = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">foreach</span> (HtmlNode input <span class="keyword">in</span> htmlInputs)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(input.Attributes[<span class="string">"value"</span>] != <span class="keyword">null</span>)</span><br><span class="line">                    postData.Append(input.Attributes[<span class="string">"name"</span>].Value + <span class="string">"="</span> + input.Attributes[<span class="string">"value"</span>].Value + <span class="string">"&amp;"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> postData.ToString().TrimEnd(<span class="string">'&amp;'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 部分网站需要登录的问题我已经着手通过另一个项目来解决（<a href="https://github.com/ziyunhx/imitate-login" title="imitate-login" target="_blank" rel="external">imitate-login</a>），目前还有许多网页使用了JavaScript或各种基于JS的框架来对网页进行数据加载，如何来模拟执行JavaScript暂时还没找到比较优美的解决方案，如果大家有什么好的方案可以发给我，谢谢！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p> 在编写网络爬虫时，HttpWebRequest几乎可以完成绝大多数网站的抓取，为了更好的使用这一技术，我将常用的几个功能进行了封装，以方便调用。这个类已经在多个项目中得到使用，主要解决了Cookies相关的一些问题；如果有其它方面的问题可以提出来，我会进一步完善。</p>]]>
    
    </summary>
    
      <category term=".NET" scheme="http://www.tnidea.com/tags/NET/"/>
    
      <category term="C#" scheme="http://www.tnidea.com/tags/C/"/>
    
      <category term="HttpHelper" scheme="http://www.tnidea.com/tags/HttpHelper/"/>
    
      <category term="HttpWebRequest" scheme="http://www.tnidea.com/tags/HttpWebRequest/"/>
    
      <category term="csharp" scheme="http://www.tnidea.com/tags/csharp/"/>
    
      <category term="爬虫" scheme="http://www.tnidea.com/categories/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[开源一个社交网站模拟登录的库]]></title>
    <link href="http://www.tnidea.com/social-network-imitate-login.html"/>
    <id>http://www.tnidea.com/social-network-imitate-login.html</id>
    <published>2015-06-26T16:00:00.000Z</published>
    <updated>2015-10-07T08:17:21.000Z</updated>
    <content type="html"><![CDATA[<p> 网站的登录是抓取某些网站的必须步骤，大多数情况我们都是使用一个真实的浏览器去提交我们的登录信息，但是在代码中嵌套浏览器不仅会带来性能损耗，还会带来崩溃的风险。因此就有了这个使用httpRequest来模拟登录的库 <strong><a href="https://github.com/ziyunhx/imitate-login" target="_blank" rel="external">imitate-login</a></strong> ，目前仅有微博网页版和微博Wap版的实现，其它计划实现会根据项目关注度来决定（<strong>Star &amp; fork</strong>）是否更新以及更新时间。</p>
 <a id="more"></a>
<p> <strong>如果这个项目侵犯了您的权益，请及时与我联系（可通过留言或邮件）！我会在收到的一周内协商处理。</strong></p>
<p> 这个类库仅对外提供一个方法： </p>
<p> <code>LoginResult Login(1: string userName, 2: string password, 3: LoginSite loginSite);</code> </p>
<p> 这个方法位于ImitateLogin的LoginHelper类中，使用之前需要先对其进行实例化。通过传入 用户名、密码以及登录的网站，返回一个包含登录结果状态、描述信息以及Cookies字典的类。</p>
<p> 这个类库并没有提供对验证码的支持，微博可以通过设置登录保护来避免验证码的出现：</p>
<p> 位于 设置-&gt;账号安全-&gt;登录保护</p>
<p> <img src="http://www.tnidea.com/media/image/imitate-login-weibo-setting.png" alt="image"></p>
<p> 这个项目支持使用 Apache Thrift 来实现多语言环境下的RPC调用，首先安装Thrift，然后使用以下命令创建目标语言下的接口：</p>
<p> <code>thrift --gen &lt;language&gt; ImitateLogin.thrift</code></p>
<p>将上面命令中的<code>&lt;language&gt;</code>替换为你所使用的语言。Thrift 目前支持以下参数所代表的语言：</p>
<ul>
<li>as3</li>
<li>c_glib</li>
<li>cpp</li>
<li>csharp</li>
<li>delphi</li>
<li>erl</li>
<li>go</li>
<li>hs</li>
<li>java</li>
<li>js</li>
<li>ocaml</li>
<li>perl</li>
<li>php</li>
<li>py</li>
<li>rb</li>
</ul>
<p>然后在csharp端添加服务端得代码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>) </span><br><span class="line"></span>&#123; </span><br><span class="line">	TServerSocket serverTransport = <span class="keyword">new</span> TServerSocket(<span class="number">7901</span>, <span class="number">0</span>, <span class="keyword">false</span>); </span><br><span class="line">	Login.Processor processor = <span class="keyword">new</span> Login.Processor(<span class="keyword">new</span> LoginHelper()); </span><br><span class="line">	TServer server = <span class="keyword">new</span> TSimpleServer(processor, serverTransport); </span><br><span class="line">	Console.WriteLine(<span class="string">"Starting server on port 7901 ..."</span>); </span><br><span class="line">	server.Serve(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 然后在其它语言（例如JAVA）中实现客户端的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TTransport transport = <span class="keyword">new</span> TSocket(<span class="string">"localhost"</span>, <span class="number">7901</span>);</span><br><span class="line">transport.open();</span><br><span class="line">TProtocol protocol = <span class="keyword">new</span> TBinaryProtocol(transport);</span><br><span class="line">Login.Client client = <span class="keyword">new</span> Login.Client(protocol);</span><br><span class="line">client.Login(<span class="string">"username"</span>, <span class="string">"password"</span>, LoginSite.Weibo);</span><br></pre></td></tr></table></figure>
<p>将上述语句中的 username 和 password 替换为真实用于登录的微博账户。</p>
<p>你可以在包含Mono或.Net Framework的环境下运行 <strong><a href="https://github.com/ziyunhx/imitate-login" target="_blank" rel="external">imitate-login</a></strong> 类库。该类库里包含一个使用Gtk+创建的测试窗体程序，如果你希望使用它，需要额外安装 Gtk+ for Mono.</p>
<p>该类库已经完成的社交网站支持：</p>
<ul>
<li>Weibo</li>
<li>WeiboWap</li>
</ul>
<p>计划完成的支持：</p>
<ul>
<li>Taobao</li>
<li>QQ</li>
<li>Facebook</li>
<li>Twitter</li>
<li>Google</li>
</ul>
<p>计划支持部分会根据项目关注度来决定（<strong>Star &amp; fork</strong>）是否更新以及更新时间。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p> 网站的登录是抓取某些网站的必须步骤，大多数情况我们都是使用一个真实的浏览器去提交我们的登录信息，但是在代码中嵌套浏览器不仅会带来性能损耗，还会带来崩溃的风险。因此就有了这个使用httpRequest来模拟登录的库 <strong><a href="https://github.com/ziyunhx/imitate-login">imitate-login</a></strong> ，目前仅有微博网页版和微博Wap版的实现，其它计划实现会根据项目关注度来决定（<strong>Star &amp; fork</strong>）是否更新以及更新时间。</p>]]>
    
    </summary>
    
      <category term=".NET" scheme="http://www.tnidea.com/tags/NET/"/>
    
      <category term="C#" scheme="http://www.tnidea.com/tags/C/"/>
    
      <category term="csharp" scheme="http://www.tnidea.com/tags/csharp/"/>
    
      <category term="social network" scheme="http://www.tnidea.com/tags/social-network/"/>
    
      <category term="thrift" scheme="http://www.tnidea.com/tags/thrift/"/>
    
      <category term="爬虫" scheme="http://www.tnidea.com/categories/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[创建Maven项目打包提交wordcount到Storm集群]]></title>
    <link href="http://www.tnidea.com/deploy-wordcount-topology.html"/>
    <id>http://www.tnidea.com/deploy-wordcount-topology.html</id>
    <published>2015-06-19T16:00:00.000Z</published>
    <updated>2015-10-07T08:15:09.000Z</updated>
    <content type="html"><![CDATA[<p> 在上一篇博客中，我们通过<a href="https://github.com/ziyunhx/storm-net-adapter" title="Storm.Net.Adapter" target="_blank" rel="external">Storm.Net.Adapter</a>创建了一个使用Csharp编写的Storm Topology - wordcount。本文将介绍如何编写Java端的程序以及如何发布到测试的Storm环境中运行。</p>
<a id="more"></a>
<p> 如果你觉得对你有帮助，欢迎Star和Fork，让更多人看到来帮助完善这个项目。</p>
<p> <strong>STEP1</strong>: 克隆storm官方示例项目 <a href="https://github.com/apache/storm/tree/master/examples/storm-starter" target="_blank" rel="external">storm-starter</a>：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone git://github.com/apache/storm.git &#38;&#38; cd storm/examples/storm-starter</span><br></pre></td></tr></table></figure>
<p> <strong>STEP2</strong>: 增加csharp的多语言支持：</p>
<p> 将上一篇博客 <a href="http://www.tnidea.com/you-first-csharp-storm-topology.html" title="使用Csharp创建你的第一个Storm拓扑">使用Csharp创建你的第一个Storm拓扑</a> 中完成的项目编译，把生产的组件拷贝到 <code>/multilang/resources/</code> 文件夹中。</p>
<p> <strong>STEP3</strong>：使用JAVA创建Topology：</p>
<p> 在 <code>/src/jvm/storm/starter/</code> 新增 WordCountTopologyCsharp.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Licensed to the Apache Software Foundation (ASF) under one</span><br><span class="line"> * or more contributor license agreements.  See the NOTICE file</span><br><span class="line"> * distributed with this work for additional information</span><br><span class="line"> * regarding copyright ownership.  The ASF licenses this file</span><br><span class="line"> * to you under the Apache License, Version 2.0 (the</span><br><span class="line"> * "License"); you may not use this file except in compliance</span><br><span class="line"> * with the License.  You may obtain a copy of the License at</span><br><span class="line"> *</span><br><span class="line"> * http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line"> *</span><br><span class="line"> * Unless required by applicable law or agreed to in writing, software</span><br><span class="line"> * distributed under the License is distributed on an "AS IS" BASIS,</span><br><span class="line"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line"> * See the License for the specific language governing permissions and</span><br><span class="line"> * limitations under the License.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">package</span> storm.starter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> backtype.storm.Config;</span><br><span class="line"><span class="keyword">import</span> backtype.storm.LocalCluster;</span><br><span class="line"><span class="keyword">import</span> backtype.storm.StormSubmitter;</span><br><span class="line"><span class="keyword">import</span> backtype.storm.spout.ShellSpout;</span><br><span class="line"><span class="keyword">import</span> backtype.storm.task.ShellBolt;</span><br><span class="line"><span class="keyword">import</span> backtype.storm.topology.IRichBolt;</span><br><span class="line"><span class="keyword">import</span> backtype.storm.topology.IRichSpout;</span><br><span class="line"><span class="keyword">import</span> backtype.storm.topology.OutputFieldsDeclarer;</span><br><span class="line"><span class="keyword">import</span> backtype.storm.topology.TopologyBuilder;</span><br><span class="line"><span class="keyword">import</span> backtype.storm.tuple.Fields;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * This topology demonstrates Storm's stream groupings and multilang capabilities.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCountTopologyCsharp</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generator</span> <span class="keyword">extends</span> <span class="title">ShellSpout</span> <span class="keyword">implements</span> <span class="title">IRichSpout</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Generator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">super</span>(<span class="string">"cmd"</span>, <span class="string">"/k"</span>, <span class="string">"CALL"</span>, <span class="string">"StormSimple.exe"</span>, <span class="string">"generator"</span>);</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="annotation">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer declarer)</span> </span>&#123;</span><br><span class="line">			declarer.declare(<span class="keyword">new</span> Fields(<span class="string">"word"</span>));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="annotation">@Override</span></span><br><span class="line">		<span class="keyword">public</span> Map&lt;String, Object&gt; getComponentConfiguration() &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Splitter</span> <span class="keyword">extends</span> <span class="title">ShellBolt</span> <span class="keyword">implements</span> <span class="title">IRichBolt</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Splitter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">super</span>(<span class="string">"cmd"</span>, <span class="string">"/k"</span>, <span class="string">"CALL"</span>, <span class="string">"StormSimple.exe"</span>, <span class="string">"splitter"</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="annotation">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer declarer)</span> </span>&#123;</span><br><span class="line">			declarer.declare(<span class="keyword">new</span> Fields(<span class="string">"word"</span>, <span class="string">"count"</span>));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="annotation">@Override</span></span><br><span class="line">		<span class="keyword">public</span> Map&lt;String, Object&gt; getComponentConfiguration() &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">ShellBolt</span> <span class="keyword">implements</span> <span class="title">IRichBolt</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Counter</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">super</span>(<span class="string">"cmd"</span>, <span class="string">"/k"</span>, <span class="string">"CALL"</span>, <span class="string">"StormSimple.exe"</span>, <span class="string">"counter"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="annotation">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer declarer)</span> </span>&#123;</span><br><span class="line">			declarer.declare(<span class="keyword">new</span> Fields(<span class="string">"word"</span>, <span class="string">"count"</span>));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="annotation">@Override</span></span><br><span class="line">		<span class="keyword">public</span> Map&lt;String, Object&gt; getComponentConfiguration() &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">		TopologyBuilder builder = <span class="keyword">new</span> TopologyBuilder();</span><br><span class="line"></span><br><span class="line">		builder.setSpout(<span class="string">"generator"</span>, <span class="keyword">new</span> Generator(), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		builder.setBolt(<span class="string">"splitter"</span>, <span class="keyword">new</span> Splitter(), <span class="number">1</span>).fieldsGrouping(<span class="string">"generator"</span>,</span><br><span class="line">				<span class="keyword">new</span> Fields(<span class="string">"word"</span>));</span><br><span class="line">		</span><br><span class="line">		builder.setBolt(<span class="string">"counter"</span>, <span class="keyword">new</span> Counter(), <span class="number">1</span>).fieldsGrouping(<span class="string">"splitter"</span>,</span><br><span class="line">				<span class="keyword">new</span> Fields(<span class="string">"word"</span>, <span class="string">"count"</span>));</span><br><span class="line"></span><br><span class="line">		Config conf = <span class="keyword">new</span> Config();</span><br><span class="line">		conf.setDebug(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (args != <span class="keyword">null</span> &amp;&amp; args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			conf.setNumWorkers(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">			StormSubmitter.submitTopologyWithProgressBar(args[<span class="number">0</span>], conf,</span><br><span class="line">					builder.createTopology());</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			conf.setMaxTaskParallelism(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">			LocalCluster cluster = <span class="keyword">new</span> LocalCluster();</span><br><span class="line">			cluster.submitTopology(<span class="string">"WordCount"</span>, conf, builder.createTopology());</span><br><span class="line"></span><br><span class="line">			Thread.sleep(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">			cluster.shutdown();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本例是在window平台使用.Net执行，如果你使用Mono，或者在其它平台通过Mono运行，请将 </p>
<p><code>super(&quot;cmd&quot;, &quot;/k&quot;, &quot;CALL&quot;, &quot;StormSimple.exe&quot;, &quot;xxxxxx&quot;);</code> </p>
<p>替换为 </p>
<p><code>super(&quot;mono&quot;, &quot;StormSimple.exe&quot;, &quot;xxxxxx&quot;);</code> </p>
<p> <strong>STEP4</strong>：编译并提交Topology：</p>
<ul>
<li>初始化安装storm所需依赖：<code>$ mvn clean install -DskipTests=true</code></li>
<li>使用Maven打包storm拓扑：<code>$ mvn package</code></li>
<li><p>搭建好运行环境并提交：</p>
<p><code>$ storm jar storm-starter-*-jar-with-dependencies.jar storm.starter.WordCountTopologyCsharp wordcount</code></p>
<p>storm集群的搭建请参考系列文章第一篇 <a href="http://www.tnidea.com/deploy-storm-environment.html" title="搭建dotNet开发Storm拓扑的环境">搭建dotNet开发Storm拓扑的环境</a></p>
<p><img src="http://www.tnidea.com/media/image/storm-3-01.png" alt="image"></p>
<p><img src="http://www.tnidea.com/media/image/storm-3-02.png" alt="image"></p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p> 在上一篇博客中，我们通过<a href="https://github.com/ziyunhx/storm-net-adapter" title="Storm.Net.Adapter">Storm.Net.Adapter</a>创建了一个使用Csharp编写的Storm Topology - wordcount。本文将介绍如何编写Java端的程序以及如何发布到测试的Storm环境中运行。</p>]]>
    
    </summary>
    
      <category term=".NET" scheme="http://www.tnidea.com/tags/NET/"/>
    
      <category term="C#" scheme="http://www.tnidea.com/tags/C/"/>
    
      <category term="Storm" scheme="http://www.tnidea.com/tags/Storm/"/>
    
      <category term="csharp" scheme="http://www.tnidea.com/tags/csharp/"/>
    
      <category term="wordcount" scheme="http://www.tnidea.com/tags/wordcount/"/>
    
      <category term="Storm" scheme="http://www.tnidea.com/categories/Storm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Csharp创建你的第一个Storm拓扑（wordcount）]]></title>
    <link href="http://www.tnidea.com/you-first-csharp-storm-topology.html"/>
    <id>http://www.tnidea.com/you-first-csharp-storm-topology.html</id>
    <published>2015-06-03T16:00:00.000Z</published>
    <updated>2015-10-07T08:18:04.000Z</updated>
    <content type="html"><![CDATA[<p> WordCount在大数据领域就像学习一门语言时的hello world，得益于Storm的开源以及<a href="https://github.com/ziyunhx/storm-net-adapter" title="Storm.Net.Adapter" target="_blank" rel="external">Storm.Net.Adapter</a>，现在我们也可以像Java或Python一样，使用Csharp创建原生支持的Storm Topologies。下面我将通过介绍wordcount来展示如何使用Csharp开发Storm拓扑。</p>
<a id="more"></a>
<p> 上篇博客已经介绍了如何部署Storm开发环境，本文所讲述demo已包含在<a href="https://github.com/ziyunhx/storm-net-adapter" title="Storm.Net.Adapter" target="_blank" rel="external">Storm.Net.Adapter</a>中，如果你觉得对你有帮助，欢迎Star和Fork，让更多人看到来帮助完善这个项目。</p>
<p> 首先，我们创建一个控制台应用程序（使用控制台是方便调用） StormSimple；使用Nuget添加添加Storm.Net.Adapter（该类库的namespace为Storm）。</p>
<p><img src="http://www.tnidea.com/media/image/wordcount-project.png" alt="wordcount project"></p>
<p> <strong>STEP1</strong>：通过继承ISpout创建一个Spout：Generator，实现ISpout的四个方法：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Open</span>(<span class="params">Config stormConf, TopologyContext context</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NextTuple</span>(<span class="params"></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Ack</span>(<span class="params"><span class="keyword">long</span> seqId</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fail</span>(<span class="params"><span class="keyword">long</span> seqId</span>)</span>;</span><br></pre></td></tr></table></figure>
<p> 在实现这4个方法之前，我们还需要创建一些变量和方法来初始化这个类：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Context ctx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Generator</span>(<span class="params">Context ctx</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">	Context.Logger.Info(<span class="string">"Generator constructor called"</span>);</span><br><span class="line">	<span class="keyword">this</span>.ctx = ctx;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Declare Output schema</span></span><br><span class="line">	Dictionary&lt;<span class="keyword">string</span>, List&lt;Type&gt;&gt; outputSchema = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, List&lt;Type&gt;&gt;();</span><br><span class="line">	outputSchema.Add(<span class="string">"default"</span>, <span class="keyword">new</span> List&lt;Type&gt;() &#123; <span class="keyword">typeof</span>(<span class="keyword">string</span>) &#125;);</span><br><span class="line">	<span class="keyword">this</span>.ctx.DeclareComponentSchema(<span class="keyword">new</span> ComponentStreamSchema(<span class="keyword">null</span>, outputSchema));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 我使用了一个私有变量<code>ctx</code>来保存实例化时传入的Context对象，Context有一个静态的Logger，用于日志的发送，我们无需实例化即可使用它。根据日志级别不同，包含 Trace Debug Info Warn Error 五个级别，另外我们在实例化方法里还需要定义输入和输出的参数的数量和类型，本例子中输入为<code>null</code>，输出为一个字符串。另外我们还创建一个方法来直接返回实例化后的类：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="xmlDocTag">///</span>  Implements of delegate "newPlugin", which is used to create a instance of this spout/bolt</span></span><br><span class="line"><span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="ctx"&gt;</span>Context instance<span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;returns&gt;</span><span class="xmlDocTag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Generator <span class="title">Get</span>(<span class="params">Context ctx</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Generator(ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 其中Open在该类第一次任务调用前执行，主要用于预处理和一些配置信息的传入，大多数情况下，我们并不需要做什么；NextTuple方法用于生成Tuple，会不断被调用，因此如果没什么任务要向下发送，可以使用<code>Thread.Sleep(50);</code>来减少CPU的消耗（具体休息时间与Topology设置有关，只要不超过超时时间就没有问题）。</p>
<p> 本例子中NextTuple主要用于从一个包含英语句子的数组中随机取出一条句子，并把它发送到下一个环节，为了能够保证所有的任务都被成功执行一遍，我们将发送的消息缓存起来，并且限制正在执行中的任务数量为20。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">int</span> MAX_PENDING_TUPLE_NUM = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> lastSeqId = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> Dictionary&lt;<span class="keyword">long</span>, <span class="keyword">string</span>&gt; cachedTuples = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">long</span>, <span class="keyword">string</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Random rand = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="keyword">string</span>[] sentences = <span class="keyword">new</span> <span class="keyword">string</span>[] &#123;</span><br><span class="line">                                  <span class="string">"the cow jumped over the moon"</span>,</span><br><span class="line">                                  <span class="string">"an apple a day keeps the doctor away"</span>,</span><br><span class="line">                                  <span class="string">"four score and seven years ago"</span>,</span><br><span class="line">                                  <span class="string">"snow white and the seven dwarfs"</span>,</span><br><span class="line">                                  <span class="string">"i am at two with nature"</span>&#125;;</span><br><span class="line"><span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="xmlDocTag">///</span> This method is used to emit one or more tuples. If there is nothing to emit, this method should return without emitting anything. </span></span><br><span class="line"><span class="comment"><span class="xmlDocTag">///</span> It should be noted that NextTuple(), Ack(), and Fail() are all called in a tight loop in a single thread in C# process. </span></span><br><span class="line"><span class="comment"><span class="xmlDocTag">///</span> When there are no tuples to emit, it is courteous to have NextTuple sleep for a short amount of time (such as 10 milliseconds), so as not to waste too much CPU.</span></span><br><span class="line"><span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">NextTuple</span>(<span class="params"></span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    Context.Logger.Info(<span class="string">"NextTuple enter"</span>);</span><br><span class="line">    <span class="keyword">string</span> sentence;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cachedTuples.Count &lt;= MAX_PENDING_TUPLE_NUM)</span><br><span class="line">    &#123;</span><br><span class="line">        lastSeqId++;</span><br><span class="line">        sentence = sentences[rand.Next(<span class="number">0</span>, sentences.Length - <span class="number">1</span>)];</span><br><span class="line">        Context.Logger.Info(<span class="string">"Generator Emit: &#123;0&#125;, seqId: &#123;1&#125;"</span>, sentence, lastSeqId);</span><br><span class="line">        <span class="keyword">this</span>.ctx.Emit(<span class="string">"default"</span>, <span class="keyword">new</span> List&lt;<span class="keyword">object</span>&gt;() &#123; sentence &#125;, lastSeqId);</span><br><span class="line">        cachedTuples[lastSeqId] = sentence;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// if have nothing to emit, then sleep for a little while to release CPU</span></span><br><span class="line">        Thread.Sleep(<span class="number">50</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Context.Logger.Info(<span class="string">"cached tuple num: &#123;0&#125;"</span>, cachedTuples.Count);</span><br><span class="line"></span><br><span class="line">    Context.Logger.Info(<span class="string">"Generator NextTx exit"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <code>this.ctx.Emit</code> 即用来把Topology发送给下一个Bolt。</p>
<p> Ack()和Fail()方法分别在整个Topology执行成功和Topology失败时被调用。本例中Ack主要是移除缓存，Fail主要是用于取出缓存数据并重新发送Tuple。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="xmlDocTag">///</span> Ack() will be called only when ack mechanism is enabled in spec file.</span></span><br><span class="line"><span class="comment"><span class="xmlDocTag">///</span> If ack is not supported in non-transactional topology, the Ack() can be left as empty function. </span></span><br><span class="line"><span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="seqId"&gt;</span>Sequence Id of the tuple which is acked.<span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Ack</span>(<span class="params"><span class="keyword">long</span> seqId</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    Context.Logger.Info(<span class="string">"Ack, seqId: &#123;0&#125;"</span>, seqId);</span><br><span class="line">    <span class="keyword">bool</span> result = cachedTuples.Remove(seqId);</span><br><span class="line">    <span class="keyword">if</span> (!result)</span><br><span class="line">    &#123;</span><br><span class="line">        Context.Logger.Warn(<span class="string">"Ack(), remove cached tuple for seqId &#123;0&#125; fail!"</span>, seqId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="xmlDocTag">///</span> Fail() will be called only when ack mechanism is enabled in spec file. </span></span><br><span class="line"><span class="comment"><span class="xmlDocTag">///</span> If ack is not supported in non-transactional topology, the Fail() can be left as empty function.</span></span><br><span class="line"><span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="seqId"&gt;</span>Sequence Id of the tuple which is failed.<span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fail</span>(<span class="params"><span class="keyword">long</span> seqId</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    Context.Logger.Info(<span class="string">"Fail, seqId: &#123;0&#125;"</span>, seqId);</span><br><span class="line">    <span class="keyword">if</span> (cachedTuples.ContainsKey(seqId))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">string</span> sentence = cachedTuples[seqId];</span><br><span class="line">        Context.Logger.Info(<span class="string">"Re-Emit: &#123;0&#125;, seqId: &#123;1&#125;"</span>, sentence, seqId);</span><br><span class="line">        <span class="keyword">this</span>.ctx.Emit(<span class="string">"default"</span>, <span class="keyword">new</span> List&lt;<span class="keyword">object</span>&gt;() &#123; sentence &#125;, seqId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Context.Logger.Warn(<span class="string">"Fail(), can't find cached tuple for seqId &#123;0&#125;!"</span>, seqId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 至此，一个Spout就算完成了，下面我们继续分析Bolt。</p>
<p> <strong>STEP2</strong>：通过继承IBasicBolt创建Bolt：Splitter、Counter。</p>
<p> Splitter是一个通过空格来拆分英语句子为一个个独立的单词，Counter则用来统计各个单词出现的次数。我们只详细分析Splitter，Counter类仅贴出全部源码。</p>
<p> 和Generator相同，我们首先也要构造一个实例化方法方便使用者传参和调用：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Context ctx;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> msgTimeoutSecs;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Splitter</span>(<span class="params">Context ctx</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    Context.Logger.Info(<span class="string">"Splitter constructor called"</span>);</span><br><span class="line">    <span class="keyword">this</span>.ctx = ctx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Declare Input and Output schemas</span></span><br><span class="line">    Dictionary&lt;<span class="keyword">string</span>, List&lt;Type&gt;&gt; inputSchema = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, List&lt;Type&gt;&gt;();</span><br><span class="line">    inputSchema.Add(<span class="string">"default"</span>, <span class="keyword">new</span> List&lt;Type&gt;() &#123; <span class="keyword">typeof</span>(<span class="keyword">string</span>) &#125;);</span><br><span class="line">    Dictionary&lt;<span class="keyword">string</span>, List&lt;Type&gt;&gt; outputSchema = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, List&lt;Type&gt;&gt;();</span><br><span class="line">    outputSchema.Add(<span class="string">"default"</span>, <span class="keyword">new</span> List&lt;Type&gt;() &#123; <span class="keyword">typeof</span>(<span class="keyword">string</span>), <span class="keyword">typeof</span>(<span class="keyword">char</span>) &#125;);</span><br><span class="line">    <span class="keyword">this</span>.ctx.DeclareComponentSchema(<span class="keyword">new</span> ComponentStreamSchema(inputSchema, outputSchema));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Demo how to get stormConf info</span></span><br><span class="line">    <span class="keyword">if</span> (Context.Config.StormConf.ContainsKey(<span class="string">"topology.message.timeout.secs"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        msgTimeoutSecs = Convert.ToInt32(Context.Config.StormConf[<span class="string">"topology.message.timeout.secs"</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    Context.Logger.Info(<span class="string">"msgTimeoutSecs: &#123;0&#125;"</span>, msgTimeoutSecs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="xmlDocTag">///</span>  Implements of delegate "newPlugin", which is used to create a instance of this spout/bolt</span></span><br><span class="line"><span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="ctx"&gt;</span>Context instance<span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;returns&gt;</span><span class="xmlDocTag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Splitter <span class="title">Get</span>(<span class="params">Context ctx</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Splitter(ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 在这个实例化方法中，我们增加了一个没有使用的变量<code>msgTimeoutSecs</code>用来展示如何获取Topology的配置。</p>
<p> 由于继承了IBasicBolt，我们需要实现以下两个方法：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Prepare</span>(<span class="params">Config stormConf, TopologyContext context</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Execute</span>(<span class="params">StormTuple tuple</span>)</span>;</span><br></pre></td></tr></table></figure>
<p> 这和IBolt是一致的，IBasicBolt和IBolt的区别仅仅在于后者需要自己处理何时向Storm发送Ack或Fail，IBasicBolt则不需要关心这些，如果你的Execute没有抛出异常的话，总会在最后向Storm发送Ack，否则则发送Fail。Prepare则是用于执行前的预处理，此例子里同样什么都不需要做。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="xmlDocTag">///</span> The Execute() function will be called, when a new tuple is available.</span></span><br><span class="line"><span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="tuple"&gt;</span><span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params">StormTuple tuple</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    Context.Logger.Info(<span class="string">"Execute enter"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">string</span> sentence = tuple.GetString(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">string</span> word <span class="keyword">in</span> sentence.Split(<span class="string">' '</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        Context.Logger.Info(<span class="string">"Splitter Emit: &#123;0&#125;"</span>, word);</span><br><span class="line">        <span class="keyword">this</span>.ctx.Emit(<span class="string">"default"</span>, <span class="keyword">new</span> List&lt;StormTuple&gt; &#123; tuple &#125;, <span class="keyword">new</span> List&lt;<span class="keyword">object</span>&gt; &#123; word, word[<span class="number">0</span>] &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Context.Logger.Info(<span class="string">"Splitter Execute exit"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Prepare</span>(<span class="params">Config stormConf, TopologyContext context</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> Counter和上述的代码类似：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Storm;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">StormSample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> The bolt "counter" uses a dictionary to record the occurrence number of each word.</span></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Counter</span> : <span class="title">IBasicBolt</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> Context ctx;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">int</span>&gt; counts = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Counter</span>(<span class="params">Context ctx</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            Context.Logger.Info(<span class="string">"Counter constructor called"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.ctx = ctx;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Declare Input and Output schemas</span></span><br><span class="line">            Dictionary&lt;<span class="keyword">string</span>, List&lt;Type&gt;&gt; inputSchema = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, List&lt;Type&gt;&gt;();</span><br><span class="line">            inputSchema.Add(<span class="string">"default"</span>, <span class="keyword">new</span> List&lt;Type&gt;() &#123; <span class="keyword">typeof</span>(<span class="keyword">string</span>), <span class="keyword">typeof</span>(<span class="keyword">char</span>) &#125;);</span><br><span class="line"></span><br><span class="line">            Dictionary&lt;<span class="keyword">string</span>, List&lt;Type&gt;&gt; outputSchema = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, List&lt;Type&gt;&gt;();</span><br><span class="line">            outputSchema.Add(<span class="string">"default"</span>, <span class="keyword">new</span> List&lt;Type&gt;() &#123; <span class="keyword">typeof</span>(<span class="keyword">string</span>), <span class="keyword">typeof</span>(<span class="keyword">int</span>) &#125;);</span><br><span class="line">            <span class="keyword">this</span>.ctx.DeclareComponentSchema(<span class="keyword">new</span> ComponentStreamSchema(inputSchema, outputSchema));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> The Execute() function will be called, when a new tuple is available.</span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="tuple"&gt;</span><span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params">StormTuple tuple</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            Context.Logger.Info(<span class="string">"Execute enter"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">string</span> word = tuple.GetString(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">int</span> count = counts.ContainsKey(word) ? counts[word] : <span class="number">0</span>;</span><br><span class="line">            count++;</span><br><span class="line">            counts[word] = count;</span><br><span class="line"></span><br><span class="line">            Context.Logger.Info(<span class="string">"Counter Emit: &#123;0&#125;, count: &#123;1&#125;"</span>, word, count);</span><br><span class="line">            <span class="keyword">this</span>.ctx.Emit(<span class="string">"default"</span>, <span class="keyword">new</span> List&lt;StormTuple&gt; &#123; tuple &#125;, <span class="keyword">new</span> List&lt;<span class="keyword">object</span>&gt; &#123; word, count &#125;);</span><br><span class="line"></span><br><span class="line">            Context.Logger.Info(<span class="string">"Counter Execute exit"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span>  Implements of delegate "newPlugin", which is used to create a instance of this spout/bolt</span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="ctx"&gt;</span>Context instance<span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;returns&gt;</span><span class="xmlDocTag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Counter <span class="title">Get</span>(<span class="params">Context ctx</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Counter(ctx);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Prepare</span>(<span class="params">Config stormConf, TopologyContext context</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>STEP3</strong>：修改Program.cs来方便使用Java调用。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Storm;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">StormSample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (args.Count() &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">string</span> compName = args[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">"generator"</span>.Equals(compName))</span><br><span class="line">                    &#123;</span><br><span class="line">                        ApacheStorm.LaunchPlugin(<span class="keyword">new</span> newPlugin(Generator.Get));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="function"><span class="keyword">else</span> <span class="title">if</span> (<span class="params"><span class="string">"splitter"</span>.Equals(compName</span>))</span><br><span class="line">                    </span>&#123;</span><br><span class="line">                        ApacheStorm.LaunchPlugin(<span class="keyword">new</span> newPlugin(Splitter.Get));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="function"><span class="keyword">else</span> <span class="title">if</span> (<span class="params"><span class="string">"counter"</span>.Equals(compName</span>))</span><br><span class="line">                    </span>&#123;</span><br><span class="line">                        ApacheStorm.LaunchPlugin(<span class="keyword">new</span> newPlugin(Counter.Get));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="keyword">string</span>.Format(<span class="string">"unexpected compName: &#123;0&#125;"</span>, compName));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">                &#123;</span><br><span class="line">                    Context.Logger.Error(ex.ToString());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Context.Logger.Error(<span class="string">"Not support local model."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 我们在Main方法里使用参数来确定具体调用的是哪个Spout/Bolt，ApacheStorm是一个包含主要方法的类，之所以不使用Storm只是因为命名空间占用了它。Csharp端的代码到此就全部结束了，Java端的代码与部署发布将在下一篇详细介绍，敬请期待！下面让我们来看一看整个Topology的流程吧！</p>
<p> <img src="http://www.tnidea.com/media/image/wordcount-topology.png" alt="WordCount Topology"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p> WordCount在大数据领域就像学习一门语言时的hello world，得益于Storm的开源以及<a href="https://github.com/ziyunhx/storm-net-adapter" title="Storm.Net.Adapter">Storm.Net.Adapter</a>，现在我们也可以像Java或Python一样，使用Csharp创建原生支持的Storm Topologies。下面我将通过介绍wordcount来展示如何使用Csharp开发Storm拓扑。</p>]]>
    
    </summary>
    
      <category term=".NET" scheme="http://www.tnidea.com/tags/NET/"/>
    
      <category term="C#" scheme="http://www.tnidea.com/tags/C/"/>
    
      <category term="Storm" scheme="http://www.tnidea.com/tags/Storm/"/>
    
      <category term="csharp" scheme="http://www.tnidea.com/tags/csharp/"/>
    
      <category term="wordcount" scheme="http://www.tnidea.com/tags/wordcount/"/>
    
      <category term="Storm" scheme="http://www.tnidea.com/categories/Storm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[搭建.Net开发Storm拓扑的环境]]></title>
    <link href="http://www.tnidea.com/deploy-storm-environment.html"/>
    <id>http://www.tnidea.com/deploy-storm-environment.html</id>
    <published>2015-05-19T16:00:00.000Z</published>
    <updated>2015-10-07T08:13:28.000Z</updated>
    <content type="html"><![CDATA[<p> 上篇博客比较了目前流行的计算框架特性，如果你是 Java 开发者，那么根据业务场景选择即可；但是如果你是 .Net 开发者，那么三者都不能拿来即用，至少在这篇文章出现之前是如此。基于上篇文章的比较发现，Storm 应该是对多语言支持比较好的框架了，但即便如此，官方也没有提供 .Net 的适配器，网上也找不到第三方的开源库。So，<a href="https://github.com/ziyunhx/storm-net-adapter" title="Storm.Net.Adapter" target="_blank" rel="external">Storm.Net.Adapter</a> 出现了，一个使用 Csharp 开发的 针对 Apache Storm 的适配器！</p>
<a id="more"></a>
<p> 本文是“Storm系列”的第一篇，后期会根据时间情况继续更新，欢迎大家关注文章末尾处的微信公众号：dotNet大数据，如果你愿意提供素材或建议，欢迎通过 About 中的邮箱与我联系。</p>
<h2 id="安装Storm与依赖环境">安装Storm与依赖环境</h2><h3 id="安装Zookeeper">安装Zookeeper</h3><ul>
<li>获取最新 Zookeeper 程序包：<a href="http://zookeeper.apache.org/" title="zookeeper" target="_blank" rel="external">官网</a></li>
<li>解压程序包，拷贝 conf 下 zoo_sample.cfg 为 zoo.cfg，修改相关配置</li>
<li>Windows 环境下直接执行 bin\zkServer.cmd；Linux 下执行 <code>bin/zkServer.sh start</code></li>
</ul>
<h3 id="安装Python,_Java与Maven">安装Python, Java与Maven</h3><ul>
<li>下载 Python 2.x 安装</li>
<li>下载 JAVA 6+ 安装，必须安装 JDK 版，否则使用 Maven 时会出错</li>
<li>下载 Maven 并安装</li>
</ul>
<h3 id="下载Storm">下载Storm</h3><ul>
<li>获取最新 Storm 程序包：<a href="http://storm.apache.org/downloads.html" title="Storm" target="_blank" rel="external">官网</a></li>
<li>解压后修改 conf 下的 storm.yaml 里的相关配置</li>
</ul>
<h3 id="配置环境变量">配置环境变量</h3><ul>
<li>配置 Storm_Home 与 Java_Home; 目录最好不要有空格</li>
<li>classPath 里增加 <code>.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\toos.jar;</code></li>
<li>path 里增加 <code>%STORM_HOME%\bin;%JAVA_HOME%\bin;</code></li>
<li>将 Maven 的目录也加到 path 方便使用</li>
</ul>
<h3 id="Storm启动">Storm启动</h3><ul>
<li>启动 Zookeeper</li>
<li>运行 <code>storm nimbus</code> （如果未将 Storm 加到 path，需要先切换到 Storm 的 bin 目录，下同）</li>
<li>运行 <code>storm supervisor</code> （集群环境下，非主可以仅执行该句）</li>
<li>运行 <code>storm ui</code>，通过 <a href="http://localhost:8080/" target="_blank" rel="external">http://localhost:8080/</a> 监控 Storm 运行状况</li>
</ul>
<h2 id="使用_Storm-Net-Adapter">使用 Storm.Net.Adapter</h2><h3 id="获取_Storm-Net-Adapter">获取 Storm.Net.Adapter</h3><p> 目前有以下几种方式获取最新的 Storm.Net.Adapter 库</p>
<ul>
<li>通过源代码编译自己的版本： <a href="https://github.com/ziyunhx/storm-net-adapter" title="Storm.Net.Adapter" target="_blank" rel="external">GitHub</a></li>
<li>下载编译好的版本加入引用： <a href="https://github.com/ziyunhx/storm-net-adapter/releases" title="Storm.Net.Adapter Release" target="_blank" rel="external">Release</a></li>
<li>使用 NuGet 获取最新版本（推荐）：<code>PM&gt; Install-Package Storm.Net.Adapter</code></li>
</ul>
<h3 id="创建示例项目">创建示例项目</h3><ul>
<li>在项目中引用 Storm.Net.Adapter，创建 Spout （基于ISpout）和 Bolt （基于IBolt或IBasicBolt），都需要 <code>using Storm;</code></li>
<li>创建一个使用 Maven 管理的 Java 项目，增加 dotNet 程序对应的 Topology</li>
<li><p>Windows（.Net Framework）平台下，你可以通过下面的方式来调用你的 Spout 或 Bolt：</p>
<pre><code><span class="keyword">super</span>(<span class="string">"cmd"</span>, <span class="string">"/k"</span>, <span class="string">"CALL"</span>, <span class="string">"StormSimple.exe"</span>, <span class="string">"generator"</span>);
</code></pre></li>
<li><p>Linux, Mac OSX, Windows（mono）平台下，你可以通过下面的方式来调用你的 Spout 或 Bolt：</p>
<pre><code><span class="keyword">super</span>(<span class="string">"mono"</span>, <span class="string">"StormSimple.exe"</span>, <span class="string">"generator"</span>);
</code></pre></li>
</ul>
<h3 id="打包与发布">打包与发布</h3><ul>
<li><p>拷贝编译好的 dotNet 程序到 resources 目录下，使用下面的 Maven 命令打包你的 Topology：</p>
<pre><code>$ mvn <span class="package"><span class="keyword">package</span></span>
</code></pre></li>
<li><p>通过 Storm 命令行工具提交你创建好的 Topology：</p>
<pre><code>$ storm jar storm-starter-*-jar-with-dependencies<span class="class">.jar</span> storm<span class="class">.starter</span><span class="class">.WordCountTopologyCsharp</span> wordcount
</code></pre></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p> 上篇博客比较了目前流行的计算框架特性，如果你是 Java 开发者，那么根据业务场景选择即可；但是如果你是 .Net 开发者，那么三者都不能拿来即用，至少在这篇文章出现之前是如此。基于上篇文章的比较发现，Storm 应该是对多语言支持比较好的框架了，但即便如此，官方也没有提供 .Net 的适配器，网上也找不到第三方的开源库。So，<a href="https://github.com/ziyunhx/storm-net-adapter" title="Storm.Net.Adapter">Storm.Net.Adapter</a> 出现了，一个使用 Csharp 开发的 针对 Apache Storm 的适配器！</p>]]>
    
    </summary>
    
      <category term="Storm" scheme="http://www.tnidea.com/tags/Storm/"/>
    
      <category term="zookeeper" scheme="http://www.tnidea.com/tags/zookeeper/"/>
    
      <category term="分布式" scheme="http://www.tnidea.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="流式框架" scheme="http://www.tnidea.com/tags/%E6%B5%81%E5%BC%8F%E6%A1%86%E6%9E%B6/"/>
    
      <category term="部署" scheme="http://www.tnidea.com/tags/%E9%83%A8%E7%BD%B2/"/>
    
      <category term="Storm" scheme="http://www.tnidea.com/categories/Storm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[开源分布式计算系统框架比较]]></title>
    <link href="http://www.tnidea.com/compare-with-distributed-computation-system.html"/>
    <id>http://www.tnidea.com/compare-with-distributed-computation-system.html</id>
    <published>2015-05-02T16:00:00.000Z</published>
    <updated>2015-10-07T08:08:33.000Z</updated>
    <content type="html"><![CDATA[<p> 分布式计算在许多领域都有广泛需求，目前流行的分布式计算框架主要有 Hadoop MapReduce, Spark Streaming, Storm； 这三个框架各有优势，现在都属于 Apache 基金会下的顶级项目，下文将对三个框架的特点与适用场景进行分析，以便开发者能快速选择适合自己的框架进行开发。</p>
<a id="more"></a>
<p> Hadoop MapReduce 是三者中出现最早，知名度最大的分布式计算框架，最早由 Google Lab 开发，使用者遍布全球（<a href="http://wiki.apache.org/hadoop/PoweredBy" title="Hadoop PoweredBy" target="_blank" rel="external">Hadoop PoweredBy</a>）；主要适用于大批量的集群任务，由于是批量执行，故时效性偏低，原生支持 Java 语言开发 MapReduce ，其它语言需要使用到 Hadoop Streaming 来开发。Spark Streaming 保留了 Hadoop MapReduce 的优点，而且在时效性上有了很大提高，中间结果可以保存在内存中，从而对需要迭代计算和有较高时效性要求的系统提供了很好的支持，多用于能容忍小延时的推荐与计算系统。Storm 一开始就是为实时处理设计，因此在实时分析/性能监测等需要高时效性的领域广泛采用，而且它理论上支持所有语言，只需要少量代码即可完成适配器。</p>
<p> 下面的表格是对三者部分特性的比较，描述时间为 2015-5-3，三个项目均处于快速迭代中，文中描述特性会随时产生变化，如果与官方文档产生出入以官方文档为准。</p>
<table>
<thead>
<tr>
<th>比较项</th>
<th>Storm</th>
<th>Spark Streaming</th>
<th>Hadoop MapReduce</th>
</tr>
</thead>
<tbody>
<tr>
<td>血统</td>
<td>Twitter</td>
<td>UC Berkeley AMP lab</td>
<td>Google Lab</td>
</tr>
<tr>
<td>开源时间</td>
<td>2011.9.16</td>
<td>2011.5.24</td>
<td>2007.9.4</td>
</tr>
<tr>
<td>当前版本</td>
<td>0.9.4</td>
<td>1.3.1</td>
<td>2.7.0</td>
</tr>
<tr>
<td>相关资料</td>
<td>多</td>
<td>多</td>
<td>极多</td>
</tr>
<tr>
<td>依赖环境</td>
<td>Zookeeper、Java、Python</td>
<td>hadoop client、Scala</td>
<td>Java、ssh</td>
</tr>
<tr>
<td>技术语言</td>
<td>Java、Clojure</td>
<td>Scala</td>
<td>Java</td>
</tr>
<tr>
<td>支持语言</td>
<td>Any</td>
<td>Scala、Java、Python</td>
<td>Java &amp; Others</td>
</tr>
<tr>
<td>延时</td>
<td>实时</td>
<td>秒级</td>
<td>较高</td>
</tr>
<tr>
<td>网络带宽</td>
<td>一般</td>
<td>一般</td>
<td>一般</td>
</tr>
<tr>
<td>硬盘IO</td>
<td>一般</td>
<td>少</td>
<td>较少</td>
</tr>
<tr>
<td>集群支持</td>
<td>好</td>
<td>超过1000节点</td>
<td>数千个节点</td>
</tr>
<tr>
<td>吞吐量</td>
<td>较好</td>
<td>好</td>
<td>好</td>
</tr>
<tr>
<td>使用公司</td>
<td>淘宝、百度、Twitte、Groupon、雅虎</td>
<td>Intel、腾讯、淘宝、中移动、Google</td>
<td>EBay、Facebook、Google、IBM</td>
</tr>
<tr>
<td>适用场景</td>
<td>实时的小数据块的分析计算</td>
<td>较大数据块又需要高时效性的小批量计算</td>
<td>低时效性的大批量计算</td>
</tr>
</tbody>
</table>
<p>表格说明：</p>
<ul>
<li>开源时间以 github 上最早的 commit 或者官网上最早发布版本的时间为准。</li>
<li>当前版本与特性描述截止 2015-5-3。</li>
<li>相关资料量通过比较官方文档、搜索引擎、论坛等途径得出。</li>
<li>部分比较数据来源于实践或相关文章（未找到出处）。</li>
</ul>
<p>本文会保持更新，如果数据发现有出入，欢迎指正。</p>
<p>参考资料：</p>
<ul>
<li><a href="http://hadoop.apache.org/index.html" title="hadoop" target="_blank" rel="external">Hadoop 官网</a></li>
<li><a href="http://spark.apache.org/streaming/" title="Spark Streaming" target="_blank" rel="external">Spark Streaming</a></li>
<li><a href="http://storm.apache.org/" title="storm" target="_blank" rel="external">Storm 官网</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p> 分布式计算在许多领域都有广泛需求，目前流行的分布式计算框架主要有 Hadoop MapReduce, Spark Streaming, Storm； 这三个框架各有优势，现在都属于 Apache 基金会下的顶级项目，下文将对三个框架的特点与适用场景进行分析，以便开发者能快速选择适合自己的框架进行开发。</p>]]>
    
    </summary>
    
      <category term="Hadoop MapReduce" scheme="http://www.tnidea.com/tags/Hadoop-MapReduce/"/>
    
      <category term="Spark Streaming" scheme="http://www.tnidea.com/tags/Spark-Streaming/"/>
    
      <category term="Storm" scheme="http://www.tnidea.com/tags/Storm/"/>
    
      <category term="分布式" scheme="http://www.tnidea.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="流式框架" scheme="http://www.tnidea.com/tags/%E6%B5%81%E5%BC%8F%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Storm" scheme="http://www.tnidea.com/categories/Storm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在VS项目中通过GIT生成版本号作为编译版本号]]></title>
    <link href="http://www.tnidea.com/git-project-version.html"/>
    <id>http://www.tnidea.com/git-project-version.html</id>
    <published>2013-10-31T16:00:00.000Z</published>
    <updated>2015-10-07T08:15:59.000Z</updated>
    <content type="html"><![CDATA[<p> 上一篇博客写了如何在 .Net 项目使用 SVN 作为版本控制工具时生成与代码对应的组件版本号。虽然在公司一直使用 SVN ，但我却对 GIT 情有独钟，但少有文章提及如何具体在 Windows 平台来获得版本号。这让我有了迫切得到方法的希望。下面会具体实现如何在VS中使用Git版本号作为编译产生的文件版本号。</p>
<a id="more"></a>
<p> 上篇博客 <a href="http://www.tnidea.com/svn-project-version.html" title="在VS项目中使用SVN版本号作为编译版本号">《在VS项目中使用SVN版本号作为编译版本号》</a></p>
<p> 将 GIT 的 commit 作为 .Net 项目编译后生成dll的文件版本号主要有以下几个困难。</p>
<ul>
<li>GIT 没有一个数字的序号，而是一个SHA散列码；</li>
<li><p>GIT 提供的命令在 linux 十分方便，在 Windows 下需要额外的工具。</p>
<p>第一个问题好解决，我们取当前文件夹 commit 的次数加上截取一段 SHA 码就可以作为文件版本号的最后一位。第二个问题目前想到的方法是调用 msysgit 提供的 Git Bash 来执行命令。</p>
<p>好了，首先我们依旧得找到 msysgit 的安装目录，一查之下头就大了，各个地方的路径都感觉不靠谱，最后还是选用了<br><code>HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\Git_is1</code> 的 <code>InstallLocation</code> ，当然也可以通过 temp 环境变量来获取路径，安装时选择第二或第三项：</p>
</li>
</ul>
<p><img src="http://www.tnidea.com/media/image/git-setup.png" alt="git-setup"></p>
<p> 然后参照 Git Bash 的快捷方式拼接了下 call 的语句。写了一个 sh 文件来获得版本号，并保存到文件：</p>
<pre><code><span class="comment"># file name: git_ver.sh</span>
<span class="shebang">#!/bin/bash </span>
VER_FILE=git_version.tmp
LOCALVER=`git rev-list HEAD | wc <span class="operator">-l</span> | awk <span class="string">'{print $1}'</span>`
VER=r<span class="variable">$LOCALVER</span>
VER=<span class="string">"<span class="variable">$VER</span> <span class="variable">$(git rev-list HEAD -n 1 | cut -c 1-7)</span>"</span>
GIT_VERSION=<span class="variable">$VER</span>
<span class="built_in">echo</span> <span class="variable">$GIT_VERSION</span>&gt;<span class="variable">$VER_FILE</span>
</code></pre><p> 在批处理里取出刚保存文件的值，接下来的工作就和使用 SVN 里的差不多了，唯一的区别是我们要自己实现关键字的替换。</p>
<p> 上篇博客 <a href="http://www.tnidea.com/svn-project-version.html" title="在VS项目中使用SVN版本号作为编译版本号">《在VS项目中使用SVN版本号作为编译版本号》</a></p>
<p> 建立以一个 AssemblyInfo.tpl 作为替换使用的模板，由于 AssemblyInfo.cs 中除了固定的值外还有类似 GUID 变化的值，所以我们不能全部替换，因此仅将需要修改的部分放在 tpl 中，内容如下：</p>
<pre><code>[assembly: <span class="function"><span class="title">AssemblyVersion</span><span class="params">(<span class="string">"1.0.0.0"</span>)</span></span>]
[assembly: <span class="function"><span class="title">AssemblyFileVersion</span><span class="params">(<span class="string">"1.0.0.GITVERSION"</span>)</span></span>]
</code></pre><p> 自己替换 GITVERSION 字段为前面取到的版本号。</p>
<p> 接下来使用批处理替换原来的 AssemblyInfo.cs 文件，为了在每次编译时都自动替换，我们把调用批处理的命令卸载项目生成事件的生成前事件中：</p>
<pre><code><span class="string">"(TargetDir)BeforeBuildProject.bat"</span><span class="comment">(ProjectDir)</span> $<span class="comment">(TargetDir)</span>
</code></pre><p> 批处理代码：</p>
<pre><code>::-------------------------------------------------
:: &lt;sunmary&gt;
:: 根据指定工作目录信息和模板生成目标文件
:: &lt;/sunmary&gt;
:: &lt;param name="WorkDir"&gt;工作目录路径&lt;/param&gt;
:: &lt;param name="Template"&gt;模板文件路径&lt;/param&gt;
:: &lt;param name="target"&gt;生成目标文件的路径&lt;/param&gt;
:: &lt;returns&gt;执行结果&lt;/returns&gt;
::=================================================

::-------------------------------------------------
:: * Initialize *
@<span class="keyword">ECHO</span> OFF
::<span class="keyword">SetLocal</span> EnableExtensions
<span class="keyword">setlocal</span> enabledelayedexpansion

<span class="comment">Rem Initialize Script arguments</span>
<span class="keyword">SET</span> WorkDir=%<span class="number">1</span>
<span class="keyword">SET</span> target=%<span class="number">2</span>

<span class="comment">Rem Initialize Constants</span>
<span class="keyword">SET</span> AssemblyInfo=ASSEMBLY_INFO.tmp

<span class="comment">Rem GoTo Main Entry</span>
<span class="flow">GOTO</span> Main
::=================================================

::-------------------------------------------------
:: * Main Entry *
:Main
<span class="comment">Rem Check arguments</span>
<span class="flow">IF</span> <span class="envvar">%WorkDir%</span>=="" <span class="flow">GOTO</span> ARGUNENT_ERROR
<span class="flow">IF</span> <span class="envvar">%target%</span>=="" <span class="flow">GOTO</span> ARGUNENT_ERROR
<span class="built_in">PushD</span> <span class="envvar">%WorkDir%</span>

<span class="comment">Rem Search TSVN Path</span>

<span class="flow">For</span> /f "tokens=<span class="number">1</span>* delims=_" <span class="envvar">%%1</span> <span class="flow">in</span> ('reg query "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\Git_is1" /v "InstallLocation"^| <span class="built_in">findstr</span> /i "InstallLocation"') <span class="flow">Do</span> (
  <span class="flow">For</span> /f "tokens=<span class="number">1</span>*" <span class="envvar">%%3</span>  <span class="flow">in</span> ("<span class="envvar">%%~</span><span class="number">2</span>") <span class="flow">Do</span> (
<span class="keyword">SET</span> GIT_PATH=<span class="envvar">%%4</span>
  )
)

<span class="keyword">COPY</span> /y "<span class="envvar">%target%</span>git_ver" "<span class="envvar">%WorkDir%</span>git_ver"

<span class="keyword">SET</span> GIT_PATH="<span class="envvar">%GIT_PATH%</span>bin\sh.exe" --login -i
<span class="flow">call</span> <span class="envvar">%GIT_PATH%</span> <span class="envvar">%WorkDir%</span>git_ver

<span class="flow">for</span> /f "delims=" <span class="envvar">%%i</span> <span class="flow">in</span> (<span class="envvar">%WorkDir%</span>\git_version.tmp) <span class="flow">do</span> (<span class="keyword">set</span> VERSION=<span class="envvar">%%i</span>)&amp;(<span class="flow">goto</span> :next)
:next
<span class="winutils">DEL</span> /Q "<span class="envvar">%WorkDir%</span>\git_ver"&gt;<span class="stream">NUL</span>
<span class="winutils">DEL</span> /Q "<span class="envvar">%WorkDir%</span>\git_version.tmp"&gt;<span class="stream">NUL</span>

<span class="comment">Rem Generate a template file</span>

<span class="keyword">COPY</span> /y "<span class="envvar">%WorkDir%</span>\Properties\AssemblyInfo.cs" "<span class="envvar">%WorkDir%</span>\Properties\AssemblyInfo.cs.bak"&gt;<span class="stream">NUL</span>
<span class="keyword">SET</span> FILESTR="<span class="envvar">%WorkDir%</span>\Properties\AssemblyInfo.cs"
<span class="built_in">FindStr</span> /v "AssemblyVersion AssemblyFileVersion" <span class="envvar">%FILESTR%</span>&gt;<span class="envvar">%AssemblyInfo%</span>

<span class="flow">For</span> /f "delims=" <span class="envvar">%%k</span> <span class="flow">In</span> (<span class="envvar">%target%</span>\AssemblyInfo.tpl) <span class="flow">do</span> (
  <span class="keyword">set</span> str=<span class="envvar">%%k</span>
  <span class="keyword">set</span> str=<span class="envvar">!str:GITVERSION=%VERSION%!</span>
  <span class="keyword">echo</span> <span class="envvar">!str!</span> &gt;&gt; "<span class="envvar">%AssemblyInfo%</span>"
)

<span class="keyword">COPY</span> /y "<span class="envvar">%AssemblyInfo%</span>" "<span class="envvar">%WorkDir%</span>\Properties\AssemblyInfo.cs"
<span class="flow">GOTO</span> SUCCESS
::=================================================

::-------------------------------------------------
:: * Error Handlers *
:ARGUNENT_ERROR
<span class="keyword">ECHO</span> 传入的参数无效。
<span class="flow">GOTO</span> FAIL

:UNKNOE_ERROR
<span class="keyword">ECHO</span> 未知错误。
<span class="flow">GOTO</span> FAIL
::=================================================

::-------------------------------------------------
:: * Program <span class="flow">Exit</span> *
:FAIL
<span class="winutils">DEL</span> /Q "<span class="envvar">%AssemblyInfo%</span>"&gt;<span class="stream">NUL</span>
::<span class="flow">IF</span> <span class="flow">EXIST</span> "<span class="envvar">%WorkDir%</span>Properties\AssemblyInfo.cs.bak" (<span class="keyword">COPY</span> /y "<span class="envvar">%WorkDir%</span>Properties\AssemblyInfo.cs.bak" "<span class="envvar">%WorkDir%</span>Properties\AssemblyInfo.cs"&amp;<span class="winutils">DEL</span> /q "<span class="envvar">%WorkDir%</span>Properties\AssemblyInfo.cs.bak")&gt;<span class="stream">NUL</span>
<span class="keyword">ECHO</span> "error"
<span class="built_in">popd</span>
<span class="flow">EXIT</span> <span class="number">1</span>

:SUCCESS
<span class="winutils">DEL</span> /Q "<span class="envvar">%AssemblyInfo%</span>"&gt;<span class="stream">NUL</span>
<span class="keyword">ECHO</span> "success"
<span class="built_in">popd</span>
<span class="flow">EXIT</span> <span class="number">0</span>
::=================================================
</code></pre><p> 惯例附上所有代码：<a href="http://pan.baidu.com/s/1osg9C" title="GIT生成版本号.rar" target="_blank" rel="external">点击下载</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p> 上一篇博客写了如何在 .Net 项目使用 SVN 作为版本控制工具时生成与代码对应的组件版本号。虽然在公司一直使用 SVN ，但我却对 GIT 情有独钟，但少有文章提及如何具体在 Windows 平台来获得版本号。这让我有了迫切得到方法的希望。下面会具体实现如何在VS中使用Git版本号作为编译产生的文件版本号。</p>]]>
    
    </summary>
    
      <category term="VS" scheme="http://www.tnidea.com/tags/VS/"/>
    
      <category term="git" scheme="http://www.tnidea.com/tags/git/"/>
    
      <category term="批处理" scheme="http://www.tnidea.com/tags/%E6%89%B9%E5%A4%84%E7%90%86/"/>
    
      <category term="文件版本号" scheme="http://www.tnidea.com/tags/%E6%96%87%E4%BB%B6%E7%89%88%E6%9C%AC%E5%8F%B7/"/>
    
      <category term="项目管理" scheme="http://www.tnidea.com/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在VS项目中使用SVN版本号作为编译版本号]]></title>
    <link href="http://www.tnidea.com/svn-project-version.html"/>
    <id>http://www.tnidea.com/svn-project-version.html</id>
    <published>2013-10-26T16:00:00.000Z</published>
    <updated>2015-09-23T14:40:35.000Z</updated>
    <content type="html"><![CDATA[<p> 在生产项目中，版本号是必不可少的一部分。版本号的规则也有许多种，在此不讨论具体的编码规范。对于迭代的产品，版本繁多，特别是有多个实施项目所使用产品的版本不同（基于定制需求）时，清楚的标识组件与代码的对应关系十分重要。 本文主要说明如何在 .Net 项目使用 SVN 作为版本控制工具时生成与代码对应的组件版本号。</p>
<a id="more"></a>
<p> 我们知道，SVN 在 commit 时会生成一串数字作为序号，所以基本思路是把这个序号作为 .Net 项目编译后生成dll的文件版本号的最后一段。下面所列方法需要使用到TortoiseSVN 提供的 SubWCRev.exe 。</p>
<p> 首先，我们需要通过注册表查找 TortoiseSVN 的安装目录。</p>
<pre><code><span class="comment">Rem Search TSVN Path</span>
<span class="flow">For</span> /f "tokens=*" <span class="envvar">%%i</span> <span class="flow">In</span> ('Reg Query HKLM\Software\TortoiseSVN /v Directory') <span class="flow">Do</span> (
   <span class="keyword">ECHO</span> <span class="envvar">%%i</span> | <span class="built_in">Find</span> "Directory"&gt;<span class="stream">NUL</span>
   <span class="flow">IF</span> <span class="envvar">%ERRORLEVEL%</span> == <span class="number">0</span> (<span class="flow">For</span> /f "tokens=<span class="number">1</span>,<span class="number">2</span>,*" <span class="envvar">%%j</span> <span class="flow">In</span> ("<span class="envvar">%%i</span>") <span class="flow">Do</span> (<span class="keyword">SET</span> TSVN_PATH=<span class="envvar">%%1</span>))
)
<span class="keyword">SET</span> TSVN_PATH=<span class="envvar">%TSVN_PATH%</span>bin\SubWCRev.exe
</code></pre><p> SubWCRev 是通过替换文件中指定的关键字来实现获得 commit 序号的，点击查看详细的列表。 </p>
<p> 然后我们建立以一个 AssemblyInfo.tpl 作为替换使用的模板，由于 AssemblyInfo.cs 中除了固定的值外还有类似 GUID 变化的值，所以我们不能全部替换，因此仅将需要修改的部分放在 tpl 中，内容如下：</p>
<pre><code>[assembly: <span class="function"><span class="title">AssemblyVersion</span><span class="params">(<span class="string">"1.0.0.0"</span>)</span></span>]
[assembly: <span class="function"><span class="title">AssemblyFileVersion</span><span class="params">(<span class="string">"1.0.0.$WCREV$"</span>)</span></span>]
</code></pre><p> 接下来使用批处理替换原来的 AssemblyInfo.cs 文件，为了在每次编译时都自动替换，我们把调用批处理的命令写在项目生成事件的生成前事件中，例如下面这样：</p>
<pre><code><span class="string">"(TargetDir)BeforeBuildProject.bat"</span><span class="string">"(ProjectDir)"</span> <span class="string">"<span class="variable">$(TargetDir)</span>AssemblyInfo.tpl"</span> .\Properties\AssemblyInfo.cs
</code></pre><p> <code>$(TargetDir)</code>表示编译输出目录，更多可用全局变量请在生成事件中点击“宏”查看。</p>
<p> 替换 AssemblyInfo.cs 的批处理代码：</p>
<pre><code><span class="keyword">SET</span> WorkDir=%<span class="number">1</span>
<span class="keyword">SET</span> Template=%<span class="number">2</span>
<span class="keyword">SET</span> target=%<span class="number">3</span>
<span class="keyword">SET</span> AssemblyInfo=ASSEMBLY_INFO.tmp

<span class="built_in">PushD</span> <span class="envvar">%WorkDir%</span>
<span class="keyword">SET</span> WorkDir=.\

<span class="comment">Rem Generate a template file</span>
<span class="built_in">FindStr</span> /v "AssemblyVersion AssemblyFileVersion" <span class="envvar">%target%</span> &gt; <span class="envvar">%AssemblyInfo%</span>
<span class="built_in">FindStr</span> ".*" <span class="envvar">%Template%</span> &gt;&gt; <span class="envvar">%AssemblyInfo%</span>

<span class="comment">Rem Using TSVN Replace Tlp</span>
"<span class="envvar">%TSVN_PATH%</span>" <span class="envvar">%WorkDir%</span> <span class="envvar">%AssemblyInfo%</span> <span class="envvar">%target%</span>&gt;<span class="stream">NUL</span>
</code></pre><p> 当然这样还不是一劳永逸，你会发现每次编译 AssemblyInfo.cs 文件都会变化，因此你的 commit 序号也会一直跟着增加，这并不是我们所想要的效果。这里提出一种解决方案，在每次替换后生成 dll 后又将 AssemblyInfo.cs 还原回去。</p>
<p> 为此，我们在生成前事件中增加备份命令：</p>
<pre><code><span class="built_in">COPY</span> <span class="bash">/y <span class="string">"%target%"</span> <span class="string">"%target%.bak"</span>&gt;NUL</span>
</code></pre><p> 然后增加生成后事件，调用命令为：</p>
<pre><code><span class="string">"(TargetDir)AfterBuildProject.bat<span class="dquote">""</span>(ProjectDir)Properties\AssemblyInfo.cs"</span>
</code></pre><p> 在 AfterBuildProject.bat 中我们需要完成还原  AssemblyInfo.cs 和删除备份文件的工作，代码如下：</p>
<pre><code><span class="keyword">SET</span> target=%<span class="number">1</span>
<span class="keyword">COPY</span> "<span class="envvar">%target%</span>.bak" <span class="envvar">%target%</span>
<span class="winutils">DEL</span> /Q "<span class="envvar">%target%</span>.bak" <span class="number">2</span>&gt;<span class="stream">NUL</span>
</code></pre><p> 就此，每次编译时，系统都会自动将 commit 序号放到 dll 的文件版本中了。</p>
<p> 完整代码下载：<a href="http://pan.baidu.com/s/1pD5TJ" title="SVN生成版本号.rar" target="_blank" rel="external">点击下载</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p> 在生产项目中，版本号是必不可少的一部分。版本号的规则也有许多种，在此不讨论具体的编码规范。对于迭代的产品，版本繁多，特别是有多个实施项目所使用产品的版本不同（基于定制需求）时，清楚的标识组件与代码的对应关系十分重要。 本文主要说明如何在 .Net 项目使用 SVN 作为版本控制工具时生成与代码对应的组件版本号。</p>]]>
    
    </summary>
    
      <category term="SVN" scheme="http://www.tnidea.com/tags/SVN/"/>
    
      <category term="VS" scheme="http://www.tnidea.com/tags/VS/"/>
    
      <category term="批处理" scheme="http://www.tnidea.com/tags/%E6%89%B9%E5%A4%84%E7%90%86/"/>
    
      <category term="文件版本号" scheme="http://www.tnidea.com/tags/%E6%96%87%E4%BB%B6%E7%89%88%E6%9C%AC%E5%8F%B7/"/>
    
      <category term="项目管理" scheme="http://www.tnidea.com/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
      <category term="项目管理" scheme="http://www.tnidea.com/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
</feed>
