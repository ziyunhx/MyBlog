<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[地平线]]></title>
  <subtitle><![CDATA[纯粹的技术导向！]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="https://www.tnidea.com/"/>
  <updated>2016-07-27T16:36:14.000Z</updated>
  <id>https://www.tnidea.com/</id>
  
  <author>
    <name><![CDATA[Carey Tzou]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[保护好你的Elasticsearch全文检索库]]></title>
    <link href="https://www.tnidea.com/protect-your-elasticsearch.html"/>
    <id>https://www.tnidea.com/protect-your-elasticsearch.html</id>
    <published>2016-07-26T16:00:00.000Z</published>
    <updated>2016-07-27T16:36:14.000Z</updated>
    <content type="html"><![CDATA[<p> Elasticsearch是一款基于Lucence的全文检索数据库，在文本分析、搜索等领域被广泛使用，但是默认的配置通过限制仅允许局域网访问来保证数据的安全性，如果你需要对公网提供服务，便需要额外安装插件来实现访问控制了。裸奔不仅可能带来被脱库，甚至数据会被删除而且不可恢复。本文将介绍如何选择和配置插件来保障Elasticsearch的安全。</p>
<a id="more"></a>
<p> 本文介绍的环境均在 Centos 7 下，其它系统同理，只需要修改部分命令。</p>
<h2 id="1-_安装_Elasticsearch，开启外网访问权限">1. 安装 Elasticsearch，开启外网访问权限</h2><ul>
<li><p>安装JDK 7+，并配置 JAVA_HOME <a href="http://docs.oracle.com/javase/8/docs/technotes/guides/install/install_overview.html" target="_blank" rel="external">Oracle 官网</a>;</p>
</li>
<li><p>根据官网提供的方法安装 Elasticsearch：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/setup-repositories.html" target="_blank" rel="external">使用yum安装</a>;</p>
</li>
<li><p>配置 /etc/elasticsearch/elasticsearch.yml 文件，此处修改 network.host 来允许外网访问：</p>
<pre><code>network.host:<span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>
</code></pre></li>
<li><p>为了防止他人的端口扫描，修改掉默认端口吧，例如设置成：</p>
<pre><code><span class="title">http</span>.<span class="foreign"><span class="keyword">port</span>: 9999</span>
</code></pre></li>
<li><p>安装管理插件，例如 head ，重启 Elasticsearch。</p>
<h2 id="2-_安装与配置_SearchGuard_2">2. 安装与配置 SearchGuard 2</h2></li>
<li><p>安装 Elasticsearch 对应版本的 search-guard-ssl 和 search-guard-2 插件：</p>
<pre><code>cd /usr/share/elasticsearch
sudo bin/plugin <span class="operator"><span class="keyword">install</span> -b com.floragunn/<span class="keyword">search</span>-<span class="keyword">guard</span>-ssl/<span class="number">2.3</span><span class="number">.4</span><span class="number">.14</span>
sudo <span class="keyword">bin</span>/<span class="keyword">plugin</span> <span class="keyword">install</span> -b com.floragunn/<span class="keyword">search</span>-<span class="keyword">guard</span>-<span class="number">2</span>/<span class="number">2.3</span><span class="number">.4</span><span class="number">.3</span></span>
</code></pre></li>
<li><p>配置 search-guard-ssl，生成证书：</p>
<pre><code><span class="keyword">cd</span> ~
yum install wget unzip
wget http<span class="variable">s:</span>//github.<span class="keyword">com</span>/floragunncom/<span class="built_in">search</span>-guard-ssl/archive/<span class="number">2.3</span>.<span class="number">4</span>.zip
unzip <span class="number">2.3</span>.<span class="number">4</span>.zip
<span class="keyword">cd</span> <span class="built_in">search</span>-guard-ssl-<span class="number">2.3</span>.<span class="number">4</span>/example-pki-scripts/
./example.<span class="keyword">sh</span>
</code></pre></li>
<li><p>复制相应证书到配置文件目录，在集群中时修改 node-0-keystore.jks 中的数字保证与配置文件中相同：</p>
<pre><code>cp node-<span class="number">0</span>-keystore<span class="class">.jks</span> /etc/elasticsearch/
cp truststore<span class="class">.jks</span> /etc/elasticsearch/
</code></pre></li>
<li><p>将目录中的 elasticsearch.yml.example 的内容复制到 /etc/elasticsearch/elasticsearch.yml</p>
</li>
<li><p>在 /etc/elasticsearch/elasticsearch.yml 中增加以下内容：</p>
<pre><code>searchguard<span class="class">.ssl</span><span class="class">.transport</span><span class="class">.keystore_filepath</span>: node-<span class="number">0</span>-keystore<span class="class">.jks</span>
#注意 node-<span class="number">0</span>-keystore<span class="class">.jks</span> 与拷入目录的证书名称相同
searchguard<span class="class">.ssl</span><span class="class">.transport</span><span class="class">.keystore_password</span>: changeit
searchguard<span class="class">.ssl</span><span class="class">.transport</span><span class="class">.truststore_filepath</span>: truststore<span class="class">.jks</span>
searchguard<span class="class">.ssl</span><span class="class">.transport</span><span class="class">.truststore_password</span>: changeit
searchguard<span class="class">.ssl</span><span class="class">.transport</span><span class="class">.enforce_hostname_verification</span>: false
</code></pre><h2 id="3-_修改账户密码以及角色权限">3. 修改账户密码以及角色权限</h2></li>
<li><p>使用自带的 hash 脚本生成密码（mycleartextpassword 替换为你需要设置的密码）：</p>
<pre><code>sh /usr/share/elasticsearch/plugins/search-guard-<span class="number">2</span>/tools/hash<span class="class">.sh</span> -<span class="tag">p</span> mycleartextpassword
</code></pre></li>
<li><p>将生成的密码复制到 /usr/share/elasticsearch/plugins/search-guard-2/sgconfig/sg_internal_users.yml 中你需要的用户名的 password 后，并注释其它用户；</p>
</li>
<li><p>在相同目录的 sg_roles.yml 中自定义你的用户角色权限；</p>
</li>
<li><p>在 sg_roles_mapping.yml 中指定用户与角色间的对应关系。</p>
<h2 id="4-_更新应用配置_SearchGuard_2_文件">4. 更新应用配置 SearchGuard 2 文件</h2></li>
<li><p>拷贝证书到 SearchGuard 2 插件的配置文件目录：</p>
<pre><code>cd <span class="regexp">~/search-guard-ssl-2.3.4/</span>example-pki-scripts/
cp truststore.jks <span class="regexp">/usr/</span>share<span class="regexp">/elasticsearch/</span>plugins<span class="regexp">/search-guard-2/</span>sgconfig/
cp kirk-keystore.jks <span class="regexp">/usr/</span>share<span class="regexp">/elasticsearch/</span>plugins<span class="regexp">/search-guard-2/</span>sgconfig/
</code></pre></li>
<li><p>重启 Elasticsearch 服务</p>
</li>
<li><p>使用命令应用配置（即时不修改配置文件也需要执行）：</p>
<pre><code><span class="keyword">sh</span> plugins/<span class="built_in">search</span>-guard-<span class="number">2</span>/tools/sgadmin.<span class="keyword">sh</span> -<span class="keyword">cd</span> plugins/<span class="built_in">search</span>-guard-<span class="number">2</span>/sgconfig/ -ks plugins/<span class="built_in">search</span>-guard-<span class="number">2</span>/sgconfig/kirk-keystore.jks -<span class="keyword">ts</span> plugins/<span class="built_in">search</span>-guard-<span class="number">2</span>/sgconfig/truststore.jks -nhnv -<span class="keyword">cn</span> elasticsearch 
# -<span class="keyword">cn</span> 后为集群名称（默认为elasticsearch），如果你修改过 cluster.name，则将它替换成你修改的名称
</code></pre></li>
<li><p>再次连接 Elasticsearch 服务，输入你设置的密码即可正常访问。</p>
<h2 id="5-_给你的_Elasticsearch_服务创建快照备份">5. 给你的 Elasticsearch 服务创建快照备份</h2><p>Elasticsearch 的数据安全不仅来自外部，内部成员的误操作同样可能带来不可挽回的损失；尽量将账户设置为最小所需权限是一个好方法，但是仍然不可避免存在超级用户，加上 head 插件缺失的确认机制，一不小心就回到解放前了！因此定时备份数据十分重要。</p>
</li>
<li><p>设置共享目录，并挂载到集群上的所有机器，并赋予 Elasticsearch 用户写权限；</p>
</li>
<li><p>在 elasticsearch.yml 中增加共享目录的配置，并重启 ES 服务：</p>
<pre><code>path<span class="class">.repo</span>: [<span class="string">"/mount/backups"</span>]
</code></pre></li>
<li><p>使用 curl 创建备份仓库：</p>
<pre><code>$ curl -XPUT <span class="string">'http</span>:<span class="comment">//localhost:9200/_snapshot/my_backup' -d '{</span>
    <span class="string">"type"</span>: <span class="string">"fs"</span>,
    <span class="string">"settings"</span>: {
        <span class="string">"location"</span>: <span class="string">"my_backup"</span>,
        <span class="string">"compress"</span>: <span class="keyword">true</span>
    }
}'
</code></pre></li>
<li><p>对指定的 index 创建快照备份（注意索引间不要有空格）：</p>
<pre><code>$ curl -XPUT <span class="string">'http</span>:<span class="comment">//localhost:9200/_snapshot/my_backup/snapshot_1' -d '{</span>
    <span class="string">"indices"</span>: <span class="string">"index_1,index_2"</span>
}'
</code></pre></li>
<li><p>查询备份状态</p>
<pre><code>GET <span class="string">http:</span><span class="comment">//localhost:9200/_snapshot/my_backup/snapshot_1/_status</span>
</code></pre></li>
<li><p>把最后两部设置成定时任务吧，这样你就可以定期备份了；而且由于快照机制是增量备份，所以也不用担心空间了！</p>
<p>好了，有关 Elasticsearch 的设置就到这里了。安全无小事，本文也仅是简单介绍了下方法和思路，许多细节都需要自己慢慢琢磨哦！</p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p> Elasticsearch是一款基于Lucence的全文检索数据库，在文本分析、搜索等领域被广泛使用，但是默认的配置通过限制仅允许局域网访问来保证数据的安全性，如果你需要对公网提供服务，便需要额外安装插件来实现访问控制了。裸奔不仅可能带来被脱库，甚至数据会被删除而且不可恢复。本文将介绍如何选择和配置插件来保障Elasticsearch的安全。</p>]]>
    
    </summary>
    
      <category term="Elasticsearch" scheme="https://www.tnidea.com/tags/Elasticsearch/"/>
    
      <category term="SearchGuard" scheme="https://www.tnidea.com/tags/SearchGuard/"/>
    
      <category term="Snapshot" scheme="https://www.tnidea.com/tags/Snapshot/"/>
    
      <category term="运维" scheme="https://www.tnidea.com/categories/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[.NET Core 现已支持DRPC，同时带来Apache Thrift]]></title>
    <link href="https://www.tnidea.com/dotnet-core-support-drpc-now.html"/>
    <id>https://www.tnidea.com/dotnet-core-support-drpc-now.html</id>
    <published>2016-07-24T16:00:00.000Z</published>
    <updated>2016-07-27T15:41:50.000Z</updated>
    <content type="html"><![CDATA[<p> 上篇文章为大家带来了新版本的 Storm 适配器，今天来弥补一下上次匆忙发布带来的遗憾。是的，DRPC for .net Core 来了，当然，为了实现这个功能，一个精简版本的 Apache Thrift for .net core 也产生了；这个类库根据 <a href="https://thrift.apache.org/docs/HowToNewLanguage" target="_blank" rel="external">Roadmap for adding new language bindings</a> 完成，为了不带来误解，该项目暂时不开源，仅在 Nugut 中供 <a href="https://github.com/ziyunhx/storm-net-adapter" target="_blank" rel="external">storm-net-adapter</a> 使用，如果你也暂时需要它，可以通过 Nuget 搜索 Tnidea.Thrift 获得。</p>
<a id="more"></a>
<p> <a href="https://github.com/ziyunhx/storm-net-adapter" target="_blank" rel="external">storm-net-adapter</a> 最新版本为 2.0.5，现在支持 .Net4.0+, .Net Core。下面给大家介绍如何快速开始创建一个 DRPC Topology：</p>
<h2 id="1-_创建-Net_DRPC_Topology项目">1. 创建.Net DRPC Topology项目</h2><ul>
<li>使用命令创建新的 .Net Core 项目：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir StormSample&#10;cd StormSample&#10;dotnet new</span><br></pre></td></tr></table></figure>
<ul>
<li>在项目中添加 Storm.Net.Adapter 引用：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#34;dependencies&#34;: &#123;&#10;    &#34;Storm.Net.Adapter&#34;: &#34;2.0.5&#34;&#10;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>创建一个 SimpleDRPC 类：</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Storm;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">StormSample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SimpleDRPC</span> : <span class="title">IBolt</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> Context ctx;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span>  Implements of delegate "newPlugin", which is used to create a instance of this spout/bolt</span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="ctx"&gt;</span>Context instance<span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;returns&gt;</span><span class="xmlDocTag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SimpleDRPC <span class="title">Get</span>(<span class="params">Context ctx</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SimpleDRPC(ctx);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SimpleDRPC</span>(<span class="params">Context ctx</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            Context.Logger.Info(<span class="string">"SimpleDRPC constructor called"</span>);</span><br><span class="line">            <span class="keyword">this</span>.ctx = ctx;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Declare Input and Output schemas</span></span><br><span class="line">            Dictionary&lt;<span class="keyword">string</span>, List&lt;Type&gt;&gt; inputSchema = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, List&lt;Type&gt;&gt;();</span><br><span class="line">            inputSchema.Add(<span class="string">"default"</span>, <span class="keyword">new</span> List&lt;Type&gt;() &#123; <span class="keyword">typeof</span>(<span class="keyword">string</span>), <span class="keyword">typeof</span>(<span class="keyword">object</span>) &#125;);</span><br><span class="line">            Dictionary&lt;<span class="keyword">string</span>, List&lt;Type&gt;&gt; outputSchema = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, List&lt;Type&gt;&gt;();</span><br><span class="line">            outputSchema.Add(<span class="string">"default"</span>, <span class="keyword">new</span> List&lt;Type&gt;() &#123; <span class="keyword">typeof</span>(<span class="keyword">string</span>), <span class="keyword">typeof</span>(<span class="keyword">object</span>) &#125;);</span><br><span class="line">            <span class="keyword">this</span>.ctx.DeclareComponentSchema(<span class="keyword">new</span> ComponentStreamSchema(inputSchema, outputSchema));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params">StormTuple tuple</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            Context.Logger.Info(<span class="string">"SimpleDRPC Execute enter"</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">string</span> sentence = tuple.GetString(<span class="number">0</span>) + <span class="string">"!"</span>;</span><br><span class="line">            <span class="keyword">this</span>.ctx.Emit(<span class="string">"default"</span>, <span class="keyword">new</span> List&lt;StormTuple&gt; &#123; tuple &#125;, <span class="keyword">new</span> List&lt;<span class="keyword">object</span>&gt; &#123; sentence, tuple.GetValue(<span class="number">1</span>) &#125;);</span><br><span class="line">            Context.Logger.Info(<span class="string">"SimpleDRPC Execute exit"</span>);</span><br><span class="line">            ApacheStorm.Ack(tuple);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Prepare</span>(<span class="params">Config stormConf, TopologyContext context</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-_使用Java封装Storm_Topology">2. 使用Java封装Storm Topology</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.storm.starter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.storm.Config;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.LocalCluster;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.LocalDRPC;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.StormSubmitter;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.drpc.DRPCSpout;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.drpc.LinearDRPCTopologyBuilder;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.drpc.ReturnResults;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.spout.ShellSpout;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.task.ShellBolt;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.topology.IRichBolt;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.topology.IRichSpout;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.topology.OutputFieldsDeclarer;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.topology.TopologyBuilder;</span><br><span class="line"><span class="keyword">import</span> org.apache.storm.tuple.Fields;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * This topology demonstrates Storm's stream groupings and multilang capabilities.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DrpcTestTopologyCsharp</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDRPC</span> <span class="keyword">extends</span> <span class="title">ShellBolt</span> <span class="keyword">implements</span> <span class="title">IRichBolt</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">SimpleDRPC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">super</span>(<span class="string">"dotnet"</span>, <span class="string">"StormSample.dll"</span>, <span class="string">"SimpleDRPC"</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="annotation">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer declarer)</span> </span>&#123;</span><br><span class="line">			declarer.declare(<span class="keyword">new</span> Fields(<span class="string">"id"</span>, <span class="string">"result"</span>));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="annotation">@Override</span></span><br><span class="line">		<span class="keyword">public</span> Map&lt;String, Object&gt; getComponentConfiguration() &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	  	TopologyBuilder builder = <span class="keyword">new</span> TopologyBuilder();</span><br><span class="line">		  </span><br><span class="line">	  	DRPCSpout drpcSpout = <span class="keyword">new</span> DRPCSpout(<span class="string">"simpledrpc"</span>);</span><br><span class="line">	    builder.setSpout(<span class="string">"drpc-input"</span>, drpcSpout,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	    builder.setBolt(<span class="string">"simple"</span>, <span class="keyword">new</span> SimpleDRPC(), <span class="number">2</span>)</span><br><span class="line">	    		.noneGrouping(<span class="string">"drpc-input"</span>);</span><br><span class="line">	    </span><br><span class="line">	    builder.setBolt(<span class="string">"return"</span>, <span class="keyword">new</span> ReturnResults(),<span class="number">1</span>)</span><br><span class="line">		.noneGrouping(<span class="string">"simple"</span>);</span><br><span class="line"></span><br><span class="line">	    Config conf = <span class="keyword">new</span> Config();</span><br><span class="line">	    conf.setDebug(<span class="keyword">true</span>);</span><br><span class="line">	    conf.setMaxTaskParallelism(<span class="number">1</span>);</span><br><span class="line">	    </span><br><span class="line">	    <span class="keyword">try</span></span><br><span class="line">	    &#123;</span><br><span class="line">	    	StormSubmitter.submitTopology(<span class="string">"drpc-q"</span>, conf,builder.createTopology());</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">catch</span> (Exception e)</span><br><span class="line">	    &#123;</span><br><span class="line">	    	e.printStackTrace();</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>注意调用代码中的 StormSimple.dll：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">super(&#34;dotnet&#34;, &#34;StormSimple.dll&#34;, &#34;SimpleDRPC&#34;);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>打包 StormSample ，并将依赖项一起拷贝到 multilang/resources 。</p>
</li>
<li><p>使用 Maven 打包 Java 项目，通过 storm jar 命令提交：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ storm jar storm-starter-1.0.1.jar org.apache.storm.starter.DrpcTestTopologyCsharp simpledrpc</span><br></pre></td></tr></table></figure>
<h2 id="3-_使用C#调用刚刚提交的DRPC_Topology">3. 使用C#调用刚刚提交的DRPC Topology</h2><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> Storm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Storm.DRPC.Demo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            DRPCClient client = <span class="keyword">new</span> DRPCClient(<span class="string">"host"</span>, <span class="number">3772</span>);</span><br><span class="line">            <span class="keyword">string</span> result = client.execute(<span class="string">"simpledrpc"</span>, <span class="string">"hello word"</span>);</span><br><span class="line">            Console.WriteLine(result);</span><br><span class="line">            Console.WriteLine(<span class="string">"Please input a word and press enter, if you want quit it, press enter only!"</span>);</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">string</span> input = Console.ReadLine();</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">string</span>.IsNullOrEmpty(input))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                Console.WriteLine(client.execute(<span class="string">"simpledrpc"</span>, input));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 至此就全部结束了！所有的代码都在 <a href="https://github.com/ziyunhx/storm-net-adapter" target="_blank" rel="external">storm-net-adapter</a> 可以找到，你可以通过 Star 与 Fork 该项目来支持我！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p> 上篇文章为大家带来了新版本的 Storm 适配器，今天来弥补一下上次匆忙发布带来的遗憾。是的，DRPC for .net Core 来了，当然，为了实现这个功能，一个精简版本的 Apache Thrift for .net core 也产生了；这个类库根据 <a href="https://thrift.apache.org/docs/HowToNewLanguage">Roadmap for adding new language bindings</a> 完成，为了不带来误解，该项目暂时不开源，仅在 Nugut 中供 <a href="https://github.com/ziyunhx/storm-net-adapter">storm-net-adapter</a> 使用，如果你也暂时需要它，可以通过 Nuget 搜索 Tnidea.Thrift 获得。</p>]]>
    
    </summary>
    
      <category term=".NET Core" scheme="https://www.tnidea.com/tags/NET-Core/"/>
    
      <category term="csharp" scheme="https://www.tnidea.com/tags/csharp/"/>
    
      <category term="dotnet" scheme="https://www.tnidea.com/tags/dotnet/"/>
    
      <category term="storm" scheme="https://www.tnidea.com/tags/storm/"/>
    
      <category term="Storm" scheme="https://www.tnidea.com/categories/Storm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[.NET Core 也能玩转 Storm]]></title>
    <link href="https://www.tnidea.com/using-storm-at-dotnet-core.html"/>
    <id>https://www.tnidea.com/using-storm-at-dotnet-core.html</id>
    <published>2016-07-10T16:00:00.000Z</published>
    <updated>2016-07-25T14:31:39.000Z</updated>
    <content type="html"><![CDATA[<p> .Net Core 自发布以来广受关注，基于其开源与跨平台的特性，可以预见其在 web 开发领域越来越受青睐。现在，Apache Storm 的 .Net Core 版本的适配器正式发布，你现在也可以使用 .Net Core 开发 Topology，实现分布式跨平台的实时计算。</p>
<a id="more"></a>
<p> <a href="https://github.com/ziyunhx/storm-net-adapter" target="_blank" rel="external">storm-net-adapter</a> 现在已经更新到 2.0.4，增加了对 .Net Core 的支持，并对之前存在的例如输出复杂日志时的 BUG 进行了修复；由于目前 Thrift 的适配暂时还未完成，因此还无法使用 DRPC 的特性。同时，Storm 集群的 Docker 的镜像编排也已经集成了 .Net Core ，你可以通过 <a href="https://github.com/ziyunhx/storm-mono-docker" target="_blank" rel="external">storm-mono-docker</a> 获取到它。</p>
<p> .Net Core 玩转 Storm 的首要条件当然是安装 .Net Core 的开发环境啦，你可以通过以下地址查看如何安装：<a href="https://www.microsoft.com/net/core" target="_blank" rel="external">.Net Core</a> 。</p>
<p> 然后使用命令创建新的 .Net Core 项目：</p>
<pre><code><span class="built_in">mkdir</span> StormSample
<span class="keyword">cd</span> StormSample
dotnet <span class="keyword">new</span>
</code></pre><p> 在项目中添加 Storm.Net.Adapter 引用：</p>
<pre><code><span class="string">"dependencies"</span>: {
    <span class="string">"Storm.Net.Adapter"</span>: <span class="string">"2.0.1"</span>
}
</code></pre><p> 接下来增加业务代码，继承 ISpout 和 IBolt，实现接口方法，在 Main 方法里实现调用方法，具体代码可以参照 <a href="https://github.com/ziyunhx/storm-net-adapter/tree/master/src/Samples/StormSample" target="_blank" rel="external">StormSample</a> 。</p>
<p> 在 Java 端增加调用 .Net 代码的 Topology；</p>
<p> 如果需要运行在 Windows(.Net Framework) 平台下通过如下代码调用：</p>
<pre><code><span class="keyword">super</span>(<span class="string">"cmd"</span>, <span class="string">"/k"</span>, <span class="string">"CALL"</span>, <span class="string">"StormSimple.exe"</span>, <span class="string">"generator"</span>);
</code></pre><p> 在 Linux, Mac OSX, Windows(mono) 下通过如下代码调用：</p>
<pre><code><span class="keyword">super</span>(<span class="string">"mono"</span>, <span class="string">"StormSimple.exe"</span>, <span class="string">"generator"</span>);
</code></pre><p> 在 Linux, Mac OSX, Windows(.net core) 下通过如下代码调用：</p>
<pre><code><span class="keyword">super</span>(<span class="string">"dotnet"</span>, <span class="string">"StormSimple.dll"</span>, <span class="string">"generator"</span>);
</code></pre><p> 使用 Maven 打包 Java 项目，通过 storm jar 命令提交：</p>
<pre><code>$ storm jar storm-starter-*<span class="class">.jar</span> org<span class="class">.apache</span><span class="class">.storm</span><span class="class">.starter</span><span class="class">.WordCountTopologyCsharp</span> wordcount
</code></pre><p> 你就可以看到如下熟悉的界面咯：</p>
<p> <img src="http://www.tnidea.com/media/image/storm-ui-docker-101.png" alt="Storm UI"></p>
<p> 接下来需要完善与实现的任务还很多，项目的发展需要得到广泛的关注与支持；如果你觉得这个项目对您有帮助，欢迎在 GitHub 给出 Star ，项目地址：<a href="https://github.com/ziyunhx/storm-net-adapter" target="_blank" rel="external">storm-net-adapter</a> ，或者转发文章支持一下！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p> .Net Core 自发布以来广受关注，基于其开源与跨平台的特性，可以预见其在 web 开发领域越来越受青睐。现在，Apache Storm 的 .Net Core 版本的适配器正式发布，你现在也可以使用 .Net Core 开发 Topology，实现分布式跨平台的实时计算。</p>]]>
    
    </summary>
    
      <category term=".NET Core" scheme="https://www.tnidea.com/tags/NET-Core/"/>
    
      <category term="csharp" scheme="https://www.tnidea.com/tags/csharp/"/>
    
      <category term="dotnet" scheme="https://www.tnidea.com/tags/dotnet/"/>
    
      <category term="storm" scheme="https://www.tnidea.com/tags/storm/"/>
    
      <category term="Storm" scheme="https://www.tnidea.com/categories/Storm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Storm 1.0.1发布，.NET 适配也已到来]]></title>
    <link href="https://www.tnidea.com/dot-net-storm-adapter-upgrade-to-support-1.0.1.html"/>
    <id>https://www.tnidea.com/dot-net-storm-adapter-upgrade-to-support-1.0.1.html</id>
    <published>2016-05-11T16:00:00.000Z</published>
    <updated>2016-05-12T15:39:07.000Z</updated>
    <content type="html"><![CDATA[<p> Apache Storm 1.0.0刚发布不久，1.0.1版本也在几天前到来；该版本主要是完成一些BUG修复和小的改进，通过一段时间新版本的使用，特将个人感受和一些遇到的问题归纳如下；另外 .NET 版本的 Storm 适配器也已经发布，源码在 <a href="https://github.com/ziyunhx/storm-net-adapter" title="storm-net-adapter" target="_blank" rel="external">storm-net-adapter</a>，如果你希望便捷的体验Storm 1.0.1，可以通过 Docker 来部署，地址在：<a href="https://github.com/ziyunhx/storm-mono-docker" target="_blank" rel="external">storm-mono-docker</a>，该镜像已经集成了Mono，你也可以查看我之前的文章来详细了解。</p>
<a id="more"></a>
<p> 下图是使用 Docker 部署的 .NET 版的 Wordcount 的 Storm UI：</p>
<p> <img src="http://www.tnidea.com/media/image/storm-ui-docker-101.png" alt="Storm UI"></p>
<p> 通过图片我们可以看到，Topology 和 Supervisor 都增加了内存的占用字段，Nimbus 也支持多主机配置了，诟病多年的单 Nimbus 造成的稳定性隐患也终于得到解决。原有的配置项从 <code>nimbus.host</code> 换成了 <code>nimbus.seeds</code>，但实际测试如果你没有修改过来的话也只会出现警告，并不会崩溃。</p>
<p> 但是 Windows 版本的安装就会有些状况了，首先是 log4g2 的配置问题，原本逻辑的将 %STORM_HOME% 拼接在前面的逻辑并没有生效，你需要在 conf/storm.yaml 中配置日志配置文件的路径，类似：</p>
<pre><code>storm<span class="class">.log4j2</span><span class="class">.conf</span><span class="class">.dir</span>: <span class="string">"X:/Storm/apache-storm-last/log4j2"</span>
</code></pre><p> 然后你需要使用管理员权限运行命令，相关的资料你可以查看 <a href="https://github.com/apache/storm/blob/master/docs/windows-users-guide.md" title="windows-users-guide" target="_blank" rel="external">windows-users-guide</a>。</p>
<p> 另外 Storm 的安全机制也有了很大的提升，详细信息我会在后续专门翻译介绍，你也可以查看 <a href="http://storm.apache.org/releases/1.0.1/SECURITY.html" title="SECURITY" target="_blank" rel="external">SECURITY</a> 了解。storm jar 的远程提交在上面提供的 Docker 镜像中暂时还无法使用，可能和安全机制的提交也有关系。</p>
<p> 总体来说，Storm 的发展速度和方向都是符合我的个人预期的，新版本的文档目前还不够完善，建议大家先折腾一段时间踩踩坑再上生产环境。学习的话就直接从 1.0 版本开始吧。</p>
<p> 好了，本文就先介绍到这里。欢迎大家关注我的公众号，现在开始接受外部投稿，如果你有 STORM SPARK 等流式框架或者 Tensflow 等机器学习框架以及 NLP 自然语言处理相关的文章愿意在本公众号发布，欢迎在公众号和我留言！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p> Apache Storm 1.0.0刚发布不久，1.0.1版本也在几天前到来；该版本主要是完成一些BUG修复和小的改进，通过一段时间新版本的使用，特将个人感受和一些遇到的问题归纳如下；另外 .NET 版本的 Storm 适配器也已经发布，源码在 <a href="https://github.com/ziyunhx/storm-net-adapter" title="storm-net-adapter">storm-net-adapter</a>，如果你希望便捷的体验Storm 1.0.1，可以通过 Docker 来部署，地址在：<a href="https://github.com/ziyunhx/storm-mono-docker">storm-mono-docker</a>，该镜像已经集成了Mono，你也可以查看我之前的文章来详细了解。</p>]]>
    
    </summary>
    
      <category term=".NET" scheme="https://www.tnidea.com/tags/NET/"/>
    
      <category term="C#" scheme="https://www.tnidea.com/tags/C/"/>
    
      <category term="Topology" scheme="https://www.tnidea.com/tags/Topology/"/>
    
      <category term="csharp" scheme="https://www.tnidea.com/tags/csharp/"/>
    
      <category term="storm" scheme="https://www.tnidea.com/tags/storm/"/>
    
      <category term="Storm" scheme="https://www.tnidea.com/categories/Storm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[再谈网络爬虫中的编码识别问题]]></title>
    <link href="https://www.tnidea.com/talk-about-http-charset-recog-again.html"/>
    <id>https://www.tnidea.com/talk-about-http-charset-recog-again.html</id>
    <published>2016-04-18T16:00:00.000Z</published>
    <updated>2016-04-19T14:58:37.000Z</updated>
    <content type="html"><![CDATA[<p>在之前的文章中，我给大家介绍了 Nchardet 结合网页头部声明来识别网页的编码。通过较长时间段生产环境的使用，效果并不是十分理想。首先是 Nchardet 带来了极大的CPU的开销，尤其是对大规模的爬虫集群来说几乎无法接受；其次猜测的准确性距离100%还有一段距离。因此，就有了今天的这篇文章。</p>
<a id="more"></a>
<p>Nchardet 是通过尝试转换编码比较错误率来实现编码猜测的，由于网页的长度与中文密度的关系，效果并不理想。之前的方法中默认采用了这种方案，导致了较大的CPU资源的开销。下面将介绍新的解析思路：</p>
<p>首先我们通过解析 HTTP 请求返回的 ContentType 来猜测编码，.Net的网络请求库中的 HttpClient 就是使用了这一方法，实现代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span> Hcharset = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">string</span> text = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">string</span>.IsNullOrEmpty(text = httpWebResponse.ContentType))</span><br><span class="line">&#123;</span><br><span class="line">    text = text.ToLower(CultureInfo.InvariantCulture);</span><br><span class="line">    <span class="keyword">string</span>[] array = text.Split(<span class="keyword">new</span> <span class="keyword">char</span>[] &#123; <span class="string">';'</span>, <span class="string">'='</span>, <span class="string">' '</span> &#125;);</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">string</span>[] array2 = array;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array2.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">string</span> text2 = array2[i];</span><br><span class="line">        <span class="keyword">if</span> (text2 == <span class="string">"charset"</span>)</span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag)</span><br><span class="line">                Hcharset = text2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 httpWebResponse 为网络请求返回的结果。</p>
<p>然后我们使用正则来解析用户在网页中声明的编码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span> CharsetReg = <span class="string">@"(meta.*?charset=""?(?&lt;Charset&gt;[^\s""'&gt;;]+)""?)|(xml.*?encoding=""?(?&lt;Charset&gt;[^\s""&gt;;]+)""?)"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">string</span> Rcharset = <span class="string">""</span>;</span><br><span class="line">String cache = <span class="keyword">string</span>.Empty;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> b = ResponseStream.ReadByte();</span><br><span class="line">    <span class="keyword">if</span> (b &lt; <span class="number">0</span>) <span class="comment">//end of stream</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    bytes.Add((<span class="keyword">byte</span>)b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cache.EndsWith(<span class="string">"&lt;/head&gt;"</span>, StringComparison.OrdinalIgnoreCase))</span><br><span class="line">        cache += (<span class="keyword">char</span>)b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Match match = Regex.Match(cache, CharsetReg, RegexOptions.IgnoreCase | RegexOptions.Multiline);</span><br><span class="line"><span class="keyword">if</span> (match.Success)</span><br><span class="line">    Rcharset = match.Groups[<span class="string">"Charset"</span>].Value;</span><br></pre></td></tr></table></figure>
<p>由于两种方法取到的结果都有不准确的可能，因此当它们相同时我们就采用该种方式解析网页获得内容，避免使用 Nchardet 带来性能损耗。当两者不同时我们才使用 Nchardet 进行猜测，同样与之前的两种结果比较选择相同的方式解析。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="keyword">string</span>.IsNullOrEmpty(Rcharset) &amp;&amp; !<span class="keyword">string</span>.IsNullOrEmpty(Hcharset) &amp;&amp; Hcharset.ToUpper() == Rcharset.ToUpper())</span><br><span class="line">    encode = Encoding.GetEncoding(Hcharset);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    Ncharset = NChardetHelper.RecogCharset(bytes.ToArray(), Thrinax.Data.NChardetLanguage.CHINESE, <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">string</span>.IsNullOrEmpty(Ncharset) &amp;&amp; (Ncharset.ToUpper() == Rcharset.ToUpper() || Ncharset.ToUpper() == Hcharset.ToUpper()))</span><br><span class="line">        encode = Encoding.GetEncoding(Ncharset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果以上方法还是得不到相同的编码时，我们使用人工标注的编码（如果有的话）。接下来我们使用以下顺序来解析网页，直到获取到使用的编码：<br>人工标注的编码 &gt; 网页自动识别 &gt; 解析ContentType &gt; 解析Html编码声明 。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2，使用人工标注的编码</span></span><br><span class="line"><span class="keyword">if</span> (encode == <span class="keyword">null</span> &amp;&amp; !<span class="keyword">string</span>.IsNullOrEmpty(encoding))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        encode = Encoding.GetEncoding(encoding);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3，使用单一方式识别出的编码，网页自动识别 &gt; 解析ContentType &gt; 解析Html编码声明</span></span><br><span class="line"><span class="keyword">if</span> (encode == <span class="keyword">null</span> &amp;&amp; !<span class="keyword">string</span>.IsNullOrEmpty(Ncharset))</span><br><span class="line">    encode = Encoding.GetEncoding(Ncharset);</span><br><span class="line"><span class="keyword">if</span>(encode == <span class="keyword">null</span> &amp;&amp; !<span class="keyword">string</span>.IsNullOrEmpty(Hcharset))</span><br><span class="line">    encode = Encoding.GetEncoding(Hcharset);</span><br><span class="line"><span class="keyword">if</span> (encode == <span class="keyword">null</span> &amp;&amp; !<span class="keyword">string</span>.IsNullOrEmpty(Rcharset))</span><br><span class="line">    encode = Encoding.GetEncoding(Rcharset);</span><br></pre></td></tr></table></figure>
<p>如果都没有的话，听天由命吧，直接使用默认编码解析。下面是该逻辑和取出内容的部分：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//4，使用默认编码，听天由命吧</span></span><br><span class="line"><span class="keyword">if</span> (encode == <span class="keyword">null</span>)</span><br><span class="line">    encode = Encoding.Default;</span><br><span class="line"></span><br><span class="line">Content = encode.GetString(bytes.ToArray());</span><br><span class="line">ResponseStream.Close();</span><br></pre></td></tr></table></figure>
<p>ok，大功告成！所有代码以及里面的一些依赖都已经在 <a href="https://github.com/ziyunhx/thrinax" target="_blank" rel="external">thrinax</a> 库中了，编码识别模块通过长时间生产环境爬虫使用，统计结果显示识别准确率大于 99.99%。相比之前方式的性能提高数倍。<a href="https://github.com/ziyunhx/thrinax" target="_blank" rel="external">thrinax</a> 的定位是一个使用 .Net 提供网络抓取，信息抽取，自然语言处理的库，其中的大部分代码都会来源于社区或其它开源算法或者论文，该库只是筛选统一方便调用。如果大家有这三方面的好的推荐，可以通过 Issue 或者博客评论发给我！</p>
<p>本文涉及 <a href="https://github.com/ziyunhx/thrinax/blob/master/Helper/HttpHelper.cs" target="_blank" rel="external">HttpHelper</a> 与 <a href="https://github.com/ziyunhx/thrinax/blob/master/Helper/NChardetHelper.cs" target="_blank" rel="external">NChardetHelper</a>，欢迎大家 Star 与 Fork <a href="https://github.com/ziyunhx/thrinax" target="_blank" rel="external">thrinax</a> 库。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在之前的文章中，我给大家介绍了 Nchardet 结合网页头部声明来识别网页的编码。通过较长时间段生产环境的使用，效果并不是十分理想。首先是 Nchardet 带来了极大的CPU的开销，尤其是对大规模的爬虫集群来说几乎无法接受；其次猜测的准确性距离100%还有一段距离。因此，就有了今天的这篇文章。</p>]]>
    
    </summary>
    
      <category term=".NET" scheme="https://www.tnidea.com/tags/NET/"/>
    
      <category term="C#" scheme="https://www.tnidea.com/tags/C/"/>
    
      <category term="charset" scheme="https://www.tnidea.com/tags/charset/"/>
    
      <category term="csharp" scheme="https://www.tnidea.com/tags/csharp/"/>
    
      <category term="爬虫" scheme="https://www.tnidea.com/categories/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用DRPC构建分布式多语言编程架构]]></title>
    <link href="https://www.tnidea.com/build-multi-language-framework-by-drpc.html"/>
    <id>https://www.tnidea.com/build-multi-language-framework-by-drpc.html</id>
    <published>2016-03-25T16:00:00.000Z</published>
    <updated>2016-03-27T06:26:38.000Z</updated>
    <content type="html"><![CDATA[<p>Distributed RPC（DRPC）作为Storm基于Thrift协议的RPC实现，已在之前的文章中被多次提及；在一个多开发语言的环境中，RPC是必不可少的一环，常见的RPC实现方式除了thrift外也还有很多，甚至基于Http协议的RESTful API也可以算作是其中的一员。本文将为您解读：为什么在这么多的RPC方式中选择使用DRPC来构建多语言编程架构，而不是使用Thrift或者其它方式？</p>
<a id="more"></a>
<p>如果你开始阅读这篇文章，我相信你至少同意一家公司出现多种编程语言是一个再正常不过的事情。随着编程语言的发展，大多数语言都会有其最佳使用场景的概念，有些偏向快速开发，有些则更注重效率；不同的部门使用各自熟悉的或合适的语言开发，最终需要协同使用时，有人力的公司可以选择用一种语言重写一遍，那么另一些公司呢？</p>
<p>一开始，你写这个模块可能只是满足自己程序的需要，甚至只是做一个可行性的实验；后来大家发现很好用，越来越多的人使用这个模块，你不得不为了方便别人使用进一步封装，优化代码性能，考虑如何部署成服务，怎么实现负载均衡……</p>
<p>自己创造的代码被广泛使用确实让我信心爆棚，但越来越多的时间花在我原本并不擅长的方向……有没有一种方案让我只需要专心的写代码，多语言调用、部署、负载均衡、分布式什么都我都不需要去管？</p>
<p>答案当然是肯定的啦，下面我就给大家介绍基于 DRPC 构建的分布式多语言编程模式，个人才疏学浅，如果疏漏，请轻拍！</p>
<p> <img src="http://www.tnidea.com/media/image/drpc-flow.jpg" alt="DRPC-flow"></p>
<p>DRPC的整个过程与一般的RPC并没有区别，它的实现也是基于Thrift协议；让它变得与众不同的原因便是让你能方便的使用Storm集群的计算能力，当然这也意味着你的整个计算集群都得基于Storm。如果你对大数据的技术有过了解，即使没有听说过Storm，也一定听说过Hadoop吧，Storm类似于Hadoop中的MapReduce，它最大的改变便是将MapReduce中批处理的方式换成了实时的方式，另一个号称实时的框架spark streaming则只是把批处理变得更小更敏捷罢了。更多关于这三者比较的信息可以查看我之前的文章：<a href="http://www.tnidea.com/compare-with-distributed-computation-system.html" title="开源分布式计算系统框架比较">开源分布式计算系统框架比较</a>。</p>
<p>编写运行在Storm框架上的DRPC模块是非常容易的，你只需要将你原来编写的逻辑代码包裹在Storm Bolt的封装代码中即可。当然，也会有一些限制，首先是需要将复杂的逻辑尽量拆解，将一个需要运行很久的代码直接封装可能会导致Bolt运行超时；其次，目前的DRPC版本仅支持一个字符串的输入输出，这也意味着复杂的对象需要额外的序列化与反序列化开销；第三，目前并非所有语言均已支持Storm，幸运的是完成对Storm的支持并不困难，下面给大家列出我整理的一些支持语言的DEMO（需要支持DRPC仅需将输入与输出参数的末尾增加一个ID）。</p>
<ul>
<li><a href="https://github.com/ziyunhx/storm-net-adapter/blob/master/samples/StormSample/Counter.cs" target="_blank" rel="external">C# Demo</a></li>
<li><a href="https://github.com/apache/storm/blob/master/examples/storm-starter/src/jvm/storm/starter/bolt/PrinterBolt.java" target="_blank" rel="external">Java Demo</a></li>
<li><a href="https://github.com/apache/storm/blob/master/examples/storm-starter/multilang/resources/splitsentence.py" target="_blank" rel="external">Python Demo</a></li>
<li><a href="https://github.com/apache/storm/blob/master/examples/storm-starter/multilang/resources/splitsentence.js" target="_blank" rel="external">NodeJS Demo</a></li>
<li><a href="https://github.com/apache/storm/blob/master/examples/storm-starter/multilang/resources/splitsentence.rb" target="_blank" rel="external">Ruby Demo</a></li>
</ul>
<p>如果你需要完成对一种目前尚不支持的语言的适配，可以查看 <a href="http://storm.apache.org/releases/0.9.6/Multilang-protocol.html" target="_blank" rel="external">Storm Multi-Language Protocol</a>。</p>
<p>另一个需要关心的便是在其它语言中的调用问题，它的实现相比支持Storm更加简单，毕竟只是对Thrift的进一步封装，同样提供我搜集的开源项目地址：</p>
<ul>
<li>C#/.Net    <a href="https://github.com/ziyunhx/storm-net-adapter" target="_blank" rel="external">Storm.Net.Apapter</a></li>
<li>Java    <a href="http://storm.apache.org/" target="_blank" rel="external">Storm 官方项目</a></li>
<li>Python    <a href="https://pypi.python.org/pypi/storm-drpc-client" target="_blank" rel="external">storm-drpc-client</a></li>
<li>Php    <a href="https://github.com/mithunsatheesh/php-drpc" target="_blank" rel="external">php-drpc</a></li>
</ul>
<p>如果需要使用到生产环境中，性能和安全性也是需要考虑的问题。使用DRPC会带来一定性能损耗，但是不要担心，不论是官方的测试报告还是我们实际使用的结论都表明这一损耗在分布式集群中是可接受的，对于大部分的用户甚至无法感知；它的负载能力同样不俗，而且DRPC本身也是支持分布式的。DRPC目前并没有做许多额外的安全性的防护，我们目前也是只能通过切换默认端口号，不开放外网访问或者使用IP白名单，程序中验证访问权限的方式来完成。相信在今后这一块也会受到官方的重视，本文的例子还是以0.9.6版本为基础，官方的开发版本已经到了2.0。</p>
<p>如果你已经下定决心想要尝试下，我已经给你准备了一个Docker快速编排的镜像，你可以查看我之前的文章或者直接依据开源项目的步骤操作，虽然现在在Docker中使用JDK已经违反了协议，还望大家放我一马啊。</p>
<ul>
<li><a href="http://www.tnidea.com/deploy-storm-by-docker.html">使用Docker快速部署Storm环境</a></li>
<li><a href="https://github.com/ziyunhx/storm-mono-docker" target="_blank" rel="external">storm-mono-docker</a></li>
</ul>
<p>另外，现在微信公众号已开通评论和打赏功能，有什么建议或者觉得文章对您有帮助，请移步公众号支持一下哦！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Distributed RPC（DRPC）作为Storm基于Thrift协议的RPC实现，已在之前的文章中被多次提及；在一个多开发语言的环境中，RPC是必不可少的一环，常见的RPC实现方式除了thrift外也还有很多，甚至基于Http协议的RESTful API也可以算作是其中的一员。本文将为您解读：为什么在这么多的RPC方式中选择使用DRPC来构建多语言编程架构，而不是使用Thrift或者其它方式？</p>]]>
    
    </summary>
    
      <category term=".NET" scheme="https://www.tnidea.com/tags/NET/"/>
    
      <category term="C#" scheme="https://www.tnidea.com/tags/C/"/>
    
      <category term="DRPC" scheme="https://www.tnidea.com/tags/DRPC/"/>
    
      <category term="Topology" scheme="https://www.tnidea.com/tags/Topology/"/>
    
      <category term="storm" scheme="https://www.tnidea.com/tags/storm/"/>
    
      <category term="多语言" scheme="https://www.tnidea.com/tags/%E5%A4%9A%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Storm" scheme="https://www.tnidea.com/categories/Storm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用C#自动识别网页编码]]></title>
    <link href="https://www.tnidea.com/recog-http-charset-by-dot-net.html"/>
    <id>https://www.tnidea.com/recog-http-charset-by-dot-net.html</id>
    <published>2016-01-26T16:00:00.000Z</published>
    <updated>2016-01-29T16:34:13.000Z</updated>
    <content type="html"><![CDATA[<p>在大规模的网络爬虫编程中，网页编码识别是必不可少的，本文将介绍如何通过C#来自动识别网页的编码。文中会分析几种可行的方法并提供源码，部分源码来源于开源代码改写而来。</p>
<a id="more"></a>
<p>网页在传输中为了能够正确识别编码，一般在头部都会声明编码格式，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#60;meta charset=&#34;utf-8&#34;&#62;</span><br></pre></td></tr></table></figure>
<p>或者像这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#60;meta http-equiv=&#34;Content-type&#34; content=&#34;text/html; charset=utf-8&#34;&#62;</span><br></pre></td></tr></table></figure>
<p>因此，很自然的我们想到通过读取这个字段来来识别编码。下面代码中 ResponseStream 是从 HTTP 网络流里读取后转化为 Stream 的流。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span> CharsetReg = <span class="string">@"(meta.*?charset=""?(?&lt;Charset&gt;[^\s""'&gt;;]+)""?)|(xml.*?encoding=""?(?&lt;Charset&gt;[^\s""&gt;;]+)""?)"</span>;</span><br><span class="line"></span><br><span class="line">Encoding encode = <span class="keyword">null</span>;</span><br><span class="line">String cache = <span class="keyword">string</span>.Empty;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> b = (<span class="keyword">byte</span>)ResponseStream.ReadByte();</span><br><span class="line">    <span class="keyword">if</span> (b &lt; <span class="number">0</span> || b == <span class="number">255</span>) <span class="comment">//end of stream</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cache.EndsWith(<span class="string">"&lt;/head&gt;"</span>, StringComparison.OrdinalIgnoreCase))</span><br><span class="line">        cache += (<span class="keyword">char</span>)b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (httpWebResponse.CharacterSet == <span class="string">"ISO-8859-1"</span> || httpWebResponse.CharacterSet == <span class="string">"zh-cn"</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Match match = Regex.Match(cache, CharsetReg, RegexOptions.IgnoreCase | RegexOptions.Multiline);</span><br><span class="line">    <span class="keyword">if</span> (match.Success)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            charset = match.Groups[<span class="string">"Charset"</span>].Value;</span><br><span class="line">            encode = Encoding.GetEncoding(charset);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (httpWebResponse.CharacterSet != <span class="keyword">null</span> &amp;&amp; encode == <span class="keyword">null</span>)</span><br><span class="line">    encode = Encoding.GetEncoding(httpWebResponse.CharacterSet);</span><br></pre></td></tr></table></figure>
<p>这个方法仅考虑了中文与英文环境下的情况，如果还有其它编码，请自行修改。</p>
<p>当你满心欢喜的以为可以喝杯咖啡打个盹时，运维妹妹发来了乱码的截图。。。这是哪个实习生在网页写的GB2312，实际却是UTF-8的编码。好吧，看在就这一个的情况下，我写个参数配置一下这个网站的编码吧。</p>
<p>一个小时过去了。。。</p>
<p>已经是第7张乱码截图了，看来乱写编码已经成为了反爬虫的招数之一了！再一次打开网站，发现浏览器中并没有乱码，看来是有其它的判断方式。于是，找到了这个库 <a href="http://www-archive.mozilla.org/projects/intl/chardet.html" target="_blank" rel="external">chardet</a> ，它是mozilla自动字符编码识别程序库，我直接使用了社区中贡献的 .Net 实现版本 <a href="http://www.cnblogs.com/hhh/archive/2007/01/27/632251.html" target="_blank" rel="external">Nchardet</a>。链接是我所能搜索到的最早的文章，如果有错误还望指出！</p>
<p>原程序使用了一种通知模式来反馈编码结果，个人感觉与习惯使用的方式不同，于是改成了静态方法，将 HandleData 等用于识别编码的方法增加了编码返回，另外创建了一个 Nchardet 的 Helper 类：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> Thrinax.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Thrinax.Helper</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NChardetHelper</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> Recog the Encoding from byte array.</span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="bytes"&gt;</span>the byte array.<span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="language"&gt;</span>the language.<span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;returns&gt;</span>charset string, will be empty when can't recog.<span class="xmlDocTag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Encoding <span class="title">RecogEncoding</span>(<span class="params"><span class="keyword">byte</span>[] bytes, NChardetLanguage language = NChardetLanguage.ALL</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">string</span> charset = RecogCharset(bytes, language);</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">string</span>.IsNullOrEmpty(charset))</span><br><span class="line">                <span class="keyword">return</span> Encoding.GetEncoding(charset); </span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> Encoding.Default;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> Recog the charset from byte array.</span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="bytes"&gt;</span>the byte array.<span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="language"&gt;</span>the language.<span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="maxLength"&gt;</span>max length per time. the default is 1024, -1 to without limit.<span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;returns&gt;</span>charset string, will be empty when can't recog.<span class="xmlDocTag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">string</span> <span class="title">RecogCharset</span>(<span class="params"><span class="keyword">byte</span>[] bytes, NChardetLanguage language = NChardetLanguage.ALL, <span class="keyword">int</span> maxLength = <span class="number">1024</span></span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (bytes == <span class="keyword">null</span> || bytes.Length == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            PSMDetector detector = <span class="keyword">new</span> PSMDetector(language);</span><br><span class="line">            <span class="keyword">string</span> charset = String.Empty;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (maxLength &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">do</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">var</span> tempBytes = bytes.Skip(maxLength * count).Take(maxLength);</span><br><span class="line">                    <span class="keyword">if</span> (tempBytes == <span class="keyword">null</span> || tempBytes.Count() == <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    detector.HandleData(tempBytes.ToArray(), tempBytes.Count(), <span class="keyword">ref</span> charset);</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="keyword">string</span>.IsNullOrEmpty(charset))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                detector.HandleData(bytes, bytes.Length, <span class="keyword">ref</span> charset);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">string</span>.IsNullOrEmpty(charset))</span><br><span class="line">                detector.DataEnd(<span class="keyword">ref</span> charset);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> charset;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了平衡效率与准确度，RecogCharset 方法提供了一个 maxLength 的参数，用于指定每次识别的最大byte数，如果指定长度的byte数组无法识别出编码，则会循环直至识别出编码或者所有byte都已参与识别。生成环境下测试该值使用 1024 效果较好。</p>
<p>你以为这样就完了，不，没有，竟然还有一个网站头部与正文部分使用不同编码的，为了避嫌，暂时不点名了。还好目前也就发现了这一个网站，好吧，拿回之前删除的指定编码的代码，把编码指定为我们要获取的部分的编码，最终改写后的方法如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span> CharsetReg = <span class="string">@"(meta.*?charset=""?(?&lt;Charset&gt;[^\s""'&gt;;]+)""?)|(xml.*?encoding=""?(?&lt;Charset&gt;[^\s""&gt;;]+)""?)"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">string</span> Content = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">var</span> bytes = <span class="keyword">new</span> List&lt;<span class="keyword">byte</span>&gt;();</span><br><span class="line">Encoding encode = <span class="keyword">null</span>;</span><br><span class="line">String cache = <span class="keyword">string</span>.Empty;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> b = (<span class="keyword">byte</span>)ResponseStream.ReadByte();</span><br><span class="line">    <span class="keyword">if</span> (b &lt; <span class="number">0</span> || b == <span class="number">255</span>) <span class="comment">//end of stream</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    bytes.Add(b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cache.EndsWith(<span class="string">"&lt;/head&gt;"</span>, StringComparison.OrdinalIgnoreCase))</span><br><span class="line">        cache += (<span class="keyword">char</span>)b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Charset check: input &gt; NChardet &gt; Parser</span></span><br><span class="line"><span class="keyword">if</span> (encode == <span class="keyword">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">string</span> charset = NChardetHelper.RecogCharset(bytes.ToArray());</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">string</span>.IsNullOrEmpty(charset))</span><br><span class="line">        encode = Encoding.GetEncoding(charset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (encode == <span class="keyword">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (httpWebResponse.CharacterSet == <span class="string">"ISO-8859-1"</span> || httpWebResponse.CharacterSet == <span class="string">"zh-cn"</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Match match = Regex.Match(cache, CharsetReg, RegexOptions.IgnoreCase | RegexOptions.Multiline);</span><br><span class="line">            <span class="keyword">if</span> (match.Success)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    charset = match.Groups[<span class="string">"Charset"</span>].Value;</span><br><span class="line">                    encode = Encoding.GetEncoding(charset);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> &#123; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (httpWebResponse.CharacterSet != <span class="keyword">null</span> &amp;&amp; encode == <span class="keyword">null</span>)</span><br><span class="line">            encode = Encoding.GetEncoding(httpWebResponse.CharacterSet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (encode == <span class="keyword">null</span>)</span><br><span class="line">    encode = Encoding.Default;</span><br><span class="line"></span><br><span class="line">Content = encode.GetString(bytes.ToArray());</span><br><span class="line">ResponseStream.Close();</span><br></pre></td></tr></table></figure>
<p>所有代码以及里面的一些依赖都已经在 <a href="https://github.com/ziyunhx/thrinax" target="_blank" rel="external">thrinax</a> 库中了，<a href="https://github.com/ziyunhx/thrinax" target="_blank" rel="external">thrinax</a> 的定位是一个使用 .Net 提供网络抓取，信息抽取，自然语言处理的库，其中的大部分代码都会来源于社区或其它开源算法或者论文，该库只是筛选统一方便调用。如果大家有这三方面的好的推荐，可以通过 Issue 或者博客评论发给我！</p>
<p>本文涉及 <a href="https://github.com/ziyunhx/thrinax/blob/master/Helper/HttpHelper.cs" target="_blank" rel="external">HttpHelper</a> 与 <a href="https://github.com/ziyunhx/thrinax/blob/master/Helper/NChardetHelper.cs" target="_blank" rel="external">NChardetHelper</a>，欢迎大家 Star 与 Fork <a href="https://github.com/ziyunhx/thrinax" target="_blank" rel="external">thrinax</a> 库。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在大规模的网络爬虫编程中，网页编码识别是必不可少的，本文将介绍如何通过C#来自动识别网页的编码。文中会分析几种可行的方法并提供源码，部分源码来源于开源代码改写而来。</p>]]>
    
    </summary>
    
      <category term=".NET" scheme="https://www.tnidea.com/tags/NET/"/>
    
      <category term="C#" scheme="https://www.tnidea.com/tags/C/"/>
    
      <category term="charset" scheme="https://www.tnidea.com/tags/charset/"/>
    
      <category term="csharp" scheme="https://www.tnidea.com/tags/csharp/"/>
    
      <category term="爬虫" scheme="https://www.tnidea.com/categories/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Icinga2监控服务器带宽以及内存占用]]></title>
    <link href="https://www.tnidea.com/add-network-memory-for-icinga2-monitor.html"/>
    <id>https://www.tnidea.com/add-network-memory-for-icinga2-monitor.html</id>
    <published>2016-01-10T16:00:00.000Z</published>
    <updated>2016-01-10T14:03:39.000Z</updated>
    <content type="html"><![CDATA[<p>监控是系统运维的基础，Icinga是一个开源的监控系统框架，通过其广泛的插件支持，你可以监控几乎任何你能想到的网络资源；也可以在超过临界值时给予通知，根据监控数据生产报表。本文将介绍如何通过SNMP协议来监控服务器的带宽以及内存占用。</p>
<a id="more"></a>
<p>SNMP（简单网络管理协议），由一组网络管理的标准组成，包含一个应用层协议、数据库模型和一组资源对象。该协议能够支持网络管理系统，用以监测连接到网络上的设备是否有任何引起管理上关注的情况。SNMP的目标是管理互联网 Internet 上众多厂家生产的软硬件平台，因此SNMP受Internet标准网络管理框架的影响也很大。</p>
<p>下表是 Icinga2 通过 SNMP 在各类系统上支持的项，本文仅介绍 Centos7 和 Windows 系统下的网络和内存的监控设置。</p>
<table>
<thead>
<tr>
<th>主机类型</th>
<th>接口</th>
<th>存储</th>
<th>CPU负载</th>
<th>内存</th>
<th>进程</th>
<th>环境变量</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>Linux</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
<td>NO</td>
<td></td>
</tr>
<tr>
<td>Windows</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
<td>NO</td>
<td>check_snmp_win.pl</td>
</tr>
<tr>
<td>Cisco router/switch</td>
<td>YES</td>
<td>N/A</td>
<td>YES</td>
<td>YES</td>
<td>N/A</td>
<td>YES</td>
<td></td>
</tr>
<tr>
<td>HP router/switch</td>
<td>YES</td>
<td>N/A</td>
<td>YES</td>
<td>YES</td>
<td>N/A</td>
<td>NO</td>
<td></td>
</tr>
<tr>
<td>Bluecoat proxy</td>
<td>YES</td>
<td>SNMP</td>
<td>YES</td>
<td>SNMP</td>
<td>NO</td>
<td>YES</td>
<td></td>
</tr>
<tr>
<td>CheckPoint on SPLAT</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
<td>NO</td>
<td>check_snmp_cpfw.pl</td>
</tr>
<tr>
<td>CheckPoint on Nokia IP</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
<td>NO</td>
<td>–</td>
<td>NO</td>
<td>check_snmp_vrrp.pl</td>
</tr>
<tr>
<td>Boostedge</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
<td>–</td>
<td>NO</td>
<td>check_snmp_boostedge.pl</td>
</tr>
<tr>
<td>AS400</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
<td>NO</td>
<td>NO</td>
<td></td>
</tr>
<tr>
<td>NetsecureOne Netbox</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
<td>–</td>
<td>YES</td>
<td>NO</td>
<td></td>
</tr>
<tr>
<td>Radware Linkproof</td>
<td>YES</td>
<td>N/A</td>
<td>SNMP</td>
<td>SNMP</td>
<td>NO</td>
<td>NO</td>
<td>check_snmp_linkproof_nhr <br> check_snmp_vrrp.pl</td>
</tr>
<tr>
<td>IronPort</td>
<td>YES</td>
<td>SNMP</td>
<td>SNMP</td>
<td>SNMP</td>
<td>NO</td>
<td>YES</td>
<td></td>
</tr>
<tr>
<td>Cisco CSS</td>
<td>YES</td>
<td>–</td>
<td>YES</td>
<td>YES</td>
<td>NO</td>
<td>–</td>
<td>check_snmp_css.pl</td>
</tr>
</tbody>
</table>
<ul>
<li>N/A, NO: 不支持或不存在</li>
<li>SNMP: 仅支持简单的SNMP查询</li>
<li>–: 未测试</li>
</ul>
<h1 id="安装与配置SNMP">安装与配置SNMP</h1><h4 id="安装_NET-SNMP">安装 NET-SNMP</h4><p>CentOS可以直接通过yum安装 NET-SNMP 的包，其它系统也可以通过 <a href="http://sourceforge.net/projects/net-snmp/" target="_blank" rel="external">NET-SNMP项目</a> 下载安装。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># yum install net-snmp net-snmp-devel net-snmp-utils</span><br></pre></td></tr></table></figure>
<h4 id="配置_NET-SNMP">配置 NET-SNMP</h4><p>CentOS需要关闭selinux才能正常使用snmp v3，使用以下命令查看SELinux状态：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># /usr/sbin/sestatus -v</span><br></pre></td></tr></table></figure>
<p>如果SELinux status参数为enabled即为开启状态。</p>
<p>关闭SELinux：</p>
<p>1: 临时关闭（不用重启机器），但机器重启后会失效： <code># setenforce 0</code></p>
<p>2: 永久关闭，需要修改配置文件需要重启机器：<br>修改/etc/selinux/config 文件，将SELINUX=enforcing改为SELINUX=disabled，重启系统。</p>
<p>停用 NET-SNMP 服务，并配置用户：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># service snmpd stop&#10;# net-snmp-config --create-snmpv3-user -ro -A tnidea@carey -a MD5 carey</span><br></pre></td></tr></table></figure>
<p>以上命令，创建了一个用户名为carey，密码为tnidea@carey的snmpv3用户，使用MD5加密。</p>
<h4 id="运行_NET-SNMP">运行 NET-SNMP</h4><p>运行 NET-SNMP 服务，并加入到开机启动项。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># service snmpd start&#10;# chkconfig snmpd on</span><br></pre></td></tr></table></figure>
<p>使用 snmpwalk 命令检测snmp服务是否正常启动，正常将返回相关结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># snmpwalk -v 3 -u carey -a MD5 -A &#34;tnidea@carey&#34; -l authNoPriv 127.0.0.1 sysDescr</span><br></pre></td></tr></table></figure>
<p>Windows系统包中已经自带了 SNMP 功能，直接在 控制面板-&gt;添加或删除程序 中找到 简单网络管理协议(SNMP) 并勾选，安装完成后到服务中配置相关安全选项。</p>
<p>另外你还需要在防火墙上允许 SNMP 端口进行通讯，其默认端口为 161 。</p>
<h1 id="安装SNMP模块监控网络与内存">安装SNMP模块监控网络与内存</h1><p>首先安装 perl 环境，下面是以 Centos 为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># yum install perl*&#10;# yum install cpan</span><br></pre></td></tr></table></figure>
<p>然后通过 CPAN 来安装 Net-SNMP：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># perl -MCPAN -e shell&#10;cpan shell -- CPAN exploration and modules installation (v1.76)&#10;ReadLine support enabled&#10;cpan&#62; install Net::SNMP</span><br></pre></td></tr></table></figure>
<p>CPAN 的安装目录可能在ROOT目录下，这会导致 Icinga2 无法调用，你需要根据安装结果提示将安装的文件复制到支持的目录，比如：<code>/usr/local/lib64/perl5/</code>。</p>
<p>另外还需要将 utils.pm 链接到 perl 的运行目录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ln -s /usr/lib64/nagios/plugins/utils.pm /usr/local/lib64/perl5/</span><br></pre></td></tr></table></figure>
<p>另外你还需要通过修改配置文件 icinga2.conf 来启用 SNMP 插件检查命令，在该文件中增加 <code>include &lt;manubulon&gt;</code>。</p>
<h4 id="通过_SNMP_检查内存">通过 SNMP 检查内存</h4><p>该功能需要 <a href="http://nagios.manubulon.com/snmp_mem.html" target="_blank" rel="external">check_snmp_mem.pl</a> 命令，如果不存在需要下载后放到 manubulon 定义的目录。下面是支持的一些参数：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>snmp_address</td>
<td>可选，主机地址，默认为变量 “$address$” 所设置的值。</td>
</tr>
<tr>
<td>snmp_nocrypt</td>
<td>可选，定义 SNMP 加密方式，仅在使用 snmp_v3 时需要设置，默认为 false。</td>
</tr>
<tr>
<td>snmp_community</td>
<td>可选，SNMP 接受团体，默认为 “public”。</td>
</tr>
<tr>
<td>snmp_port</td>
<td>可选，SNMP 连接端口。</td>
</tr>
<tr>
<td>snmp_v2</td>
<td>可选，SNMP 版本为 2c？默认为 false。</td>
</tr>
<tr>
<td>snmp_v3</td>
<td>可选，SNMP 版本为 3？默认为 false。</td>
</tr>
<tr>
<td>snmp_login</td>
<td>可选，snmp_v3 时的用户名，默认为 “snmpuser”。</td>
</tr>
<tr>
<td>snmp_password</td>
<td>必须，snmp_v3 时的密码，无默认值。</td>
</tr>
<tr>
<td>snmp_v3_use_privpass</td>
<td>可选，定义 snmp_v3 使用的私钥，默认为 false。</td>
</tr>
<tr>
<td>snmp_authprotocol</td>
<td>可选，snmp_v3的验证接口，默认为 “md5,des”。</td>
</tr>
<tr>
<td>snmp_privpass</td>
<td>必须，snmp_v3 时的私钥，仅在使用私钥时需要，无默认值。</td>
</tr>
<tr>
<td>snmp_warn</td>
<td>可选，提示警告时的取值范围。</td>
</tr>
<tr>
<td>snmp_crit</td>
<td>可选，提示错误时的取值返回。</td>
</tr>
<tr>
<td>snmp_is_cisco</td>
<td>可选，修改 Cisco switches 的 OIDs，默认为 false。</td>
</tr>
<tr>
<td>snmp_perf</td>
<td>可选，允许生成 perfdata 的值（用于图表），默认为 true。</td>
</tr>
<tr>
<td>snmp_timeout</td>
<td>可选，命令超时时间，默认为 5秒。</td>
</tr>
</tbody>
</table>
<p>下面是一个检查内存的例子，放在 services.conf：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apply Service &#34;memory&#34; &#123;&#10;  import &#34;generic-service&#34;&#10;&#10;  check_command = &#34;snmp-memory&#34;&#10;  vars.snmp_nocrypt = &#34;authNoPriv&#34;&#10;  vars.snmp_v3 = true&#10;  vars.snmp_login = &#34;carey&#34;&#10;  vars.snmp_password = &#34;tnidea@carey&#34;&#10;  vars.snmp_authprotocol = &#34;MD5&#34;&#10;  assign where host.name == NodeName&#10;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="通过_SNMP_检查网络">通过 SNMP 检查网络</h4><p>该功能需要 <a href="http://nagios.manubulon.com/snmp_int.html" target="_blank" rel="external">check_snmp_int.pl</a> 命令，如果不存在需要下载后放到 manubulon 定义的目录。下面是支持的一些参数：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>snmp_address</td>
<td>可选，主机地址，默认为变量 “$address$” 所设置的值。</td>
</tr>
<tr>
<td>snmp_nocrypt</td>
<td>可选，定义 SNMP 加密方式，仅在使用 snmp_v3 时需要设置，默认为 false。</td>
</tr>
<tr>
<td>snmp_community</td>
<td>可选，SNMP 接受团体，默认为 “public”。</td>
</tr>
<tr>
<td>snmp_port</td>
<td>可选，SNMP 连接端口。</td>
</tr>
<tr>
<td>snmp_v2</td>
<td>可选，SNMP 版本为 2c？默认为 false。</td>
</tr>
<tr>
<td>snmp_v3</td>
<td>可选，SNMP 版本为 3？默认为 false。</td>
</tr>
<tr>
<td>snmp_login</td>
<td>可选，snmp_v3 时的用户名，默认为 “snmpuser”。</td>
</tr>
<tr>
<td>snmp_password</td>
<td>必须，snmp_v3 时的密码，无默认值。</td>
</tr>
<tr>
<td>snmp_v3_use_privpass</td>
<td>可选，定义 snmp_v3 使用的私钥，默认为 false。</td>
</tr>
<tr>
<td>snmp_authprotocol</td>
<td>可选，snmp_v3的验证接口，默认为 “md5,des”。</td>
</tr>
<tr>
<td>snmp_privpass</td>
<td>必须，snmp_v3 时的私钥，仅在使用私钥时需要，无默认值。</td>
</tr>
<tr>
<td>snmp_warn</td>
<td>可选，提示警告时的取值范围。</td>
</tr>
<tr>
<td>snmp_crit</td>
<td>可选，提示错误时的取值返回。</td>
</tr>
<tr>
<td>snmp_interface</td>
<td>可选，网卡名称，默认为 “eth0”。注意该项是模糊匹配。</td>
</tr>
<tr>
<td>snmp_interface_perf</td>
<td>可选，检查输入输出端口的带宽，默认为 true。</td>
</tr>
<tr>
<td>snmp_interface_label</td>
<td>可选，在输出前自定义字段，例如 in=, out=, errors-out=, 等等…</td>
</tr>
<tr>
<td>snmp_interface_bits_bytes</td>
<td>可选，输出数据格式使用 bits/s 或者 Bytes/s。需要 snmp_interface_kbits 设置为 true。默认为 true。</td>
</tr>
<tr>
<td>snmp_interface_percent</td>
<td>可选， 输出数据使用相对于最大值的百分比表述，默认为 false。</td>
</tr>
<tr>
<td>snmp_interface_kbits</td>
<td>可选，使用 KBits/s 来定义警告与错误的等级，默认为 true。</td>
</tr>
<tr>
<td>snmp_interface_megabytes</td>
<td>可选，使用 Mbps 或 MBps 来定义警告与错误的等级，需要 snmp_interface_kbits 设置为 true。默认为 true。</td>
</tr>
<tr>
<td>snmp_interface_64bit</td>
<td>可选，使用64位的计数器取代默认的计数器，当带宽大于等于 1Gb 时使用，默认为 false。</td>
</tr>
<tr>
<td>snmp_interface_errors</td>
<td>可选，在输出时输出错误信息，默认为 true。</td>
</tr>
<tr>
<td>snmp_interface_noregexp</td>
<td>可选，不使用正则匹配网卡名称，默认为 false。</td>
</tr>
<tr>
<td>snmp_interface_delta</td>
<td>可选，检查间隔时间，默认为 “300” (5 分钟)。</td>
</tr>
<tr>
<td>snmp_warncrit_percent</td>
<td>可选，将警告与错误的等级通过报告速度的百分比来定义，如果设置了 snmp_interface_megabytes 则需要设置为 false。 默认为 false。</td>
</tr>
<tr>
<td>snmp_perf</td>
<td>可选，允许生成 perfdata 的值（用于图表），默认为 true。</td>
</tr>
<tr>
<td>snmp_timeout</td>
<td>可选，命令超时时间，默认为 5秒。</td>
</tr>
</tbody>
</table>
<p>下面是一个检查网络的例子，同样放在 services.conf：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apply Service &#34;network&#34; &#123;&#10;  import &#34;generic-service&#34;&#10;&#10;  check_command = &#34;snmp-interface&#34;&#10;  vars.snmp_nocrypt = &#34;authNoPriv&#34;&#10;  vars.snmp_v3 = true&#10;  vars.snmp_login = &#34;carey&#34;&#10;  vars.snmp_password = &#34;tnidea@carey&#34;&#10;  vars.snmp_interface = &#34;eth0&#34;&#10;  vars.snmp_authprotocol = &#34;MD5&#34;&#10;  vars.snmp_interface_megabytes = false&#10;  assign where host.name == NodeName&#10;&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>监控是系统运维的基础，Icinga是一个开源的监控系统框架，通过其广泛的插件支持，你可以监控几乎任何你能想到的网络资源；也可以在超过临界值时给予通知，根据监控数据生产报表。本文将介绍如何通过SNMP协议来监控服务器的带宽以及内存占用。</p>]]>
    
    </summary>
    
      <category term="CentOS" scheme="https://www.tnidea.com/tags/CentOS/"/>
    
      <category term="Icinga Web2" scheme="https://www.tnidea.com/tags/Icinga-Web2/"/>
    
      <category term="Icinga2" scheme="https://www.tnidea.com/tags/Icinga2/"/>
    
      <category term="Memory" scheme="https://www.tnidea.com/tags/Memory/"/>
    
      <category term="Network" scheme="https://www.tnidea.com/tags/Network/"/>
    
      <category term="服务器监控" scheme="https://www.tnidea.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%91%E6%8E%A7/"/>
    
      <category term="运维" scheme="https://www.tnidea.com/categories/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ImitateLogin新增插件机制以及又一个社交网站的支持]]></title>
    <link href="https://www.tnidea.com/imitate-login-support-plugin-now.html"/>
    <id>https://www.tnidea.com/imitate-login-support-plugin-now.html</id>
    <published>2016-01-08T16:00:00.000Z</published>
    <updated>2016-01-08T16:25:39.000Z</updated>
    <content type="html"><![CDATA[<p>我的文章里已经多次介绍 <a href="https://github.com/ziyunhx/imitate-login" target="_blank" rel="external">imitate-login</a> ，这是我最近一直在维护的一个使用c#模拟社交网站登录的开源项目，现在新增了对插件的支持以及一个新的网站（由于某种原因，会在文章结束部分介绍；而且仅会出现在博客中）。希望喜欢的读者可以通过 <strong>Star &amp; fork</strong> 来支持我，我也会据此来决定时间的分配。</p>
 <a id="more"></a>
<p>说点无关的东西，最近把博客从 GitHub Page 迁移到了 Azure，为了减轻域名与服务器的费用，在文章的正文开头和结尾放了点小广告，如果影响了你的阅读体验，请自行使用 Adblock Plus。 </p>
<p>好了，言归正常！<a href="https://github.com/ziyunhx/imitate-login" target="_blank" rel="external">imitate-login</a> 现在已经提供了对插件的支持；目前有两个部分使用到了插件机制，登录自身实现以及登录过程中的验证码识别过程；其中登录过程仅支持 MEF（Managed Extensibility Framework）模式，而验证码识别过程支持 Thrift RPC (Apache Thrift)、HTTP RESTful (POST/GET)、MEF 三种方式。下面将介绍这三种插件的开发与配置方式，所有代码均已经在 <a href="https://github.com/ziyunhx/imitate-login/tree/master/Extensions" target="_blank" rel="external">Extensions</a> 。</p>
<h3 id="Thrift_RPC">Thrift RPC</h3><p>在 Imitate Login 的库中有通过 Thrift 文件生成的类 ThriftOperation，如果你使用其它语言开发，请通过 Thrift 生成对应的类，下面将介绍使用C#来开发插件。</p>
<p>首先，创建一个控制台应用程序，新增一个类继承 ThriftOperation.Iface 并实现，这里直接 return 一下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">class demo : ThriftOperation.Iface</span><br><span class="line">&#123;</span><br><span class="line">    public string Operation(OperationObj operationObj)</span><br><span class="line">    &#123;</span><br><span class="line">        return "1234";</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在主函数里增加一个创建 Thrift 服务端得方法：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> port = <span class="number">7801</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">string</span> str = ConfigurationManager.AppSettings[<span class="string">"ServerPort"</span>];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">string</span>.IsNullOrEmpty(str))</span><br><span class="line">        <span class="keyword">int</span>.TryParse(str, <span class="keyword">out</span> port);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (args != <span class="keyword">null</span> &amp;&amp; args.Length == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span>.TryParse(args[<span class="number">0</span>], <span class="keyword">out</span> port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Start(port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"><span class="keyword">int</span> port</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    TServerSocket serverTransport = <span class="keyword">new</span> TServerSocket(port, <span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">    ThriftOperation.Processor processor = <span class="keyword">new</span> ThriftOperation.Processor(<span class="keyword">new</span> demo());</span><br><span class="line">    TServer server = <span class="keyword">new</span> TSimpleServer(processor, serverTransport);</span><br><span class="line">    Console.WriteLine(<span class="string">"Starting server on port &#123;0&#125; ..."</span>, port);</span><br><span class="line">    server.Serve();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用时，你需要先启动该插件程序，然后将下面配置部分合并放到程序运行目录的 extension.conf 文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#10;    &#34;ExtendType&#34;: 3,&#10;    &#34;SupportSite&#34;: [2],&#10;    &#34;Path&#34;: null,&#10;    &#34;Host&#34;: &#34;127.0.0.1&#34;,&#10;    &#34;Port&#34;: 7801,&#10;    &#34;UrlFormat&#34;: null,&#10;    &#34;HttpMethod&#34;: null&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>你可以使用 <a href="https://github.com/ziyunhx/imitate-login/tree/master/Tools/PluginConfigBuild" target="_blank" rel="external">PluginConfigBuild</a> 工具来生成配置文件，此处不再解释具体细节。</p>
<h3 id="HTTP_RESTful">HTTP RESTful</h3><p>另外一种插件方式即使用通用的 Http RESTful API 来实现，如果通过 GET 方法，你仅能传入一个枚举用来表明网站以及一个字符串作为参数；如果你通过 POST 方法，需要通过 Thrift 获得一个 OperationObj 类的定义，当然 C# 可以通过直接引用 <a href="https://github.com/ziyunhx/imitate-login" target="_blank" rel="external">imitate-login</a> 库来获得。API 的编写方法不再累述，接下来你需要将以下配置部分合并放到程序运行目录的 extension.conf 文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#10;    &#34;ExtendType&#34;: 2,&#10;    &#34;SupportSite&#34;: [6],&#10;    &#34;Path&#34;: null,&#10;    &#34;Host&#34;: null,&#10;    &#34;Port&#34;: 0,&#10;    &#34;UrlFormat&#34;: &#34;http://localhost:2920/Mail/SendMail?loginSite=&#123;0&#125;&#38;imageUrl=&#123;1&#125;&#34;,&#10;    &#34;HttpMethod&#34;: &#34;GET&#34;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="MEF">MEF</h3><p>MEF 是微软在 .NET 4.0 以后原生提供的一种插件模式；使用该方法需要用到 IMEFOperation 类，你需要通过引用 <a href="https://github.com/ziyunhx/imitate-login" target="_blank" rel="external">imitate-login</a> 得到，demo 代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[Export(<span class="keyword">typeof</span>(IMEFOperation))]</span><br><span class="line">[ExportMetadata(<span class="string">"loginSite"</span>, LoginSite.Baidu)]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">demo</span> : <span class="title">IMEFOperation</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">Operate</span>(<span class="params"><span class="keyword">string</span> imageUrl = <span class="string">""</span>, Image image = <span class="keyword">null</span>, <span class="keyword">params</span> <span class="keyword">string</span>[] param</span>)</span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"1234"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式需要在配置文件中指定插件的存放位置，位置支持相对运行目录或绝对目录；本例为将该插件生成的 dll 拷贝到程序运行目录下的 Extensions 目录中，配置文件如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#10;    &#34;ExtendType&#34;: 1,&#10;    &#34;SupportSite&#34;: [5, 1],&#10;    &#34;Path&#34;: &#34;Extensions&#34;,&#10;    &#34;Host&#34;: null,&#10;    &#34;Port&#34;: 0,&#10;    &#34;UrlFormat&#34;: null,&#10;    &#34;HttpMethod&#34;: null&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>所有的配置文件均可以通过 <a href="https://github.com/ziyunhx/imitate-login/tree/master/Tools/PluginConfigBuild" target="_blank" rel="external">PluginConfigBuild</a> 工具来生成，其中 SupportSite 为支持的登录网站的枚举数组。</p>
<hr>
<p>以下内容将仅在博客中展示！</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 博客正文广告 -->
<ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-6541442242935379" data-ad-slot="9453052931" data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<p>为了展示插件机制，我将微信网页版的登录增加到了库中；该方式为登录时将二维码通过邮件发送到指定的邮箱，人工使用手机微信扫描后登录微信。该方法仅供展示插件机制，无生成环境使用价值，请轻喷！</p>
<p>修改 <a href="https://github.com/ziyunhx/imitate-login/tree/master/Extensions/MailNotication" target="_blank" rel="external">MailNotication</a> 插件的 web.config 中的发信邮箱与收信邮箱设置，在 IIS 中部署好WebAPI，配置好插件配置文件，即可测试微信登录功能。</p>
<hr>
<p>好了，接下来需要什么自己动手试试吧！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>我的文章里已经多次介绍 <a href="https://github.com/ziyunhx/imitate-login">imitate-login</a> ，这是我最近一直在维护的一个使用c#模拟社交网站登录的开源项目，现在新增了对插件的支持以及一个新的网站（由于某种原因，会在文章结束部分介绍；而且仅会出现在博客中）。希望喜欢的读者可以通过 <strong>Star &amp; fork</strong> 来支持我，我也会据此来决定时间的分配。</p>]]>
    
    </summary>
    
      <category term=".NET" scheme="https://www.tnidea.com/tags/NET/"/>
    
      <category term="C#" scheme="https://www.tnidea.com/tags/C/"/>
    
      <category term="social network" scheme="https://www.tnidea.com/tags/social-network/"/>
    
      <category term="thrift" scheme="https://www.tnidea.com/tags/thrift/"/>
    
      <category term="wechat" scheme="https://www.tnidea.com/tags/wechat/"/>
    
      <category term="微信" scheme="https://www.tnidea.com/tags/%E5%BE%AE%E4%BF%A1/"/>
    
      <category term="插件机制" scheme="https://www.tnidea.com/tags/%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6/"/>
    
      <category term="爬虫" scheme="https://www.tnidea.com/categories/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Icinga2监控Linux和Windows服务器]]></title>
    <link href="https://www.tnidea.com/icinga2-monitor-other-machine.html"/>
    <id>https://www.tnidea.com/icinga2-monitor-other-machine.html</id>
    <published>2016-01-05T16:00:00.000Z</published>
    <updated>2016-01-06T16:02:29.000Z</updated>
    <content type="html"><![CDATA[<p>Icinga2可以通过Agent来监控其它设备，这些设备包含各种操作系统的服务器以及网络设备。一些简单的网络指标监控是不需要创建Agent的，例如ping和ssh；但是某些无法通过网络获取的指标则需要在被监测服务器创建一个监控代理来将指标返回给监控服务器。本文将介绍如何在Linux和Windows服务器上安装和配置Agent来实现多机器的监控。</p>
<a id="more"></a>
<h1 id="配置监控服务器">配置监控服务器</h1><p>在配置远程监控代理之前，你首先需要设置一下主节点；这个设置过程主要是完成了一下几个步骤：</p>
<ul>
<li>为主节点生成SSL加密的CA证书；</li>
<li>启用 API 功能，在配置文件增加本地 Endpoint 和 Zone 的配置；</li>
<li>设置防火墙允许通信端口（默认为 5665）。</li>
</ul>
<p>你可以使用命令行界面来设置一个主节点，它需要以root权限来执行，如果你是使用该命令来设置主节点，注意第一个选项需要选择NO（n）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># icinga2 node wizard&#10;Welcome to the Icinga 2 Setup Wizard!&#10;&#10;We&#39;ll guide you through all required configuration details.&#10;&#10;Please specify if this is a satellite setup (&#39;n&#39; installs a master setup) [Y/n]: n&#10;Starting the Master setup routine...&#10;Please specifiy the common name (CN) [icinga2-node1.localdomain]: &#10;Checking the &#39;api&#39; feature...&#10;&#39;api&#39; feature not enabled, running &#39;api setup&#39; now.&#10;information/cli: Generating new CA.&#10;&#10;information/base: Writing private key to &#39;/var/lib/icinga2/ca/ca.key&#39;.&#10;information/base: Writing X509 certificate to &#39;/var/lib/icinga2/ca/ca.crt&#39;.&#10;information/cli: Initializing serial file in &#39;/var/lib/icinga2/ca/serial.txt&#39;.&#10;information/cli: Generating new CSR in &#39;/etc/icinga2/pki/icinga2-node1.localdomain.csr&#39;.&#10;&#10;information/base: Writing private key to &#39;/etc/icinga2/pki/icinga2-node1.localdomain.key&#39;.&#10;information/base: Writing certificate signing request to &#39;/etc/icinga2/pki/icinga2-node1.localdomain.csr&#39;.&#10;information/cli: Signing CSR with CA and writing certificate to &#39;/etc/icinga2/pki/icinga2-node1.localdomain.crt&#39;.&#10;&#10;information/cli: Copying CA certificate to &#39;/etc/icinga2/pki/ca.crt&#39;.&#10;&#10;information/cli: Adding new ApiUser &#39;root&#39; in &#39;/etc/icinga2/conf.d/api-users.conf&#39;.&#10;&#10;information/cli: Enabling the ApiListener feature.&#10;&#10;Enabling feature api. Make sure to restart Icinga 2 for these changes to take effect.&#10;information/cli: Dumping config items to file &#39;/etc/icinga2/zones.conf&#39;.&#10;Please specify the API bind host/port (optional):&#10;Bind Host []: &#10;Bind Port []: &#10;information/cli: Updating constants.conf.&#10;information/cli: Updating constants file &#39;/etc/icinga2/constants.conf&#39;.&#10;information/cli: Updating constants file &#39;/etc/icinga2/constants.conf&#39;.&#10;Done.&#10;&#10;Now restart your Icinga 2 daemon to finish the installation!</span><br></pre></td></tr></table></figure>
<p>验证配置文件，检查该步骤是否成功：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># egrep &#39;NodeName|TicketSalt&#39; /etc/icinga2/constants.conf&#10;# cat /etc/icinga2/zones.conf&#10;/*&#10; * Generated by Icinga 2 node setup commands&#10; * on 2015-02-09 15:21:49 +0100&#10; */&#10;object Endpoint &#34;icinga2-node1.localdomain&#34; &#123;&#10;&#125;&#10;&#10;object Zone &#34;master&#34; &#123;&#10;    //this is the local node master named  = &#34;master&#34;&#10;    endpoints = [ &#34;icinga2-node1.localdomain&#34; ]&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>验证完成后重启 Icinga2。</p>
<p>在主节点使用命令行生成 ticket，其中 icinga2-node2.localdomain 为远程节点的 CN：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># icinga2 pki ticket --cn icinga2-node2.localdomain</span><br></pre></td></tr></table></figure>
<h1 id="监控Linux服务器">监控Linux服务器</h1><p>Linux的远程节点安装与主节点相同，安装完Icinga2后，使用 icinga2 node wizard 配置远程节点，此处在第一次选择时直接使用回车选择默认选项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># icinga2 node wizard&#10;Welcome to the Icinga 2 Setup Wizard!&#10;We&#39;ll guide you through all required configuration details.&#10;&#10;Please specify if this is a satellite setup (&#39;n&#39; installs a master setup) [Y/n]:&#10;Starting the Node setup routine...&#10;Please specifiy the common name (CN) [icinga2-node2.localdomain]:&#10;Please specifiy the local zone name [icinga2-node2.localdomain]:&#10;Please specify the master endpoint(s) this node should connect to:&#10;Master Common Name (CN from your master setup): icinga2-node1.localdomain&#10;Please fill out the master connection information:&#10;Master endpoint host (optional, your master&#39;s IP address or FQDN): 192.168.56.101&#10;Master endpoint port (optional) []:&#10;Add more master endpoints? [y/N]&#10;Please specify the master connection for CSR auto-signing (defaults to master endpoint host):&#10;Host [192.168.56.101]:&#10;Port [5665]:&#10;information/base: Writing private key to &#39;/etc/icinga2/pki/icinga2-node2.localdomain.key&#39;.&#10;information/base: Writing X509 certificate to &#39;/etc/icinga2/pki/icinga2-node2.localdomain.crt&#39;.&#10;information/cli: Generating self-signed certifiate:&#10;information/cli: Fetching public certificate from master (192.168.56.101, 5665):&#10;&#10;information/cli: Writing trusted certificate to file &#39;/etc/icinga2/pki/trusted-master.crt&#39;.&#10;information/cli: Stored trusted master certificate in &#39;/etc/icinga2/pki/trusted-master.crt&#39;.&#10;&#10;Please specify the request ticket generated on your Icinga 2 master.&#10; (Hint: # icinga2 pki ticket --cn &#39;icinga2-node2.localdomain&#39;): ead2d570e18c78abf285d6b85524970a0f69c22d&#10;information/cli: Processing self-signed certificate request. Ticket &#39;ead2d570e18c78abf285d6b85524970a0f69c22d&#39;.&#10;&#10;information/cli: Writing signed certificate to file &#39;/etc/icinga2/pki/icinga2-node2.localdomain.crt&#39;.&#10;information/cli: Writing CA certificate to file &#39;/etc/icinga2/pki/ca.crt&#39;.&#10;Please specify the API bind host/port (optional):&#10;Bind Host []:&#10;Bind Port []:&#10;information/cli: Disabling the Notification feature.&#10;Disabling feature notification. Make sure to restart Icinga 2 for these changes to take effect.&#10;information/cli: Enabling the Apilistener feature.&#10;Enabling feature api. Make sure to restart Icinga 2 for these changes to take effect.&#10;information/cli: Created backup file &#39;/etc/icinga2/features-available/api.conf.orig&#39;.&#10;information/cli: Generating local zones.conf.&#10;information/cli: Dumping config items to file &#39;/etc/icinga2/zones.conf&#39;.&#10;information/cli: Created backup file &#39;/etc/icinga2/zones.conf.orig&#39;.&#10;information/cli: Updating constants.conf.&#10;information/cli: Created backup file &#39;/etc/icinga2/constants.conf.orig&#39;.&#10;information/cli: Updating constants file &#39;/etc/icinga2/constants.conf&#39;.&#10;information/cli: Updating constants file &#39;/etc/icinga2/constants.conf&#39;.&#10;Done.&#10;&#10;Now restart your Icinga 2 daemon to finish the installation!</span><br></pre></td></tr></table></figure>
<p>安装设置过程完成了以下过程：</p>
<ul>
<li>生成一个新的自签名证书并拷贝到 /etc/icinga2/pki；</li>
<li>保存主节点证书到信任证书； </li>
<li>生成一个客户端节点的本地空间和终结点配置；</li>
<li>禁用客户端通知功能；</li>
<li>启用API功能，设置 bind_host 和 bind_port；</li>
<li>在 constants.conf 文件设置 NodeName 常量。</li>
</ul>
<p>验证配置文件并重启 Icinga2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># grep &#39;NodeName&#39; /etc/icinga2/constants.conf&#10;&#10;# cat /etc/icinga2/zones.conf&#10;/*&#10; * Generated by Icinga 2 node setup commands&#10; * on 2015-02-09 16:56:10 +0100&#10; */&#10;&#10;object Endpoint &#34;icinga2-node1.localdomain&#34; &#123;&#10;    host = &#34;192.168.56.101&#34;&#10;&#125;&#10;&#10;object Zone &#34;master&#34; &#123;&#10;    endpoints = [ &#34;icinga2-node1.localdomain&#34; ]&#10;&#125;&#10;&#10;object Endpoint &#34;icinga2-node2.localdomain&#34; &#123;&#10;&#125;&#10;&#10;object Zone &#34;icinga2-node2.localdomain&#34; &#123;&#10;    //this is the local node = &#34;icinga2-node2.localdomain&#34;&#10;    endpoints = [ &#34;icinga2-node2.localdomain&#34; ]&#10;    parent = &#34;master&#34;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h1 id="监控Windows服务器">监控Windows服务器</h1><p>下载 Icinga2 的安装包，网址：<a href="http://packages.icinga.org/windows/" target="_blank" rel="external">http://packages.icinga.org/windows/</a> 。</p>
<p>系统环境需求：</p>
<p>Windows Vista/Server 2008 或者更高；<br>Microsoft .NET Framework 2.0。</p>
<p>通过图形界面配置主节点的IP与端口，配置完成后会创建一个服务，使用以下命令进行配置文件验证：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:&#62; icinga2.exe daemon -C</span><br></pre></td></tr></table></figure>
<p>配置完成远程节点后，你可以在主节点使用以下命令发现节点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># icinga2 node list&#10;Node &#39;icinga2-node2.localdomain&#39; (last seen: Mon Feb  9 16:58:21 2015)&#10;    * Host &#39;icinga2-node2.localdomain&#39;&#10;        * Service &#39;ping4&#39;&#10;        * Service &#39;ping6&#39;&#10;        * Service &#39;ssh&#39;&#10;        * Service &#39;http&#39;&#10;        * Service &#39;disk&#39;&#10;        * Service &#39;disk /&#39;&#10;        * Service &#39;icinga&#39;&#10;        * Service &#39;load&#39;&#10;        * Service &#39;procs&#39;&#10;        * Service &#39;swap&#39;&#10;        * Service &#39;users&#39;</span><br></pre></td></tr></table></figure>
<p>如果未发现你配置的节点，请确保远程节点重启过。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Icinga2可以通过Agent来监控其它设备，这些设备包含各种操作系统的服务器以及网络设备。一些简单的网络指标监控是不需要创建Agent的，例如ping和ssh；但是某些无法通过网络获取的指标则需要在被监测服务器创建一个监控代理来将指标返回给监控服务器。本文将介绍如何在Linux和Windows服务器上安装和配置Agent来实现多机器的监控。</p>]]>
    
    </summary>
    
      <category term="CentOS" scheme="https://www.tnidea.com/tags/CentOS/"/>
    
      <category term="Icinga Web2" scheme="https://www.tnidea.com/tags/Icinga-Web2/"/>
    
      <category term="Icinga2" scheme="https://www.tnidea.com/tags/Icinga2/"/>
    
      <category term="服务器监控" scheme="https://www.tnidea.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%91%E6%8E%A7/"/>
    
      <category term="运维" scheme="https://www.tnidea.com/categories/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Storm适配器(.Net)升级说明以及一些性能数据]]></title>
    <link href="https://www.tnidea.com/dot-net-storm-adapter-upgrade.html"/>
    <id>https://www.tnidea.com/dot-net-storm-adapter-upgrade.html</id>
    <published>2015-12-04T16:00:00.000Z</published>
    <updated>2015-12-05T12:52:05.000Z</updated>
    <content type="html"><![CDATA[<p> <a href="https://github.com/ziyunhx/storm-net-adapter" title="storm-net-adapter" target="_blank" rel="external">storm-net-adapter</a> 是一个使用C#编写的 Apache Storm 适配器；用于在 .Net 环境下开发 Storm 原生支持的拓扑，以及通过DRPC来远程跨语言使用集群计算资源。距离首次介绍已经更新了3个版本，带来了数项功能与性能的改进！下面将对改进部分进行说明。</p>
<a id="more"></a>
<p> 首先，在V1.2版本加入了对DRPC的支持；通过使用DRPC，你可以方便调用任何使用Storm支持语言编写的Topology，你仅需将它们部署到集群。详细介绍可以通过 <a href="http://www.tnidea.com/dot-net-drpc-storm.html">.NET使用DRPC远程调用运行在Storm上的拓扑</a> 和 <a href="http://www.tnidea.com/call-dot-net-drpc-program.html">使用DRPC调用.NET开发的Storm拓扑</a> 来了解。<br> 在刚刚发布的V1.4版本中，对DRPC的支持进一步增强，默认使用线程池来管理连接。在之前的版本中，单机单进程环境下，如果所有并发使用各自连接，并发100的环境下长时间运行会出现连接数过大导致失败；如果使用单连接加锁模式，在并发30的情况下延时以及在5000ms以上。通过使用线程池来控制（默认配置），在生产环境下，峰值200并发的条件下，使用外网访问DRPC的延时保持在200ms内；每日调用量保持在2500万次，单个小时调用量峰值在300万次。Storm集群使用Docker部署在单台服务器上，部署方式可以查看 <a href="http://www.tnidea.com/deploy-storm-by-docker.html">使用Docker快速部署Storm环境</a>。下面是连续10天Storm运行的截图：</p>
<p> <img src="http://www.tnidea.com/media/image/storm-run-status-1.png" alt="Storm UI"></p>
<p> <img src="http://www.tnidea.com/media/image/storm-run-status-2.png" alt="Storm Topology"></p>
<p> 当然，你也可以通过设置 reconnect 和 maxIdle 参数来决定是否使用线程池特性以及最大线程数。</p>
<p> 在V1.3版本，解决了一些在linux环境下运行的Bug，默认demo使用mono来驱动，并将Storm版本选用了0.9.6版本。</p>
<p> 在V1.4版本中，移除了项目对于Json.Net的依赖，采用SimpleJson作为替代；现在，再也不用慢慢等待Nuget的龟速了。另外，该类库支持.Net 3.5及以上；这是由于最新的Thrift并不支持.Net 3.5以下的版本，如果你需要使用更低版本的.Net，你可以从Apache Thrift官方网站下载源码修改后自行编译。</p>
<p> 好了，在未来的版本中，我们还计划增加直接通过.Net打包发布Topology的支持，如果你有什么希望增加或完善的部分，可以通过博客留言、公众号评论、GitHub或邮件与我交流！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p> <a href="https://github.com/ziyunhx/storm-net-adapter" title="storm-net-adapter">storm-net-adapter</a> 是一个使用C#编写的 Apache Storm 适配器；用于在 .Net 环境下开发 Storm 原生支持的拓扑，以及通过DRPC来远程跨语言使用集群计算资源。距离首次介绍已经更新了3个版本，带来了数项功能与性能的改进！下面将对改进部分进行说明。</p>]]>
    
    </summary>
    
      <category term=".NET" scheme="https://www.tnidea.com/tags/NET/"/>
    
      <category term="C#" scheme="https://www.tnidea.com/tags/C/"/>
    
      <category term="DRPC" scheme="https://www.tnidea.com/tags/DRPC/"/>
    
      <category term="Topology" scheme="https://www.tnidea.com/tags/Topology/"/>
    
      <category term="csharp" scheme="https://www.tnidea.com/tags/csharp/"/>
    
      <category term="storm" scheme="https://www.tnidea.com/tags/storm/"/>
    
      <category term="Storm" scheme="https://www.tnidea.com/categories/Storm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用ImitateLogin模拟登录百度]]></title>
    <link href="https://www.tnidea.com/login-baidu-throught-imitate-login.html"/>
    <id>https://www.tnidea.com/login-baidu-throught-imitate-login.html</id>
    <published>2015-11-29T16:00:00.000Z</published>
    <updated>2015-11-30T16:23:54.000Z</updated>
    <content type="html"><![CDATA[<p>在之前的文章中，我已经介绍过一个社交网站模拟登录的类库：<a href="https://github.com/ziyunhx/imitate-login" target="_blank" rel="external">imitate-login</a> ，这是一个通过c#的HttpWebRequest来模拟网站登录的库，之前实现了微博网页版和微博Wap版；现在，模拟百度登录的部分也已经完成。由于个人时间的限制，加上目前有多个项目在同时进行，因此更新频率会根据项目关注度来决定（<strong>Star &amp; fork</strong>）。</p>
 <a id="more"></a>
<p>这个类库的使用方法非常简单，仅对外提供一个方法： </p>
<p><code>LoginResult Login(1: string userName, 2: string password, 3: LoginSite loginSite);</code> </p>
<p>这个方法位于ImitateLogin的LoginHelper类中，使用之前需要先对其进行实例化。通过传入 用户名、密码以及登录的网站，返回一个包含登录结果状态、描述信息和Cookies字典的类。它通过 Thrift 来实现多语言的支持。</p>
<p>下面将通过介绍模拟百度登录的实现来介绍如何进行扩充与二次开发：</p>
<p>首先，创建百度登录类 BaiduLogin.cs 继承 ILogin 接口；实现其生成的 DoLogin 方法。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">region</span> ILogin implementation</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LoginResult <span class="title">DoLogin</span>(<span class="params"><span class="keyword">string</span> UserName, <span class="keyword">string</span> Password</span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> CookieContainer cookies &#123; <span class="keyword">set</span>; <span class="keyword">get</span>;&#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endregion</span></span></span><br></pre></td></tr></table></figure>
<p>然后我们通过监听百度登录过程中的网络请求，梳理出修改过Cookies和最终提交登录所需的参数的请求。</p>
<p>Step1: 访问以下链接生成初始Cookies：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">HttpHelper.GetHttpContent(<span class="string">"https://passport.baidu.com/passApi/html/_blank.html"</span>, cookies: cookies, cookiesDomain: <span class="string">"passport.baidu.com"</span>);</span><br></pre></td></tr></table></figure>
<p>Step2: 获取最终登录提交所需的token：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. Get the token.</span></span><br><span class="line"><span class="keyword">string</span> token_url = <span class="keyword">string</span>.Format(<span class="string">"https://passport.baidu.com/v2/api/?getapi&amp;tpl=mn&amp;apiver=v3&amp;tt=&#123;0&#125;&amp;class=login&amp;gid=&#123;1&#125;&amp;logintype=dialogLogin&amp;callback=bd__cbs__&#123;2&#125;"</span>, TimeHelper.ConvertDateTimeInt(DateTime.Now), Guid.NewGuid().ToString().ToUpper(), build_callback());</span><br><span class="line"><span class="keyword">string</span> prepareContent = HttpHelper.GetHttpContent(token_url, <span class="keyword">null</span>, cookies, referer: <span class="string">"https://www.baidu.com/"</span>, encode: Encoding.GetEncoding(<span class="string">"GB2312"</span>), cookiesDomain: <span class="string">"passport.baidu.com"</span>);</span><br><span class="line"><span class="comment">//string prepareJson = prepareContent.Split('(')[1].Split(')')[0];</span></span><br><span class="line"><span class="keyword">dynamic</span> prepareJson = JsonConvert.DeserializeObject(prepareContent.Split(<span class="string">'('</span>)[<span class="number">1</span>].Split(<span class="string">')'</span>)[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">string</span> token = prepareJson.data.token;</span><br></pre></td></tr></table></figure>
<p>其中 build_callback 为随机生成6位字母或数字的组合的方法。</p>
<p>Step3: 获取用于加密密码的publickey：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2. Get public key</span></span><br><span class="line"><span class="keyword">string</span> pubkey_url = <span class="string">"https://passport.baidu.com/v2/getpublickey?token=&#123;0&#125;&amp;tpl=mn&amp;apiver=v3&amp;tt=&#123;1&#125;&amp;gid=&#123;2&#125;&amp;callback=bd__cbs__&#123;3&#125;"</span>;</span><br><span class="line"><span class="keyword">string</span> pubkeyContent = HttpHelper.GetHttpContent(<span class="keyword">string</span>.Format(pubkey_url, token, TimeHelper.ConvertDateTimeInt(DateTime.Now), Guid.NewGuid().ToString().ToUpper(), build_callback()), <span class="keyword">null</span>, cookies, referer: <span class="string">"https://www.baidu.com/"</span>, encode: Encoding.GetEncoding(<span class="string">"GB2312"</span>), cookiesDomain: <span class="string">"passport.baidu.com"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">dynamic</span> pubkeyJson = JsonConvert.DeserializeObject(pubkeyContent.Split(<span class="string">'('</span>)[<span class="number">1</span>].Split(<span class="string">')'</span>)[<span class="number">0</span>]);</span><br><span class="line">rsa_pub_baidu = pubkeyJson.pubkey;</span><br><span class="line"><span class="keyword">string</span> KEY = pubkeyJson.key;</span><br></pre></td></tr></table></figure>
<p>Step4: 模拟执行最终的登录：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3. Build post data</span></span><br><span class="line"><span class="keyword">string</span> login_data = <span class="string">"staticpage=https%3A%2F%2Fwww.baidu.com%2Fcache%2Fuser%2Fhtml%2Fv3Jump.html&amp;charset=UTF-8&amp;token=&#123;0&#125;&amp;tpl=mn&amp;subpro=&amp;apiver=v3&amp;tt=&#123;1&#125;&amp;codestring=&amp;safeflg=0&amp;u=https%3A%2F%2Fwww.baidu.com%2F&amp;isPhone=&amp;detect=1&amp;gid=&#123;2&#125;&amp;quick_user=0&amp;logintype=dialogLogin&amp;logLoginType=pc_loginDialog&amp;idc=&amp;loginmerge=true&amp;splogin=rate&amp;username=&#123;3&#125;&amp;password=&#123;4&#125;&amp;verifycode=&amp;mem_pass=on&amp;rsakey=&#123;5&#125;&amp;crypttype=12&amp;ppui_logintime=&#123;6&#125;&amp;countrycode=&amp;callback=parent.bd__pcbs__&#123;7&#125;"</span>;</span><br><span class="line">login_data = <span class="keyword">string</span>.Format(login_data, token, TimeHelper.ConvertDateTimeInt(DateTime.Now), Guid.NewGuid().ToString().ToUpper(), HttpUtility.UrlEncode(UserName), HttpUtility.UrlEncode(get_pwa_rsa(Password)), HttpUtility.UrlEncode(KEY), stopwatch.ElapsedMilliseconds, build_callback());</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. Post the login data</span></span><br><span class="line"><span class="keyword">string</span> login_url = <span class="string">"https://passport.baidu.com/v2/api/?login"</span>;</span><br><span class="line">HttpHelper.GetHttpContent(login_url, login_data, cookies, referer: <span class="string">"https://www.baidu.com/"</span>, cookiesDomain: <span class="string">"passport.baidu.com"</span>);</span><br></pre></td></tr></table></figure>
<p>stopwatch 是一个记录从最初执行到最终提交之前的耗时的一个计时器，get_pwa_rsa 为加密密码的方法。</p>
<p>Step5：验证最终的登录结果：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span> home_url = <span class="string">"https://www.baidu.com"</span>;</span><br><span class="line"><span class="keyword">string</span> result = HttpHelper.GetHttpContent(home_url, cookies: cookies, cookiesDomain: <span class="string">"passport.baidu.com"</span>);</span><br><span class="line"><span class="comment">//5. Verifty the login result</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">string</span>.IsNullOrWhiteSpace(result) || result.Contains(<span class="string">"账号存在异常"</span>) || !result.Contains(<span class="string">"bds.comm.user=\""</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LoginResult() &#123; Result = ResultType.AccounntLimit, Msg = <span class="string">"Fail, Msg: Login fail! Maybe you account is disable or captcha is needed."</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step6：创建返回结果类：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">LoginResult loginResult = <span class="keyword">new</span> LoginResult() &#123; Result = ResultType.Success, Msg = <span class="string">"Success"</span>, Cookies = HttpHelper.GetAllCookies(cookies) &#125;;</span><br></pre></td></tr></table></figure>
<p>至此，模拟登录部分的代码就完成了，为了能够被其它程序调用，你还需要在 LoginSite 的枚举中新增一条来标识这个登录方法，此处增加了一个 Baidu = 5，并设置 [Description(“Baidu”)]。</p>
<p>然后在 LoginHelper.cs 的 Login 方法中的 switch (loginSite) 里增加一个 case：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> LoginSite.Baidu:</span><br><span class="line">    LoginClass = <span class="keyword">new</span> BaiduLogin ();</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>好了，大功告成！Todo List中还有淘宝、QQ、Facebook、Twitter、Google要做呢，我还想加入GitHub、Wechat…<br>现在，你可以帮我了吗？</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在之前的文章中，我已经介绍过一个社交网站模拟登录的类库：<a href="https://github.com/ziyunhx/imitate-login">imitate-login</a> ，这是一个通过c#的HttpWebRequest来模拟网站登录的库，之前实现了微博网页版和微博Wap版；现在，模拟百度登录的部分也已经完成。由于个人时间的限制，加上目前有多个项目在同时进行，因此更新频率会根据项目关注度来决定（<strong>Star &amp; fork</strong>）。</p>]]>
    
    </summary>
    
      <category term=".NET" scheme="https://www.tnidea.com/tags/NET/"/>
    
      <category term="Baidu" scheme="https://www.tnidea.com/tags/Baidu/"/>
    
      <category term="C#" scheme="https://www.tnidea.com/tags/C/"/>
    
      <category term="csharp" scheme="https://www.tnidea.com/tags/csharp/"/>
    
      <category term="social network" scheme="https://www.tnidea.com/tags/social-network/"/>
    
      <category term="thrift" scheme="https://www.tnidea.com/tags/thrift/"/>
    
      <category term="爬虫" scheme="https://www.tnidea.com/categories/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Docker快速部署Storm环境]]></title>
    <link href="https://www.tnidea.com/deploy-storm-by-docker.html"/>
    <id>https://www.tnidea.com/deploy-storm-by-docker.html</id>
    <published>2015-11-17T16:00:00.000Z</published>
    <updated>2015-11-18T13:34:33.000Z</updated>
    <content type="html"><![CDATA[<p>Storm的部署虽然不是特别麻烦，但是在生产环境中，为了提高部署效率，方便管理维护，使用Docker来统一管理部署是一个不错的选择。下面是我开源的一个新的项目，一个配置好了storm与mono环境的Docker镜像编排：<a href="https://github.com/ziyunhx/storm-mono-docker" target="_blank" rel="external">storm-mono-docker</a>。</p>
<a id="more"></a>
<p>这个项目得益于<a href="https://github.com/ptgoetz/storm-vagrant" target="_blank" rel="external">https://github.com/ptgoetz/storm-vagrant</a>和<a href="https://github.com/wurstmeister/storm-docker" target="_blank" rel="external">https://github.com/wurstmeister/storm-docker</a>；在此感谢他们的付出！<br>项目使用的Docker镜像托管在 <a href="https://index.docker.io" target="_blank" rel="external">https://index.docker.io</a>。</p>
<h2 id="准备工作">准备工作</h2><ul>
<li><p>安装 Docker Engine，<a href="https://docs.docker.com/" target="_blank" rel="external">https://docs.docker.com/</a></p>
</li>
<li><p>安装 docker-compose <a href="http://docs.docker.com/compose/install/" target="_blank" rel="external">http://docs.docker.com/compose/install/</a></p>
</li>
<li><p>克隆git项目： </p>
<pre><code>git clone <span class="string">https:</span><span class="comment">//github.com/ziyunhx/storm-mono-docker</span>
</code></pre></li>
</ul>
<h2 id="使用">使用</h2><p>首先将命令行目录切换到刚刚克隆下来的git项目目录；</p>
<p>通过以下命令启动集群：</p>
<pre><code>docker-compose up <span class="operator">-d</span>
</code></pre><ul>
<li>你也可以使用 docker-compose up 命令来将结果输出到当前命令行界面，但是在你结束它之前无法进行任何其它操作，而一旦命令行退出，所有的容器都将停止。而 docker-compose up -d 将在后台启动所有容器。</li>
</ul>
<p>停止这个集群的所有容器：</p>
<pre><code>docker-compose <span class="keyword">stop</span>
</code></pre><p>容器一旦停止，下次直接启动将无法正常链接容器，导致storm运行异常，你可以在结束后使用以下命令结束和移除所有的Docker缓存：</p>
<pre><code>docker kill $<span class="comment">(docker ps -q)</span> ; docker rm $<span class="comment">(docker ps -a -q)</span>
</code></pre><p>增加更多的supervisors：</p>
<pre><code>docker-compose scale supervisor=<span class="number">4</span>
</code></pre><p>使用以下命令删除所有的镜像文件（小心，这会让你下一次启动时花费更多时间下载容器，仅在不想继续使用时执行）：</p>
<pre><code>docker rmi $<span class="comment">(docker images -q -a)</span>
</code></pre><h2 id="重新构建和更新">重新构建和更新</h2><p>你可以在修改Dockerfile后使用以下命令来重新构建镜像：rebuild.sh ；</p>
<p>使用以下命令来更新镜像到最新版本：refresh.sh 。</p>
<h2 id="问与答">问与答</h2><h3 id="如何访问Storm_UI来查看运行状况？">如何访问Storm UI来查看运行状况？</h3><p>在docker-compose.yml中有下面这段配置：</p>
<pre><code><span class="attribute">ui</span>:
  <span class="attribute">image</span>: ziyunhx/storm-ui
      <span class="attribute">ports</span>:
        - <span class="string">"49080:8080"</span>
</code></pre><p>它告诉我们将Docker镜像的8080端口映射到了主机的49080，因此你可以通过访问 <a href="http://localhost:49080" target="_blank" rel="external">http://localhost:49080</a> 来访问。如果你使用 boot2docker ，你可以通过以下命令得到虚拟机的IP：</p>
<pre><code>$ <span class="keyword">boot2docker </span><span class="literal">ip</span>
<span class="label">The</span> VM<span class="string">'s Host only interface IP address is: 192.168.59.103</span>
</code></pre><p>返回的结果就是你的IP，本例中可以通过 <a href="http://192.168.59.103:49080" target="_blank" rel="external">http://192.168.59.103:49080</a> 来访问。</p>
<h3 id="如何部署提交一个topology？">如何部署提交一个topology？</h3><p>如果 nimbus 的IP与端口不是默认的，你需要指定它们后来提交，本例中可以使用以下命令：</p>
<pre><code>storm jar target/your-topology-fat-jar<span class="class">.jar</span> com<span class="class">.your</span><span class="class">.package</span><span class="class">.AndTopology</span> topology-name -c nimbus.host=<span class="number">192.168</span>.<span class="number">59.103</span> -c nimbus<span class="class">.thrift</span><span class="class">.port</span>=<span class="number">49627</span>
</code></pre><p>如果上述命令没有起作用，你可以在本地的Storm配置文件（storm.yaml）配置以下项：</p>
<pre><code>nimbus<span class="class">.host</span>: <span class="string">"192.168.59.103"</span>    
nimbus<span class="class">.thrift</span><span class="class">.port</span>: <span class="number">49627</span>
</code></pre><p>然后执行以下命令提交：</p>
<pre><code>storm jar target/your-topology-fat-jar<span class="class">.jar</span> com<span class="class">.your</span><span class="class">.package</span><span class="class">.AndTopology</span> topology-name
</code></pre><h3 id="如何连接我的容器?">如何连接我的容器?</h3><p>通过使用 docker-compose ps 找到你希望连接的容器的ssh端口，然后通过ssh连接：</p>
<pre><code>$ ssh root@`boot2docker ip` -p <span class="variable">$CONTAINER</span>_PORT
</code></pre><p>密码是 ‘ziyunhxpass’ （位于：<a href="https://registry.hub.docker.com/u/ziyunhx/base/dockerfile/）。" target="_blank" rel="external">https://registry.hub.docker.com/u/ziyunhx/base/dockerfile/）。</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Storm的部署虽然不是特别麻烦，但是在生产环境中，为了提高部署效率，方便管理维护，使用Docker来统一管理部署是一个不错的选择。下面是我开源的一个新的项目，一个配置好了storm与mono环境的Docker镜像编排：<a href="https://github.com/ziyunhx/storm-mono-docker">storm-mono-docker</a>。</p>]]>
    
    </summary>
    
      <category term=".NET" scheme="https://www.tnidea.com/tags/NET/"/>
    
      <category term="C#" scheme="https://www.tnidea.com/tags/C/"/>
    
      <category term="Docker" scheme="https://www.tnidea.com/tags/Docker/"/>
    
      <category term="csharp" scheme="https://www.tnidea.com/tags/csharp/"/>
    
      <category term="mono" scheme="https://www.tnidea.com/tags/mono/"/>
    
      <category term="storm" scheme="https://www.tnidea.com/tags/storm/"/>
    
      <category term="Storm" scheme="https://www.tnidea.com/categories/Storm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[安装与配置Icinga Web2]]></title>
    <link href="https://www.tnidea.com/setting-up-icinga-web2.html"/>
    <id>https://www.tnidea.com/setting-up-icinga-web2.html</id>
    <published>2015-10-29T16:00:00.000Z</published>
    <updated>2015-10-29T15:03:56.000Z</updated>
    <content type="html"><![CDATA[<p>Icinga Web2是Icinga2的Web前端展示界面之一，它也是支持Icinga2的Web界面中我个人最喜欢的。通过Icinga Web2，你可以方便的展示与管理你的监控，也可以自定义一些显示模块。本文将介绍Icinga Web2的安装与配置，其中部分经验可能在Icinga2的其它Web界面也适用。</p>
<a id="more"></a>
<h3 id="设置包管理库">设置包管理库</h3><p>你需要使用以下命令将Icinga2的所在的包管理库加入到你的系统中，如果你按照我之前的文章操作的话，其实这步已经做过了。</p>
<p>Debian (debmon):</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -O - http://debmon.org/debmon/repo.key 2&#62;/dev/null | apt-key add -&#10;echo &#39;deb http://debmon.org/debmon debmon-wheezy main&#39; &#62;/etc/apt/sources.list.d/debmon.list&#10;apt-get update</span><br></pre></td></tr></table></figure>
<p>Ubuntu Trusty:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -O - http://packages.icinga.org/icinga.key | apt-key add -&#10;add-apt-repository &#39;deb http://packages.icinga.org/ubuntu icinga-trusty main&#39;&#10;apt-get update</span><br></pre></td></tr></table></figure>
<p>如果你使用的是其它的Ubuntu版本，只需要将trusty替换成你实际环境的名字。</p>
<p>RHEL 和 CentOS:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm --import http://packages.icinga.org/icinga.key&#10;curl -o /etc/yum.repos.d/ICINGA-release.repo http://packages.icinga.org/epel/ICINGA-release.repo&#10;yum makecache</span><br></pre></td></tr></table></figure>
<p>Fedora:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm --import http://packages.icinga.org/icinga.key&#10;curl -o /etc/yum.repos.d/ICINGA-release.repo http://packages.icinga.org/fedora/ICINGA-release.repo&#10;yum makecache</span><br></pre></td></tr></table></figure>
<p>SLES 11:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zypper ar http://packages.icinga.org/SUSE/ICINGA-release-11.repo&#10;zypper ref</span><br></pre></td></tr></table></figure>
<p>SLES 12:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zypper ar http://packages.icinga.org/SUSE/ICINGA-release.repo&#10;zypper ref</span><br></pre></td></tr></table></figure>
<p>openSUSE:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zypper ar http://packages.icinga.org/openSUSE/ICINGA-release.repo&#10;zypper ref</span><br></pre></td></tr></table></figure>
<p>RHEL/CentOS的软件包依赖于EPEL，确保你已经配置了它！这步应该在安装Icinga2时已经完成。<br>Debian wheezy的软件包依赖于wheezy-packports库，请在安装前启用它。</p>
<h3 id="安装_Icinga_Web2">安装 Icinga Web2</h3><p>你可以通过系统的包管理器来安装Icinga Web2，下面是一些系统的具体命令：</p>
<p>Debian 和 Ubuntu:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install icingaweb2</span><br></pre></td></tr></table></figure>
<p>RHEL, CentOS 和 Fedora:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install icingaweb2 icingacli</span><br></pre></td></tr></table></figure>
<p>Debian wheezy/RHEL/CentOS用户请仔细阅读包管理库的提示。</p>
<p>SLES 和 openSUSE:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zypper install icingaweb2 icingacli</span><br></pre></td></tr></table></figure>
<h3 id="配置Icinga_Web2">配置Icinga Web2</h3><p>你可以通过Icinga Web2配置向导，或者直接通过执行命令来完成配置，本文仅介绍通过配置向导来完成配置，如果需要使用命令行来完成，请查看 Icinga Web 2官方文档。</p>
<p>STEP 1: 通过icingacli创建一个token，用来安装Icinga Web2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">icingacli setup token create&#10;icingacli setup token show</span><br></pre></td></tr></table></figure>
<p>STEP 2: 使用浏览器访问 <a href="http://127.0.0.1/icingaweb2/setup" target="_blank" rel="external">http://127.0.0.1/icingaweb2/setup</a> （将IP替换为实际IP或域名），将上一步命令行得到的token输入到Steup Token的输入框中，继续下一步。</p>
<p> <img src="http://www.tnidea.com/media/image/icinga-websetup-1.png" alt="Image"></p>
<p>STEP 3: 根据需要选择需要安装的模块，我这边选择了除翻译外的所有模块。</p>
<p> <img src="http://www.tnidea.com/media/image/icinga-websetup-2.png" alt="Image"></p>
<p>STEP 4: 根据系统检查结果，解决需要修改的项，全部完成后刷新确认。</p>
<p> <img src="http://www.tnidea.com/media/image/icinga-websetup-3.png" alt="Image"></p>
<p>本例中，需要解决的有PHP时区，LDAP，PDO-MySQL，PDO-PostgreSQL问题。PDO-MySQL，PDO-PostgreSQL只需要重启Web服务器即可解决。</p>
<p>修改PHP时区：<br><code>使用 vi 打开 /etc/php.ini；查找 date.timezone，删除最前面的分号，在结尾增加时区标签，这里使用： Asia/Shanghai 。</code></p>
<p>启用LDAP：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install php-ldap</span><br></pre></td></tr></table></figure></p>
<p>重启Web服务器，CentOS 7直接使用 systemctl restart httpd 重启。<br>现在界面上所有的状态应该都已经变成了绿色，继续下一步吧，后面没有特别讲到的步骤都是直接点击下一步的！</p>
<p>STEP 5: 配置Icinga Web2数据库</p>
<p> <img src="http://www.tnidea.com/media/image/icinga-websetup-4.png" alt="Image"></p>
<p>此处直接填写我们创建的icingaweb2数据库的信息，默认情况下用户名和密码都是icingaweb2。由于我们并没有给予icingaweb2用户创建表的权限，因此你还需要给一个有创建数据库和表权限的用户。</p>
<p><img src="http://www.tnidea.com/media/image/icinga-websetup-5.png" alt="Image"></p>
<p>STEP 6: 创建一个Icinga Web2的管理员账号</p>
<p><img src="http://www.tnidea.com/media/image/icinga-websetup-6.png" alt="Image"></p>
<p>STEP 7: 配置Icinga IDO数据库信息</p>
<p><img src="http://www.tnidea.com/media/image/icinga-websetup-7.png" alt="Image"></p>
<p>此处直接填写我们创建的icinga数据库的信息，默认情况下用户名和密码都是icinga。</p>
<p>ok! 一切就绪，登陆进去瞅瞅吧！</p>
<p><img src="http://www.tnidea.com/media/image/icinga-websetup-8.png" alt="Image"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Icinga Web2是Icinga2的Web前端展示界面之一，它也是支持Icinga2的Web界面中我个人最喜欢的。通过Icinga Web2，你可以方便的展示与管理你的监控，也可以自定义一些显示模块。本文将介绍Icinga Web2的安装与配置，其中部分经验可能在Icinga2的其它Web界面也适用。</p>]]>
    
    </summary>
    
      <category term="CentOS" scheme="https://www.tnidea.com/tags/CentOS/"/>
    
      <category term="Icinga Web2" scheme="https://www.tnidea.com/tags/Icinga-Web2/"/>
    
      <category term="Icinga2" scheme="https://www.tnidea.com/tags/Icinga2/"/>
    
      <category term="服务器监控" scheme="https://www.tnidea.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%91%E6%8E%A7/"/>
    
      <category term="运维" scheme="https://www.tnidea.com/categories/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[安装Icinga Web2所需服务]]></title>
    <link href="https://www.tnidea.com/prepare-for-setting-up-icinga-web2.html"/>
    <id>https://www.tnidea.com/prepare-for-setting-up-icinga-web2.html</id>
    <published>2015-10-24T16:00:00.000Z</published>
    <updated>2015-10-29T13:01:55.000Z</updated>
    <content type="html"><![CDATA[<p>Icinga Web2是Icinga2的Web前端展示界面之一，它也是支持Icinga2的Web界面中我个人最喜欢的。通过Icinga Web2，你可以方便的展示与管理你的监控，也可以自定义一些显示模块。本文将介绍Icinga Web2的安装与配置，其中部分经验可能在Icinga2的其它Web界面也适用。</p>
<a id="more"></a>
<p>Icinga2通过DB IDO模块将所有配置与状态信息都保存在一个数据库中，这些数据会被Icinga Web2，Icinga Reporting或Icinga Web 1.x使用。</p>
<p>目前Icinga2支持使用MySQL和PostgreSQL作为后端数据库，本文仅介绍MySQL作为后端数据库的情况，如果你使用PostgreSQL，请依据官方文档配置好PostgreSQL。</p>
<h3 id="安装MySQL数据库服务">安装MySQL数据库服务</h3><p>Debian/Ubuntu:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ apt-get install mysql-server mysql-client</span><br></pre></td></tr></table></figure>
<p>RHEL/CentOS 5/6:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ yum install mysql-server mysql&#10;$ chkconfig mysqld on&#10;$ service mysqld start&#10;$ mysql_secure_installation</span><br></pre></td></tr></table></figure>
<p>RHEL/CentOS 7 和 Fedora:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ yum install mariadb-server mariadb&#10;$ systemctl enable mariadb&#10;$ systemctl start mariadb&#10;$ mysql_secure_installation</span><br></pre></td></tr></table></figure>
<p>SUSE:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ zypper install mysql mysql-client&#10;$ chkconfig mysqld on&#10;$ service mysqld start</span><br></pre></td></tr></table></figure>
<p>FreeBSD:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pkg install mysql56-server&#10;$ sysrc mysql_enable=yes&#10;$ service mysql-server restart&#10;$ mysql_secure_installation</span><br></pre></td></tr></table></figure>
<h3 id="安装MySQL的IDO模块">安装MySQL的IDO模块</h3><p>通过默认的包管理器安装icinga2-ido-mysql包：</p>
<p>Debian/Ubuntu:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ apt-get install icinga2-ido-mysql</span><br></pre></td></tr></table></figure>
<p>RHEL/CentOS:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ yum install icinga2-ido-mysql</span><br></pre></td></tr></table></figure>
<p>SUSE:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ zypper install icinga2-ido-mysql</span><br></pre></td></tr></table></figure>
<p>FreeBSD:</p>
<p>FreeBSD的MySQL IDO模块已经包含在icinga2包中，位于 /usr/local/share/icinga2-ido-mysql/schema/mysql.sql。</p>
<p>注意：Debian/Ubuntu的包中提供了一个数据库配置向导，你可以根据个人喜好来选择是否使用它。</p>
<h3 id="设置MySQL数据库">设置MySQL数据库</h3><p>为Icinga 2设置一个MySQL数据库:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mysql -u root -p&#10;&#10;mysql&#62;  CREATE DATABASE icinga;&#10;        GRANT SELECT, INSERT, UPDATE, DELETE, DROP, CREATE VIEW, INDEX, EXECUTE ON icinga.* TO &#39;icinga&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;icinga&#39;;</span><br></pre></td></tr></table></figure>
<p>在创建数据库完成后，使用以下命令导入Icinga2 IDO数据库结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mysql -u root -p icinga &#60; /usr/share/icinga2-ido-mysql/schema/mysql.sql</span><br></pre></td></tr></table></figure>
<p>为了使用Icinga Web2，我们为Icinga Web2也创建一个空的数据库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mysql -u root -p&#10;&#10;mysql&#62;  CREATE DATABASE icingaweb2;&#10;        GRANT SELECT, INSERT, UPDATE, DELETE, DROP, CREATE VIEW, INDEX, EXECUTE ON icingaweb2.* TO &#39;icingaweb2&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;icingaweb2&#39;;&#10;        quit</span><br></pre></td></tr></table></figure>
<p>启用MySQL IDO模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ icinga2 feature enable ido-mysql</span><br></pre></td></tr></table></figure>
<p>启用后别忘了重启Icinga2服务：</p>
<p>Debian/Ubuntu, RHEL/CentOS 6 和 SUSE:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ service icinga2 restart</span><br></pre></td></tr></table></figure>
<p>RHEL/CentOS 7 和 Fedora:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ systemctl restart icinga2</span><br></pre></td></tr></table></figure>
<p>FreeBSD:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ service icinga2 restart</span><br></pre></td></tr></table></figure>
<h3 id="安装Web服务">安装Web服务</h3><p>Debian/Ubuntu:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ apt-get install apache2</span><br></pre></td></tr></table></figure>
<p>RHEL/CentOS 6:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ yum install httpd&#10;$ chkconfig httpd on&#10;$ service httpd start</span><br></pre></td></tr></table></figure>
<p>RHEL/CentOS 7/Fedora:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ yum install httpd&#10;$ systemctl enable httpd&#10;$ systemctl start httpd</span><br></pre></td></tr></table></figure>
<p>SUSE:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ zypper install apache2&#10;$ chkconfig on&#10;$ service apache2 start</span><br></pre></td></tr></table></figure>
<p>FreeBSD (nginx，你也可以使用 apache24 来作为Web服务)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pkg install nginx php56-gettext php56-ldap php56-openssl php56-mysql php56-pdo_mysql php56-pgsql php56-pdo_pgsql php56-sockets php56-gd pecl-imagick pecl-intl&#10;$ sysrc php_fpm_enable=yes&#10;$ sysrc nginx_enable=yes&#10;$ sed -i &#39;&#39; &#34;s/listen\ =\ 127.0.0.1:9000/listen\ =\ \/var\/run\/php5-fpm.sock/&#34; /usr/local/etc/php-fpm.conf&#10;$ sed -i &#39;&#39; &#34;s/;listen.owner/listen.owner/&#34; /usr/local/etc/php-fpm.conf&#10;$ sed -i &#39;&#39; &#34;s/;listen.group/listen.group/&#34; /usr/local/etc/php-fpm.conf&#10;$ sed -i &#39;&#39; &#34;s/;listen.mode/listen.mode/&#34; /usr/local/etc/php-fpm.conf&#10;$ service php-fpm start&#10;$ service nginx start</span><br></pre></td></tr></table></figure>
<h3 id="配置防火墙规则">配置防火墙规则</h3><p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ iptables -A INPUT -p tcp -m tcp --dport 80 -j ACCEPT&#10;$ service iptables save</span><br></pre></td></tr></table></figure>
<p>RHEL/CentOS 7 使用下面命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ firewall-cmd --add-service=http&#10;$ firewall-cmd --permanent --add-service=http</span><br></pre></td></tr></table></figure>
<h3 id="配置额外的命令通道">配置额外的命令通道</h3><p>Web接口和一些其它模块通过额外的命令通道来向Icinga2发送命令，你可以使用下面的命令启用它： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ icinga2 feature enable command</span><br></pre></td></tr></table></figure>
<p>同样，你需要重启Icinga2服务来使它生效。</p>
<p>默认情况下，icingacmd用户组拥有读写命令通道文件的权限，因此你需要使用下面的命令将Web服务的用户加入到该组：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ usermod -a -G icingacmd www-data</span><br></pre></td></tr></table></figure>
<p>FreeBSD: www用户组拥有文件的读写权限，你不需要额外操作什么。</p>
<p>Debian包使用nagios作为默认用户名和用户组，因此你需要将上述命令中的icingacmd修改为nagios。</p>
<p>Web服务的用户名在不同的环境下是不同的，因此你可以尝试修改www-data为wwwrun、www、或者 apache。</p>
<p>你可以使用以下命令来检测是否成功将用户加入到icingacmd用户组：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ id &#60;your-webserver-user&#62;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>Icinga Web2是Icinga2的Web前端展示界面之一，它也是支持Icinga2的Web界面中我个人最喜欢的。通过Icinga Web2，你可以方便的展示与管理你的监控，也可以自定义一些显示模块。本文将介绍Icinga Web2的安装与配置，其中部分经验可能在Icinga2的其它Web界面也适用。</p>]]>
    
    </summary>
    
      <category term="CentOS" scheme="https://www.tnidea.com/tags/CentOS/"/>
    
      <category term="Icinga Web2" scheme="https://www.tnidea.com/tags/Icinga-Web2/"/>
    
      <category term="Icinga2" scheme="https://www.tnidea.com/tags/Icinga2/"/>
    
      <category term="服务器监控" scheme="https://www.tnidea.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%91%E6%8E%A7/"/>
    
      <category term="运维" scheme="https://www.tnidea.com/categories/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Icinga2和Icinga Web2搭建监控服务]]></title>
    <link href="https://www.tnidea.com/monitor-system-by-icinga2.html"/>
    <id>https://www.tnidea.com/monitor-system-by-icinga2.html</id>
    <published>2015-10-09T16:00:00.000Z</published>
    <updated>2015-10-11T16:00:41.000Z</updated>
    <content type="html"><![CDATA[<p>监控是系统运维的基础，Icinga是一个开源的监控系统框架，通过其广泛的插件支持，你可以监控几乎任何你能想到的网络资源；也可以在超过临界值时给予通知，根据监控数据生产报表。本文主要介绍其搭建过程，大部分内容翻译自官方文档。</p>
<a id="more"></a>
<p>在使用Icinga2前，我们曾经自己编写过监控框架，也用过其它的类似监控系统和在线服务。功能都大同小异，现在之所以选择Icinga2 + Icinga Web2来构建整个系统的监控平台主要是由于其高度可自定义性以及广泛的插件。但是由于该版本发布时间比较短，国内少有将最新版本用于生产环境，导致文档较少，很多问题需要自行摸索。写这个系列文章也是想将自己遇到的坑列出来让其它人少走弯路。</p>
<p>下面将介绍Icinga2与Icinga Web2的安装，所有的操作步骤均仅在CentOS 7上验证（特殊说明的除外），不保证其它系统下的完备性。</p>
<h2 id="安装Icinga2">安装Icinga2</h2><h3 id="设置Icinga2安装源">设置Icinga2安装源</h3><p>首先你要根据你的系统选择执行下面的命令将Icinga2的项目库地址加入到包管理中。</p>
<p>Debian (debmon):</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ wget -O - http://debmon.org/debmon/repo.key 2&#62;/dev/null | apt-key add -&#10;$ echo &#39;deb http://debmon.org/debmon debmon-jessie main&#39; &#62;/etc/apt/sources.list.d/debmon.list&#10;$ apt-get update</span><br></pre></td></tr></table></figure>
<p>Ubuntu (PPA):</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ add-apt-repository ppa:formorer/icinga&#10;$ apt-get update</span><br></pre></td></tr></table></figure>
<p>RHEL/CentOS:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ rpm --import http://packages.icinga.org/icinga.key&#10;$ curl -o /etc/yum.repos.d/ICINGA-release.repo http://packages.icinga.org/epel/ICINGA-release.repo&#10;$ yum makecache</span><br></pre></td></tr></table></figure>
<ul>
<li>这个软件包依赖于<a href="http://fedoraproject.org/wiki/EPEL" title="EPEL" target="_blank" rel="external">EPEL库</a>中的其它软件包，请确保以及允许了<a href="http://fedoraproject.org/wiki/EPEL" title="EPEL" target="_blank" rel="external">EPEL库</a>。CentOS 7可以直接通过以下命令来安装：$ yum install epel-release</li>
</ul>
<p>Fedora:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ rpm --import http://packages.icinga.org/icinga.key&#10;$ curl -o /etc/yum.repos.d/ICINGA-release.repo http://packages.icinga.org/fedora/ICINGA-release.repo&#10;$ yum makecache</span><br></pre></td></tr></table></figure>
<p>SLES 11:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ zypper ar http://packages.icinga.org/SUSE/ICINGA-release-11.repo&#10;$ zypper ref</span><br></pre></td></tr></table></figure>
<ul>
<li>这个软件包依赖于openssl1，它是SLES 11安全模块的一部分。</li>
</ul>
<p>SLES 12:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ zypper ar http://packages.icinga.org/SUSE/ICINGA-release.repo&#10;$ zypper ref</span><br></pre></td></tr></table></figure>
<p>openSUSE:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ zypper ar http://packages.icinga.org/openSUSE/ICINGA-release.repo&#10;$ zypper ref</span><br></pre></td></tr></table></figure>
<h3 id="安装Icinga2-1">安装Icinga2</h3><p>Debian/Ubuntu:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ apt-get install icinga2</span><br></pre></td></tr></table></figure>
<p>RHEL/CentOS 5/6:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ yum install icinga2&#10;$ chkconfig icinga2 on&#10;$ service icinga2 start</span><br></pre></td></tr></table></figure>
<p>RHEL/CentOS 7 和 Fedora:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ yum install icinga2&#10;$ systemctl enable icinga2&#10;$ systemctl start icinga2</span><br></pre></td></tr></table></figure>
<p>SLES/openSUSE:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ zypper install icinga2</span><br></pre></td></tr></table></figure>
<h3 id="在安装过程中启用功能">在安装过程中启用功能</h3><p>在默认安装中，启用了checker mainlog notification这三个功能，你可以通过执行以下命令来获取当前开启和关闭的所有功能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ icinga2 feature list</span><br></pre></td></tr></table></figure>
<p>如果你希望开启或关闭某个功能，可以enable/disable命令，例如我们现在开启command功能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ icinga2 feature enable command</span><br></pre></td></tr></table></figure>
<ul>
<li>如果你启用了某个功能导致在接下来的启动过程中出现错误，记得回来关闭掉！</li>
</ul>
<h3 id="文件默认位置">文件默认位置</h3><table>
<thead>
<tr>
<th>路径</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>/etc/icinga2</td>
<td>包含Icinga2所有的配置文件</td>
</tr>
<tr>
<td>/etc/init.d/icinga2</td>
<td>Icinga2的启动脚本</td>
</tr>
<tr>
<td>/usr/sbin/icinga2</td>
<td>Icinga2程序目录</td>
</tr>
<tr>
<td>/usr/share/doc/icinga2</td>
<td>Icinga2的文档目录</td>
</tr>
<tr>
<td>/usr/share/icinga2/include</td>
<td>模板库和插件命令配置</td>
</tr>
<tr>
<td>/var/run/icinga2</td>
<td>程序运行PID文件</td>
</tr>
<tr>
<td>/var/run/icinga2/cmd</td>
<td>命令通道和状态套接字</td>
</tr>
<tr>
<td>/var/cache/icinga2</td>
<td>缓存、调试、状态文件</td>
</tr>
<tr>
<td>/var/spool/icinga2</td>
<td>用于性能数据脱机文件</td>
</tr>
<tr>
<td>/var/lib/icinga2</td>
<td>状态文件，集群日志，本地证书和配置文件</td>
</tr>
<tr>
<td>/var/log/icinga2</td>
<td>CompatLogger功能产生的日志文件以及相关工具目录</td>
</tr>
</tbody>
</table>
<h2 id="安装Check插件">安装Check插件</h2><p>Icinga2只是一个监控框架，如果没有插件，它将不知道如何检查外部服务。Icinga2是从nagios发展而来，因此它兼容nagios的插件。你可以直接使用包管理工具来安装插件包，下表将列出插件包得名称和默认安装路径。</p>
<table>
<thead>
<tr>
<th>操作系统</th>
<th>包名称</th>
<th>安装路径</th>
</tr>
</thead>
<tbody>
<tr>
<td>RHEL/CentOS (EPEL)</td>
<td>nagios-plugins-all</td>
<td>/usr/lib/nagios/plugins 或 /usr/lib64/nagios/plugins</td>
</tr>
<tr>
<td>Debian</td>
<td>nagios-plugins</td>
<td>/usr/lib/nagios/plugins</td>
</tr>
<tr>
<td>FreeBSD</td>
<td>nagios-plugins</td>
<td>/usr/local/libexec/nagios</td>
</tr>
<tr>
<td>OS X (MacPorts)</td>
<td>nagios-plugins</td>
<td>/opt/local/libexec</td>
</tr>
</tbody>
</table>
<p>根据安装目录的差异，你可能需要修改Icinga2的配置来指定插件包得安装位置。配置文件为 /etc/icinga2/constants.conf，修改PluginDir的值为插件目录即可。</p>
<h2 id="运行Icinga2">运行Icinga2</h2><h3 id="启动脚本">启动脚本</h3><p>根据上面的文件位置表格，我们知道Icinga2的默认启动脚本位于： /etc/init.d/icinga2。</p>
<p>具体命令使用格式为 /etc/init.d/icinga2 {start|stop|restart|reload|checkconfig|status} ；命令具体含义与一般服务相同。</p>
<p>对于部分操作系统，例如：Fedora，openSUSE 和 RHEL/CentOS 7 可以使用服务来操作，Icinga2在安装时已经安装了必要的服务。</p>
<p>例如你可以使用以下命令来检查Icinga2的运行状态：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ systemctl status icinga2</span><br></pre></td></tr></table></figure>
<p>将Icinga2设置为自启动：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ systemctl enable icinga2</span><br></pre></td></tr></table></figure>
<p>以及重启Icinga2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ systemctl restart icinga2</span><br></pre></td></tr></table></figure>
<p>如果启动出错，别忘了检查插件以及配置文件，你也可以使用 journalctl -xn 来查看错误信息。由于篇幅过长，Icinga Web2的安装与配置将放到下篇博客中！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>监控是系统运维的基础，Icinga是一个开源的监控系统框架，通过其广泛的插件支持，你可以监控几乎任何你能想到的网络资源；也可以在超过临界值时给予通知，根据监控数据生产报表。本文主要介绍其搭建过程，大部分内容翻译自官方文档。</p>]]>
    
    </summary>
    
      <category term="CentOS" scheme="https://www.tnidea.com/tags/CentOS/"/>
    
      <category term="Icinga Web2" scheme="https://www.tnidea.com/tags/Icinga-Web2/"/>
    
      <category term="Icinga2" scheme="https://www.tnidea.com/tags/Icinga2/"/>
    
      <category term="服务器监控" scheme="https://www.tnidea.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%91%E6%8E%A7/"/>
    
      <category term="运维" scheme="https://www.tnidea.com/categories/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用DRPC调用.NET开发的Storm拓扑]]></title>
    <link href="https://www.tnidea.com/call-dot-net-drpc-program.html"/>
    <id>https://www.tnidea.com/call-dot-net-drpc-program.html</id>
    <published>2015-09-11T16:00:00.000Z</published>
    <updated>2015-10-29T13:01:55.000Z</updated>
    <content type="html"><![CDATA[<p> 在上一篇文章里介绍了.Net版本的DRPC的类库，结尾处的例子使用了Java版 BasicDRPCTopology ，本文我将介绍如何使用C#来开发 Storm Topology 并供远程DRPC调用，这篇文章将作为.Net Storm系列文章的一个暂时的结束，新的文章将随着 <a href="https://github.com/ziyunhx/storm-net-adapter" title="storm-net-adapter" target="_blank" rel="external">storm-net-adapter</a> 新特性来更新!</p>
<a id="more"></a>
<p> 在开始介绍具体代码之前，我们先回顾一下DRPC的数据流图：</p>
<p> <img src="http://www.tnidea.com/media/image/drpc-workflow.png" alt="DRPC-workflow"></p>
<p> 从图中可以看到，DRPC实际上并不会影响的具体的业务逻辑代码的编写，只是在传入参数中增加了一个 request-id 用于辨别任务，在结束时增加了一个 return-info 用来返回结果。那么，在Bolt的编写中，我们为每一个Bolt的输入输出增加一个 id 参数来标识任务，在结束时额外增加一个返回结果的参数。我们还是写一个简单的字符操作的例子。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Storm;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">StormSample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SimpleDRPC</span> : <span class="title">IBolt</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> Context ctx;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span>  Implements of delegate "newPlugin", which is used to create a instance of this spout/bolt</span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="ctx"&gt;</span>Context instance<span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;returns&gt;</span><span class="xmlDocTag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SimpleDRPC <span class="title">Get</span>(<span class="params">Context ctx</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SimpleDRPC(ctx);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SimpleDRPC</span>(<span class="params">Context ctx</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            Context.Logger.Info(<span class="string">"SimpleDRPC constructor called"</span>);</span><br><span class="line">            <span class="keyword">this</span>.ctx = ctx;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Declare Input and Output schemas</span></span><br><span class="line">            Dictionary&lt;<span class="keyword">string</span>, List&lt;Type&gt;&gt; inputSchema = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, List&lt;Type&gt;&gt;();</span><br><span class="line">            inputSchema.Add(<span class="string">"default"</span>, <span class="keyword">new</span> List&lt;Type&gt;() &#123; <span class="keyword">typeof</span>(<span class="keyword">string</span>), <span class="keyword">typeof</span>(<span class="keyword">object</span>) &#125;);</span><br><span class="line">            Dictionary&lt;<span class="keyword">string</span>, List&lt;Type&gt;&gt; outputSchema = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, List&lt;Type&gt;&gt;();</span><br><span class="line">            outputSchema.Add(<span class="string">"default"</span>, <span class="keyword">new</span> List&lt;Type&gt;() &#123; <span class="keyword">typeof</span>(<span class="keyword">string</span>), <span class="keyword">typeof</span>(<span class="keyword">object</span>) &#125;);</span><br><span class="line">            <span class="keyword">this</span>.ctx.DeclareComponentSchema(<span class="keyword">new</span> ComponentStreamSchema(inputSchema, outputSchema));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params">StormTuple tuple</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            Context.Logger.Info(<span class="string">"SimpleDRPC Execute enter"</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">string</span> sentence = tuple.GetString(<span class="number">0</span>) + <span class="string">"!"</span>;</span><br><span class="line">            <span class="keyword">this</span>.ctx.Emit(<span class="string">"default"</span>, <span class="keyword">new</span> List&lt;StormTuple&gt; &#123; tuple &#125;, <span class="keyword">new</span> List&lt;<span class="keyword">object</span>&gt; &#123; sentence, tuple.GetValue(<span class="number">1</span>) &#125;);</span><br><span class="line">            Context.Logger.Info(<span class="string">"SimpleDRPC Execute exit"</span>);</span><br><span class="line">            ApacheStorm.Ack(tuple);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Prepare</span>(<span class="params">Config stormConf, TopologyContext context</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码需要引用<a href="https://github.com/ziyunhx/storm-net-adapter" title="storm-net-adapter" target="_blank" rel="external">storm-net-adapter</a>，详细信息可以查看我之前的文章，下面我们来使用Java定义这个DRPC Topology:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Licensed to the Apache Software Foundation (ASF) under one</span><br><span class="line"> * or more contributor license agreements.  See the NOTICE file</span><br><span class="line"> * distributed with this work for additional information</span><br><span class="line"> * regarding copyright ownership.  The ASF licenses this file</span><br><span class="line"> * to you under the Apache License, Version 2.0 (the</span><br><span class="line"> * "License"); you may not use this file except in compliance</span><br><span class="line"> * with the License.  You may obtain a copy of the License at</span><br><span class="line"> *</span><br><span class="line"> * http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line"> *</span><br><span class="line"> * Unless required by applicable law or agreed to in writing, software</span><br><span class="line"> * distributed under the License is distributed on an "AS IS" BASIS,</span><br><span class="line"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line"> * See the License for the specific language governing permissions and</span><br><span class="line"> * limitations under the License.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">package</span> storm.starter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> backtype.storm.Config;</span><br><span class="line"><span class="keyword">import</span> backtype.storm.LocalCluster;</span><br><span class="line"><span class="keyword">import</span> backtype.storm.LocalDRPC;</span><br><span class="line"><span class="keyword">import</span> backtype.storm.StormSubmitter;</span><br><span class="line"><span class="keyword">import</span> backtype.storm.drpc.DRPCSpout;</span><br><span class="line"><span class="keyword">import</span> backtype.storm.drpc.LinearDRPCTopologyBuilder;</span><br><span class="line"><span class="keyword">import</span> backtype.storm.drpc.ReturnResults;</span><br><span class="line"><span class="keyword">import</span> backtype.storm.spout.ShellSpout;</span><br><span class="line"><span class="keyword">import</span> backtype.storm.task.ShellBolt;</span><br><span class="line"><span class="keyword">import</span> backtype.storm.topology.IRichBolt;</span><br><span class="line"><span class="keyword">import</span> backtype.storm.topology.IRichSpout;</span><br><span class="line"><span class="keyword">import</span> backtype.storm.topology.OutputFieldsDeclarer;</span><br><span class="line"><span class="keyword">import</span> backtype.storm.topology.TopologyBuilder;</span><br><span class="line"><span class="keyword">import</span> backtype.storm.tuple.Fields;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * This topology demonstrates Storm's stream groupings and multilang capabilities.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DrpcTestTopologyCsharp</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDRPC</span> <span class="keyword">extends</span> <span class="title">ShellBolt</span> <span class="keyword">implements</span> <span class="title">IRichBolt</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">SimpleDRPC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">super</span>(<span class="string">"cmd"</span>, <span class="string">"/k"</span>, <span class="string">"CALL"</span>, <span class="string">"StormSample.exe"</span>, <span class="string">"SimpleDRPC"</span>);</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="annotation">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer declarer)</span> </span>&#123;</span><br><span class="line">			declarer.declare(<span class="keyword">new</span> Fields(<span class="string">"id"</span>, <span class="string">"result"</span>));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="annotation">@Override</span></span><br><span class="line">		<span class="keyword">public</span> Map&lt;String, Object&gt; getComponentConfiguration() &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	  	TopologyBuilder builder = <span class="keyword">new</span> TopologyBuilder();</span><br><span class="line">		  </span><br><span class="line">	  	DRPCSpout drpcSpout = <span class="keyword">new</span> DRPCSpout(<span class="string">"simpledrpc"</span>);</span><br><span class="line">	    builder.setSpout(<span class="string">"drpc-input"</span>, drpcSpout,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	    builder.setBolt(<span class="string">"simple"</span>, <span class="keyword">new</span> SimpleDRPC(), <span class="number">2</span>)</span><br><span class="line">	    		.noneGrouping(<span class="string">"drpc-input"</span>);</span><br><span class="line">	    </span><br><span class="line">	    builder.setBolt(<span class="string">"return"</span>, <span class="keyword">new</span> ReturnResults(),<span class="number">1</span>)</span><br><span class="line">		.noneGrouping(<span class="string">"simple"</span>);</span><br><span class="line"></span><br><span class="line">	    Config conf = <span class="keyword">new</span> Config();</span><br><span class="line">	    conf.setDebug(<span class="keyword">true</span>);</span><br><span class="line">	    conf.setMaxTaskParallelism(<span class="number">1</span>);</span><br><span class="line">	    </span><br><span class="line">	    <span class="keyword">try</span></span><br><span class="line">	    &#123;</span><br><span class="line">	    	StormSubmitter.submitTopology(<span class="string">"drpc-q"</span>, conf,builder.createTopology());</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">catch</span> (Exception e)</span><br><span class="line">	    &#123;</span><br><span class="line">	    	e.printStackTrace();</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 相关代码已经集成到<a href="https://github.com/ziyunhx/storm-net-adapter/tree/master/storm-starter" target="_blank" rel="external">storm-starter</a>中，部署并启动该Topology，然后使用C#或其它语言调用：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">DRPCClient client = <span class="keyword">new</span> DRPCClient(<span class="string">"localhost"</span>, <span class="number">3772</span>);</span><br><span class="line"><span class="keyword">string</span> result = client.execute(<span class="string">"simpledrpc"</span>, <span class="string">"hello word"</span>);</span><br></pre></td></tr></table></figure>
<p> 下面是一些其它语言DRPC项目的搜集：</p>
<ul>
<li>C#/.Net    Storm.Net.Apapter <a href="https://github.com/ziyunhx/storm-net-adapter" target="_blank" rel="external">https://github.com/ziyunhx/storm-net-adapter</a></li>
<li>Java    Storm 官方包 <a href="http://storm.apache.org/" target="_blank" rel="external">http://storm.apache.org/</a></li>
<li>Python    storm-drpc-client <a href="https://pypi.python.org/pypi/storm-drpc-client" target="_blank" rel="external">https://pypi.python.org/pypi/storm-drpc-client</a></li>
<li>Php    php-drpc <a href="https://github.com/mithunsatheesh/php-drpc" target="_blank" rel="external">https://github.com/mithunsatheesh/php-drpc</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p> 在上一篇文章里介绍了.Net版本的DRPC的类库，结尾处的例子使用了Java版 BasicDRPCTopology ，本文我将介绍如何使用C#来开发 Storm Topology 并供远程DRPC调用，这篇文章将作为.Net Storm系列文章的一个暂时的结束，新的文章将随着 <a href="https://github.com/ziyunhx/storm-net-adapter" title="storm-net-adapter">storm-net-adapter</a> 新特性来更新!</p>]]>
    
    </summary>
    
      <category term=".NET" scheme="https://www.tnidea.com/tags/NET/"/>
    
      <category term="C#" scheme="https://www.tnidea.com/tags/C/"/>
    
      <category term="DRPC" scheme="https://www.tnidea.com/tags/DRPC/"/>
    
      <category term="Topology" scheme="https://www.tnidea.com/tags/Topology/"/>
    
      <category term="csharp" scheme="https://www.tnidea.com/tags/csharp/"/>
    
      <category term="storm" scheme="https://www.tnidea.com/tags/storm/"/>
    
      <category term="Storm" scheme="https://www.tnidea.com/categories/Storm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[.NET使用DRPC远程调用运行在Storm上的拓扑]]></title>
    <link href="https://www.tnidea.com/dot-net-drpc-storm.html"/>
    <id>https://www.tnidea.com/dot-net-drpc-storm.html</id>
    <published>2015-08-11T16:00:00.000Z</published>
    <updated>2015-09-28T12:13:59.000Z</updated>
    <content type="html"><![CDATA[<p> Distributed RPC（DRPC）是Storm构建在Thrift协议上的RPC的实现，DRPC使得你可以通过多种语言远程的使用Storm集群的计算能力。DRPC并非Storm的基础特性，但它确实非常有用。DRPC的整个过程与一般的RPC没有区别，客户端只需要调用一个远程的方法并等待返回结果。主要工作已经被DRPC Server封装，服务端在这个过程中完成了以下步骤：</p>
<a id="more"></a>
<ul>
<li>从客户端接收一个RPC请求；</li>
<li>将请求发送到storm topology；</li>
<li>从storm topology接收结果；</li>
<li><p>将结果发回给等待的客户端。</p>
<p><img src="http://www.tnidea.com/media/image/drpc-workflow.png" alt="image"></p>
<p><a href="https://github.com/ziyunhx/storm-net-adapter" title="storm-net-adapter" target="_blank" rel="external">storm-net-adapter</a>现在已经完成了对DRPC的支持，因此你可以使用dotNet编写代码远程调用任何支持语言编写的支持DRPC的Topology，当然你也可以使用dotNet编写Topology供其它语言通过DRPC调用。</p>
<p>DRPC是<a href="https://github.com/ziyunhx/storm-net-adapter" title="storm-net-adapter" target="_blank" rel="external">storm-net-adapter</a>新增加的特性，因此需要使用最新的类库，你可以使用源代码自行编译，或者下载最新的<a href="https://github.com/ziyunhx/storm-net-adapter/releases" title="Release" target="_blank" rel="external">Release</a>，还可以使用Nuget获取最新版本。</p>
<p> PM&gt; Install-Package Storm.Net.Adapter</p>
<p>推荐大家使用Nuget获取，方便管理依赖项。下面将介绍如何通过DRPC调用运行在Storm集群的方法，在这之前，你需要已经熟悉Storm环境的搭建与集群部署，不了解的可以先看我之前的文章。为了尽可能的简单，我们使用了Storm官方的BasicDRPCTopology，这个是一个简单的使用JAVA编写的DRPC Topology，它的功能仅仅是在传入的单词后面增加一个感叹号。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Licensed to the Apache Software Foundation (ASF) under one</span><br><span class="line"> * or more contributor license agreements.  See the NOTICE file</span><br><span class="line"> * distributed with this work for additional information</span><br><span class="line"> * regarding copyright ownership.  The ASF licenses this file</span><br><span class="line"> * to you under the Apache License, Version 2.0 (the</span><br><span class="line"> * "License"); you may not use this file except in compliance</span><br><span class="line"> * with the License.  You may obtain a copy of the License at</span><br><span class="line"> *</span><br><span class="line"> * http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line"> *</span><br><span class="line"> * Unless required by applicable law or agreed to in writing, software</span><br><span class="line"> * distributed under the License is distributed on an "AS IS" BASIS,</span><br><span class="line"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line"> * See the License for the specific language governing permissions and</span><br><span class="line"> * limitations under the License.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">package</span> storm.starter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> backtype.storm.Config;</span><br><span class="line"><span class="keyword">import</span> backtype.storm.LocalCluster;</span><br><span class="line"><span class="keyword">import</span> backtype.storm.LocalDRPC;</span><br><span class="line"><span class="keyword">import</span> backtype.storm.StormSubmitter;</span><br><span class="line"><span class="keyword">import</span> backtype.storm.drpc.LinearDRPCTopologyBuilder;</span><br><span class="line"><span class="keyword">import</span> backtype.storm.topology.BasicOutputCollector;</span><br><span class="line"><span class="keyword">import</span> backtype.storm.topology.OutputFieldsDeclarer;</span><br><span class="line"><span class="keyword">import</span> backtype.storm.topology.base.BaseBasicBolt;</span><br><span class="line"><span class="keyword">import</span> backtype.storm.tuple.Fields;</span><br><span class="line"><span class="keyword">import</span> backtype.storm.tuple.Tuple;</span><br><span class="line"><span class="keyword">import</span> backtype.storm.tuple.Values;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * This topology is a basic example of doing distributed RPC on top of Storm. It implements a function that appends a</span><br><span class="line"> * "!" to any string you send the DRPC function.</span><br><span class="line"> * &lt;p/&gt;</span><br><span class="line"> * See https://github.com/nathanmarz/storm/wiki/Distributed-RPC for more information on doing distributed RPC on top of</span><br><span class="line"> * Storm.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicDRPCTopology</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExclaimBolt</span> <span class="keyword">extends</span> <span class="title">BaseBasicBolt</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Tuple tuple, BasicOutputCollector collector)</span> </span>&#123;</span><br><span class="line">      String input = tuple.getString(<span class="number">1</span>);</span><br><span class="line">      collector.emit(<span class="keyword">new</span> Values(tuple.getValue(<span class="number">0</span>), input + <span class="string">"!"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer declarer)</span> </span>&#123;</span><br><span class="line">      declarer.declare(<span class="keyword">new</span> Fields(<span class="string">"id"</span>, <span class="string">"result"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    LinearDRPCTopologyBuilder builder = <span class="keyword">new</span> LinearDRPCTopologyBuilder(<span class="string">"exclamation"</span>);</span><br><span class="line">    builder.addBolt(<span class="keyword">new</span> ExclaimBolt(), <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    Config conf = <span class="keyword">new</span> Config();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (args == <span class="keyword">null</span> || args.length == <span class="number">0</span>) &#123;</span><br><span class="line">      LocalDRPC drpc = <span class="keyword">new</span> LocalDRPC();</span><br><span class="line">      LocalCluster cluster = <span class="keyword">new</span> LocalCluster();</span><br><span class="line"></span><br><span class="line">      cluster.submitTopology(<span class="string">"drpc-demo"</span>, conf, builder.createLocalTopology(drpc));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (String word : <span class="keyword">new</span> String[]&#123; <span class="string">"hello"</span>, <span class="string">"goodbye"</span> &#125;) &#123;</span><br><span class="line">        System.out.println(<span class="string">"Result for \""</span> + word + <span class="string">"\": "</span> + drpc.execute(<span class="string">"exclamation"</span>, word));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      cluster.shutdown();</span><br><span class="line">      drpc.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      conf.setNumWorkers(<span class="number">2</span>);</span><br><span class="line">      StormSubmitter.submitTopologyWithProgressBar(args[<span class="number">0</span>], conf, builder.createRemoteTopology());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 相关代码已经集成到<a href="https://github.com/ziyunhx/storm-net-adapter/tree/master/storm-starter" target="_blank" rel="external">storm-starter</a>中，下面我们还需要修改一下Storm的配置文件：</p>
<pre><code>drpc.servers:
 -<span class="ruby"> <span class="string">"drpc1.foo.com"</span>
</span> -<span class="ruby"> <span class="string">"drpc2.foo.com"</span></span>
</code></pre><p> 将drpc1.foo.com替换成你接下来要启动drpc服务机器的IP或者域名，你可以只保留一条，也可以继续增加服务的数量。</p>
<p> 在你刚刚填写的IP所在服务器上启动drpc服务：</p>
<pre><code><span class="variable">$ </span>storm drpc
</code></pre><p> 使用storm命令提交Topology：</p>
<pre><code>$ storm jar storm-starter-*<span class="class">.jar</span> storm<span class="class">.starter</span><span class="class">.BasicDRPCTopology</span> drpc-test
</code></pre><p> 然后我们就可以在Csharp上编写代码调用了：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">DRPCClient client = <span class="keyword">new</span> DRPCClient(<span class="string">"localhost"</span>, <span class="number">3772</span>);</span><br><span class="line"><span class="keyword">string</span> result = client.execute(<span class="string">"exclamation"</span>, <span class="string">"hello word"</span>);</span><br></pre></td></tr></table></figure>
<p> 替换 localhost 为你的drpc服务器的地址，exclamation为你在java中设置的LinearDRPCTopologyBuilder的名称；我也在项目中新增了一个控制台程序<a href="https://github.com/ziyunhx/storm-net-adapter/tree/master/samples/Storm.DRPC.Demo" target="_blank" rel="external">Storm.DRPC.Demo</a>以便大家用于测试！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p> Distributed RPC（DRPC）是Storm构建在Thrift协议上的RPC的实现，DRPC使得你可以通过多种语言远程的使用Storm集群的计算能力。DRPC并非Storm的基础特性，但它确实非常有用。DRPC的整个过程与一般的RPC没有区别，客户端只需要调用一个远程的方法并等待返回结果。主要工作已经被DRPC Server封装，服务端在这个过程中完成了以下步骤：</p>]]>
    
    </summary>
    
      <category term=".NET" scheme="https://www.tnidea.com/tags/NET/"/>
    
      <category term="C#" scheme="https://www.tnidea.com/tags/C/"/>
    
      <category term="DRPC" scheme="https://www.tnidea.com/tags/DRPC/"/>
    
      <category term="Topology" scheme="https://www.tnidea.com/tags/Topology/"/>
    
      <category term="csharp" scheme="https://www.tnidea.com/tags/csharp/"/>
    
      <category term="storm" scheme="https://www.tnidea.com/tags/storm/"/>
    
      <category term="Storm" scheme="https://www.tnidea.com/categories/Storm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Open Auth辅助库（使用ImitateLogin实现登录）]]></title>
    <link href="https://www.tnidea.com/open-auth-assist-project.html"/>
    <id>https://www.tnidea.com/open-auth-assist-project.html</id>
    <published>2015-08-09T16:00:00.000Z</published>
    <updated>2015-09-23T15:26:42.000Z</updated>
    <content type="html"><![CDATA[<p> 网络上越来越多的公司进行着自己的平台化策略，其中绝大多数都已Web API的方式对外提供服务，为了方便的使用这些服务，你不得不引用许多相关的类库，但是API的本质其实仅仅是一些约定的网络请求，我们大多数情况仅仅使用API提供的少数几个功能，因此，我稍微修改了下微博的c#的类库，加入了<a href="https://github.com/ziyunhx/imitate-login" title="ImitateLogin" target="_blank" rel="external">ImitateLogin</a>库来模拟登录，形成了<a href="https://github.com/ziyunhx/open-auth-assist" title="open-auth-assist" target="_blank" rel="external">open-auth-assist</a>库。</p>
<a id="more"></a>
<p> <a href="https://github.com/ziyunhx/open-auth-assist" target="_blank" rel="external">open-auth-assist</a>的目的是将现有的API的类库使用一种通用的方式来代替，同时又不增加太多的额外工作。另外这个项目也可以算作我的另一个开源项目<a href="https://github.com/ziyunhx/imitate-login" target="_blank" rel="external">ImitateLogin</a>的一个Demo。</p>
<p> 这个类库的绝大多数代码都源于 <a href="http://weibosdk.codeplex.com/" title="WeiboSDK" target="_blank" rel="external">weiboSDK</a> 这个项目，由于作者不准备再更新，而且没有继续提供模拟登录的功能，所以我拿过来修改了下开源出来（已获得原作者同意），目前仅完成了微博部分的实现，由于这个项目依赖于<a href="https://github.com/ziyunhx/imitate-login" target="_blank" rel="external">ImitateLogin</a>，因此只有<a href="https://github.com/ziyunhx/imitate-login" target="_blank" rel="external">ImitateLogin</a>完成的网站才会增加支持；<a href="https://github.com/ziyunhx/imitate-login" target="_blank" rel="external">ImitateLogin</a>本身并没有太多的技术难度，仅仅需要熟悉网络请求和一些耐心来解决各种客户端加密，所以如果大家有时间，也希望能一起为这个项目贡献一些代码，谢谢！</p>
<p> 下面将简单介绍下如何使用<a href="https://github.com/ziyunhx/open-auth-assist" target="_blank" rel="external">open-auth-assist</a>来实现微博API的调用。</p>
<p> 首先，我们需要实例化一个OpenAuthAssist类：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> openAuth = <span class="keyword">new</span> SinaWeiboClient(<span class="string">"1402038860"</span>, <span class="string">"62e1ddd4f6bc33077c796d5129047ca2"</span>, <span class="string">"http://qcyn.sina.com.cn"</span>);</span><br></pre></td></tr></table></figure>
<p> 例子中使用的appkey使用了原作者例子中的key。</p>
<p> 接下来我们登录需要进行操作的用户：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">openAuth.DoLogin(<span class="string">"username"</span>, <span class="string">"password"</span>);</span><br></pre></td></tr></table></figure>
<p> 然后我们来使用Weibo提供的获取用户时间轴的API来展示如何使用Get：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = openAuth.HttpGet(<span class="string">"statuses/friends_timeline.json"</span>, <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">object</span>&gt;</span><br><span class="line">		&#123;</span><br><span class="line">			&#123;<span class="string">"count"</span>, <span class="number">5</span>&#125;,</span><br><span class="line">			&#123;<span class="string">"page"</span>, <span class="number">1</span>&#125;,</span><br><span class="line">			&#123;<span class="string">"base_app"</span> , <span class="number">0</span>&#125;</span><br><span class="line">		&#125;);</span><br></pre></td></tr></table></figure>
<p> 我们发送一条微博来展示Post方法的调用：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result2 = openAuth.HttpPost(<span class="string">"statuses/update.json"</span>, <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">object</span>&gt;</span><br><span class="line">		&#123;</span><br><span class="line">			&#123;<span class="string">"status"</span> , <span class="keyword">string</span>.Format(<span class="string">"post from OpenAuth.Assist! @&#123;0:HH:mm:ss&#125;"</span>, DateTime.Now)&#125;</span><br><span class="line">		&#125;);</span><br></pre></td></tr></table></figure>
<p> 接下来，好好享受吧！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p> 网络上越来越多的公司进行着自己的平台化策略，其中绝大多数都已Web API的方式对外提供服务，为了方便的使用这些服务，你不得不引用许多相关的类库，但是API的本质其实仅仅是一些约定的网络请求，我们大多数情况仅仅使用API提供的少数几个功能，因此，我稍微修改了下微博的c#的类库，加入了<a href="https://github.com/ziyunhx/imitate-login" title="ImitateLogin">ImitateLogin</a>库来模拟登录，形成了<a href="https://github.com/ziyunhx/open-auth-assist" title="open-auth-assist">open-auth-assist</a>库。</p>]]>
    
    </summary>
    
      <category term=".NET" scheme="https://www.tnidea.com/tags/NET/"/>
    
      <category term="C#" scheme="https://www.tnidea.com/tags/C/"/>
    
      <category term="ImitateLogin" scheme="https://www.tnidea.com/tags/ImitateLogin/"/>
    
      <category term="OpenAuth" scheme="https://www.tnidea.com/tags/OpenAuth/"/>
    
      <category term="csharp" scheme="https://www.tnidea.com/tags/csharp/"/>
    
      <category term="open-auth-assist" scheme="https://www.tnidea.com/tags/open-auth-assist/"/>
    
      <category term="爬虫" scheme="https://www.tnidea.com/categories/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[.Net使用HttpWebRequest模拟浏览器]]></title>
    <link href="https://www.tnidea.com/http-helper-at-csharp.html"/>
    <id>https://www.tnidea.com/http-helper-at-csharp.html</id>
    <published>2015-07-09T16:00:00.000Z</published>
    <updated>2015-10-07T08:16:21.000Z</updated>
    <content type="html"><![CDATA[<p> 在编写网络爬虫时，HttpWebRequest几乎可以完成绝大多数网站的抓取，为了更好的使用这一技术，我将常用的几个功能进行了封装，以方便调用。这个类已经在多个项目中得到使用，主要解决了Cookies相关的一些问题；如果有其它方面的问题可以提出来，我会进一步完善。</p>
<a id="more"></a>
<p> 目前HttpHelper包含了以下几个方面：</p>
<ul>
<li>GetHttpContent：通过Get或Post来获取网页的Html</li>
<li>SetCookie：根据response中头部的set-cookie对cookie进行设置，能识别httponly</li>
<li>GetAllCookies：将CookieContainer转换为键值对，方便存储和跨程序间调用</li>
<li>ConvertToCookieContainer：将键值对转换回CookieContainer供程序调用</li>
<li><p>BuildPostData：通过一个需要post的html构建出postdata</p>
<p>代码如下：</p>
</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Specialized;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.IO.Compression;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Net;</span><br><span class="line"><span class="keyword">using</span> System.Net.Security;</span><br><span class="line"><span class="keyword">using</span> System.Security.Cryptography.X509Certificates;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Text.RegularExpressions;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> HtmlAgilityPack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">TNIdea.Common.Helper</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HttpHelper</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">const</span> <span class="keyword">string</span> CharsetReg = <span class="string">@"(meta.*?charset=""?(?&lt;Charset&gt;[^\s""'&gt;]+)""?)|(xml.*?encoding=""?(?&lt;Charset&gt;[^\s""&gt;]+)""?)"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> 获取网页的内容</span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="url"&gt;</span>Url<span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="postData"&gt;</span>Post的信息<span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="cookies"&gt;</span>Cookies<span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="userAgent"&gt;</span>浏览器标识<span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="referer"&gt;</span>来源页<span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="cookiesDomain"&gt;</span>Cookies的Domian参数，配合cookies使用；为空则取url的Host<span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="encode"&gt;</span>编码方式，用于解析html<span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;returns&gt;</span><span class="xmlDocTag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">string</span> <span class="title">GetHttpContent</span>(<span class="params"><span class="keyword">string</span> url, <span class="keyword">string</span> postData = <span class="keyword">null</span>, CookieContainer cookies = <span class="keyword">null</span>, <span class="keyword">string</span> userAgent = <span class="string">""</span>, <span class="keyword">string</span> referer = <span class="string">""</span>, <span class="keyword">string</span> cookiesDomain = <span class="string">""</span>, Encoding encode = <span class="keyword">null</span></span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                HttpWebResponse httpResponse = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="keyword">string</span>.IsNullOrWhiteSpace(postData))</span><br><span class="line">                    httpResponse = CreatePostHttpResponse(url, postData, cookies: cookies, userAgent: userAgent, referer: referer);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    httpResponse = CreateGetHttpResponse(url, cookies: cookies, userAgent: userAgent, referer: referer);</span><br><span class="line"></span><br><span class="line">                <span class="preprocessor">#<span class="keyword">region</span> 根据Html头判断</span></span><br><span class="line">                <span class="keyword">string</span> Content = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//缓冲区长度</span></span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">int</span> N_CacheLength = <span class="number">10000</span>;</span><br><span class="line">                <span class="comment">//头部预读取缓冲区，字节形式</span></span><br><span class="line">                <span class="keyword">var</span> bytes = <span class="keyword">new</span> List&lt;<span class="keyword">byte</span>&gt;();</span><br><span class="line">                <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//头部预读取缓冲区，字符串</span></span><br><span class="line">                String cache = <span class="keyword">string</span>.Empty;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//创建流对象并解码</span></span><br><span class="line">                Stream ResponseStream;</span><br><span class="line">                <span class="keyword">switch</span> (httpResponse.ContentEncoding.ToUpperInvariant())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">"GZIP"</span>:</span><br><span class="line">                        ResponseStream = <span class="keyword">new</span> GZipStream(</span><br><span class="line">                            httpResponse.GetResponseStream(), CompressionMode.Decompress);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">"DEFLATE"</span>:</span><br><span class="line">                        ResponseStream = <span class="keyword">new</span> DeflateStream(</span><br><span class="line">                            httpResponse.GetResponseStream(), CompressionMode.Decompress);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        ResponseStream = httpResponse.GetResponseStream();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">while</span> (</span><br><span class="line">                        !(cache.EndsWith(<span class="string">"&lt;/head&gt;"</span>, StringComparison.OrdinalIgnoreCase)</span><br><span class="line">                          || count &gt;= N_CacheLength))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">var</span> b = (<span class="keyword">byte</span>)ResponseStream.ReadByte();</span><br><span class="line">                        <span class="keyword">if</span> (b &lt; <span class="number">0</span>) <span class="comment">//end of stream</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        bytes.Add(b);</span><br><span class="line"></span><br><span class="line">                        count++;</span><br><span class="line">                        cache += (<span class="keyword">char</span>)b;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (encode == <span class="keyword">null</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">try</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span> (httpResponse.CharacterSet == <span class="string">"ISO-8859-1"</span> || httpResponse.CharacterSet == <span class="string">"zh-cn"</span>)</span><br><span class="line">                            &#123;</span><br><span class="line">                                Match match = Regex.Match(cache, CharsetReg, RegexOptions.IgnoreCase | RegexOptions.Multiline);</span><br><span class="line">                                <span class="keyword">if</span> (match.Success)</span><br><span class="line">                                &#123;</span><br><span class="line">                                    <span class="keyword">try</span></span><br><span class="line">                                    &#123;</span><br><span class="line">                                        <span class="keyword">string</span> charset = match.Groups[<span class="string">"Charset"</span>].Value;</span><br><span class="line">                                        encode = Encoding.GetEncoding(charset);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    <span class="keyword">catch</span> &#123; &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    encode = Encoding.GetEncoding(<span class="string">"GB2312"</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                encode = Encoding.GetEncoding(httpResponse.CharacterSet);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">catch</span> &#123; &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//缓冲字节重新编码，然后再把流读完</span></span><br><span class="line">                    <span class="keyword">var</span> Reader = <span class="keyword">new</span> StreamReader(ResponseStream, encode);</span><br><span class="line">                    Content = encode.GetString(bytes.ToArray(), <span class="number">0</span>, count) + Reader.ReadToEnd();</span><br><span class="line">                    Reader.Close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> ex.ToString();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">finally</span></span><br><span class="line">                &#123;</span><br><span class="line">                    httpResponse.Close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="preprocessor">#<span class="keyword">endregion</span> 根据Html头判断</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//获取返回的Cookies，支持httponly</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">string</span>.IsNullOrWhiteSpace(cookiesDomain))</span><br><span class="line">                    cookiesDomain = httpResponse.ResponseUri.Host;</span><br><span class="line"></span><br><span class="line">                cookies = <span class="keyword">new</span> CookieContainer();</span><br><span class="line">                CookieCollection httpHeaderCookies = SetCookie(httpResponse, cookiesDomain);</span><br><span class="line">                cookies.Add(httpHeaderCookies ?? httpResponse.Cookies);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> Content;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">string</span>.Empty;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> 创建GET方式的HTTP请求 </span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="url"&gt;</span><span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="timeout"&gt;</span><span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="userAgent"&gt;</span><span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="cookies"&gt;</span><span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="referer"&gt;</span><span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;returns&gt;</span><span class="xmlDocTag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HttpWebResponse <span class="title">CreateGetHttpResponse</span>(<span class="params"><span class="keyword">string</span> url, <span class="keyword">int</span> timeout = <span class="number">60000</span>, <span class="keyword">string</span> userAgent = <span class="string">""</span>, CookieContainer cookies = <span class="keyword">null</span>, <span class="keyword">string</span> referer = <span class="string">""</span></span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            HttpWebRequest request = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (url.StartsWith(<span class="string">"https"</span>, StringComparison.OrdinalIgnoreCase))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//对服务端证书进行有效性校验（非第三方权威机构颁发的证书，如自己生成的，不进行验证，这里返回true）</span></span><br><span class="line">                ServicePointManager.ServerCertificateValidationCallback = <span class="keyword">new</span> RemoteCertificateValidationCallback(CheckValidationResult);</span><br><span class="line">                request = WebRequest.Create(url) <span class="keyword">as</span> HttpWebRequest;</span><br><span class="line">                <span class="comment">//request.ProtocolVersion = HttpVersion.Version10;    //http版本，默认是1.1,这里设置为1.0</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                request = WebRequest.Create(url) <span class="keyword">as</span> HttpWebRequest;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            request.Referer = referer;</span><br><span class="line">            request.Method = <span class="string">"GET"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置代理UserAgent和超时</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">string</span>.IsNullOrWhiteSpace(userAgent))</span><br><span class="line">                userAgent = <span class="string">"Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/34.0.1847.116 Safari/537.36"</span>;</span><br><span class="line"></span><br><span class="line">            request.UserAgent = userAgent;</span><br><span class="line">            request.Timeout = timeout;</span><br><span class="line">            request.KeepAlive = <span class="keyword">true</span>;</span><br><span class="line">            request.AllowAutoRedirect = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cookies == <span class="keyword">null</span>)</span><br><span class="line">                cookies = <span class="keyword">new</span> CookieContainer();</span><br><span class="line">            request.CookieContainer = cookies;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> request.GetResponse() <span class="keyword">as</span> HttpWebResponse;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> 创建POST方式的HTTP请求</span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="url"&gt;</span><span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="postData"&gt;</span><span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="timeout"&gt;</span><span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="userAgent"&gt;</span><span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="cookies"&gt;</span><span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="referer"&gt;</span><span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;returns&gt;</span><span class="xmlDocTag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HttpWebResponse <span class="title">CreatePostHttpResponse</span>(<span class="params"><span class="keyword">string</span> url, <span class="keyword">string</span> postData, <span class="keyword">int</span> timeout = <span class="number">60000</span>, <span class="keyword">string</span> userAgent = <span class="string">""</span>, CookieContainer cookies = <span class="keyword">null</span>, <span class="keyword">string</span> referer = <span class="string">""</span></span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            HttpWebRequest request = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//如果是发送HTTPS请求  </span></span><br><span class="line">            <span class="keyword">if</span> (url.StartsWith(<span class="string">"https"</span>, StringComparison.OrdinalIgnoreCase))</span><br><span class="line">            &#123;</span><br><span class="line">                ServicePointManager.ServerCertificateValidationCallback = <span class="keyword">new</span> RemoteCertificateValidationCallback(CheckValidationResult);</span><br><span class="line">                request = WebRequest.Create(url) <span class="keyword">as</span> HttpWebRequest;</span><br><span class="line">                <span class="comment">//request.ProtocolVersion = HttpVersion.Version10;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                request = WebRequest.Create(url) <span class="keyword">as</span> HttpWebRequest;</span><br><span class="line">            &#125;</span><br><span class="line">            request.Referer = referer;</span><br><span class="line">            request.Method = <span class="string">"POST"</span>;</span><br><span class="line">            request.ContentType = <span class="string">"application/x-www-form-urlencoded"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置代理UserAgent和超时</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">string</span>.IsNullOrWhiteSpace(userAgent))</span><br><span class="line">                request.UserAgent = <span class="string">"Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1985.125 Safari/537.36"</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                request.UserAgent = userAgent;</span><br><span class="line">            request.Timeout = timeout;</span><br><span class="line">            request.KeepAlive = <span class="keyword">true</span>;</span><br><span class="line">            request.AllowAutoRedirect = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cookies == <span class="keyword">null</span>)</span><br><span class="line">                cookies = <span class="keyword">new</span> CookieContainer();</span><br><span class="line">            request.CookieContainer = cookies;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//发送POST数据  </span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">string</span>.IsNullOrWhiteSpace(postData))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] data = Encoding.UTF8.GetBytes(postData);</span><br><span class="line">                request.ContentLength = data.Length;</span><br><span class="line">                <span class="keyword">using</span> (Stream stream = request.GetRequestStream())</span><br><span class="line">                &#123;</span><br><span class="line">                    stream.Write(data, <span class="number">0</span>, data.Length);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//string[] values = request.Headers.GetValues("Content-Type");</span></span><br><span class="line">            <span class="keyword">return</span> request.GetResponse() <span class="keyword">as</span> HttpWebResponse;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> 验证证书</span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="sender"&gt;</span><span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="certificate"&gt;</span><span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="chain"&gt;</span><span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="errors"&gt;</span><span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;returns&gt;</span>是否验证通过<span class="xmlDocTag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">CheckValidationResult</span>(<span class="params"><span class="keyword">object</span> sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors errors</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (errors == SslPolicyErrors.None)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> 根据response中头部的set-cookie对request中的cookie进行设置</span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="setCookie"&gt;</span>The set cookie.<span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="defaultDomain"&gt;</span>The default domain.<span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;returns&gt;</span><span class="xmlDocTag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> CookieCollection <span class="title">SetCookie</span>(<span class="params">HttpWebResponse response, <span class="keyword">string</span> defaultDomain</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">string</span>[] setCookie = response.Headers.GetValues(<span class="string">"Set-Cookie"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// there is bug in it,the datetime in "set-cookie" will be sepreated in two pieces.</span></span><br><span class="line">                List&lt;<span class="keyword">string</span>&gt; a = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;(setCookie);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = setCookie.Length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (a[i].Substring(a[i].Length - <span class="number">3</span>) == <span class="string">"GMT"</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        a[i - <span class="number">1</span>] = a[i - <span class="number">1</span>] + <span class="string">", "</span> + a[i];</span><br><span class="line">                        a.RemoveAt(i);</span><br><span class="line">                        i--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                setCookie = a.ToArray&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line">                CookieCollection cookies = <span class="keyword">new</span> CookieCollection();</span><br><span class="line">                <span class="keyword">foreach</span> (<span class="keyword">string</span> str <span class="keyword">in</span> setCookie)</span><br><span class="line">                &#123;</span><br><span class="line">                    NameValueCollection hs = <span class="keyword">new</span> NameValueCollection();</span><br><span class="line">                    <span class="keyword">foreach</span> (<span class="keyword">string</span> i <span class="keyword">in</span> str.Split(<span class="string">';'</span>))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">int</span> index = i.IndexOf(<span class="string">"="</span>);</span><br><span class="line">                        <span class="keyword">if</span> (index &gt; <span class="number">0</span>)</span><br><span class="line">                            hs.Add(i.Substring(<span class="number">0</span>, index).Trim(), i.Substring(index + <span class="number">1</span>).Trim());</span><br><span class="line">                        <span class="function"><span class="keyword">else</span></span><br><span class="line">                            <span class="title">switch</span> (<span class="params">i</span>)</span><br><span class="line">                            </span>&#123;</span><br><span class="line">                                <span class="keyword">case</span> <span class="string">"HttpOnly"</span>:</span><br><span class="line">                                    hs.Add(<span class="string">"HttpOnly"</span>, <span class="string">"True"</span>);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                <span class="keyword">case</span> <span class="string">"Secure"</span>:</span><br><span class="line">                                    hs.Add(<span class="string">"Secure"</span>, <span class="string">"True"</span>);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Cookie ck = <span class="keyword">new</span> Cookie();</span><br><span class="line">                    <span class="keyword">foreach</span> (<span class="keyword">string</span> Key <span class="keyword">in</span> hs.AllKeys)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">switch</span> (Key.ToLower().Trim())</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">"path"</span>:</span><br><span class="line">                                ck.Path = hs[Key];</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">"expires"</span>:</span><br><span class="line">                                ck.Expires = DateTime.Parse(hs[Key]);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">"domain"</span>:</span><br><span class="line">                                ck.Domain = hs[Key];</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">"httpOnly"</span>:</span><br><span class="line">                                ck.HttpOnly = <span class="keyword">true</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">"secure"</span>:</span><br><span class="line">                                ck.Secure = <span class="keyword">true</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">default</span>:</span><br><span class="line">                                ck.Name = Key;</span><br><span class="line">                                ck.Value = hs[Key];</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (ck.Domain == <span class="string">""</span>) ck.Domain = defaultDomain;</span><br><span class="line">                    <span class="keyword">if</span> (ck.Name != <span class="string">""</span>) cookies.Add(ck);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> cookies;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> 遍历CookieContainer</span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="cookieContainer"&gt;</span><span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;returns&gt;</span>List of cookie<span class="xmlDocTag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">string</span>&gt; GetAllCookies(CookieContainer cookieContainer)</span><br><span class="line">        &#123;</span><br><span class="line">            Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">string</span>&gt; cookies = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">string</span>&gt;();</span><br><span class="line"></span><br><span class="line">            Hashtable table = (Hashtable)cookieContainer.GetType().InvokeMember(<span class="string">"m_domainTable"</span>,</span><br><span class="line">                System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.GetField |</span><br><span class="line">                System.Reflection.BindingFlags.Instance, <span class="keyword">null</span>, cookieContainer, <span class="keyword">new</span> <span class="keyword">object</span>[] &#123; &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">string</span> pathList <span class="keyword">in</span> table.Keys)</span><br><span class="line">            &#123;</span><br><span class="line">                StringBuilder _cookie = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                SortedList cookieColList = (SortedList)table[pathList].GetType().InvokeMember(<span class="string">"m_list"</span>,</span><br><span class="line">                    System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.GetField</span><br><span class="line">                    | System.Reflection.BindingFlags.Instance, <span class="keyword">null</span>, table[pathList], <span class="keyword">new</span> <span class="keyword">object</span>[] &#123; &#125;);</span><br><span class="line">                <span class="keyword">foreach</span> (CookieCollection colCookies <span class="keyword">in</span> cookieColList.Values)</span><br><span class="line">                    <span class="keyword">foreach</span> (Cookie c <span class="keyword">in</span> colCookies)</span><br><span class="line">                        _cookie.Append(c.Name + <span class="string">"="</span> + c.Value + <span class="string">";"</span>);</span><br><span class="line"></span><br><span class="line">                cookies.Add(pathList, _cookie.ToString().TrimEnd(<span class="string">';'</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cookies;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> convert cookies string to CookieContainer</span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;param name="cookies"&gt;</span><span class="xmlDocTag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;returns&gt;</span><span class="xmlDocTag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CookieContainer <span class="title">ConvertToCookieContainer</span>(<span class="params">Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">string</span>&gt; cookies</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            CookieContainer cookieContainer = <span class="keyword">new</span> CookieContainer();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> cookie <span class="keyword">in</span> cookies)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">string</span>[] strEachCookParts = cookie.Value.Split(<span class="string">';'</span>);</span><br><span class="line">                <span class="keyword">int</span> intEachCookPartsCount = strEachCookParts.Length;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">foreach</span> (<span class="keyword">string</span> strCNameAndCValue <span class="keyword">in</span> strEachCookParts)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="keyword">string</span>.IsNullOrEmpty(strCNameAndCValue))</span><br><span class="line">                    &#123;</span><br><span class="line">                        Cookie cookTemp = <span class="keyword">new</span> Cookie();</span><br><span class="line">                        <span class="keyword">int</span> firstEqual = strCNameAndCValue.IndexOf(<span class="string">"="</span>);</span><br><span class="line">                        <span class="keyword">string</span> firstName = strCNameAndCValue.Substring(<span class="number">0</span>, firstEqual);</span><br><span class="line">                        <span class="keyword">string</span> allValue = strCNameAndCValue.Substring(firstEqual + <span class="number">1</span>, strCNameAndCValue.Length - (firstEqual + <span class="number">1</span>));</span><br><span class="line">                        cookTemp.Name = firstName;</span><br><span class="line">                        cookTemp.Value = allValue;</span><br><span class="line">                        cookTemp.Path = <span class="string">"/"</span>;</span><br><span class="line">                        cookTemp.Domain = cookie.Key;</span><br><span class="line">                        cookieContainer.Add(cookTemp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cookieContainer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">string</span> <span class="title">BuildPostData</span>(<span class="params"><span class="keyword">string</span> htmlContent</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            HtmlDocument htmlDoc = <span class="keyword">new</span> HtmlDocument();</span><br><span class="line">            htmlDoc.LoadHtml(htmlContent);</span><br><span class="line">            <span class="comment">//Get the form node collection.</span></span><br><span class="line">            HtmlNode htmlNode = htmlDoc.DocumentNode.SelectSingleNode(<span class="string">"//form"</span>);</span><br><span class="line">            HtmlNodeCollection htmlInputs = htmlNode.SelectNodes(<span class="string">"//input"</span>);</span><br><span class="line"></span><br><span class="line">            StringBuilder postData = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">foreach</span> (HtmlNode input <span class="keyword">in</span> htmlInputs)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(input.Attributes[<span class="string">"value"</span>] != <span class="keyword">null</span>)</span><br><span class="line">                    postData.Append(input.Attributes[<span class="string">"name"</span>].Value + <span class="string">"="</span> + input.Attributes[<span class="string">"value"</span>].Value + <span class="string">"&amp;"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> postData.ToString().TrimEnd(<span class="string">'&amp;'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 部分网站需要登录的问题我已经着手通过另一个项目来解决（<a href="https://github.com/ziyunhx/imitate-login" title="imitate-login" target="_blank" rel="external">imitate-login</a>），目前还有许多网页使用了JavaScript或各种基于JS的框架来对网页进行数据加载，如何来模拟执行JavaScript暂时还没找到比较优美的解决方案，如果大家有什么好的方案可以发给我，谢谢！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p> 在编写网络爬虫时，HttpWebRequest几乎可以完成绝大多数网站的抓取，为了更好的使用这一技术，我将常用的几个功能进行了封装，以方便调用。这个类已经在多个项目中得到使用，主要解决了Cookies相关的一些问题；如果有其它方面的问题可以提出来，我会进一步完善。</p>]]>
    
    </summary>
    
      <category term=".NET" scheme="https://www.tnidea.com/tags/NET/"/>
    
      <category term="C#" scheme="https://www.tnidea.com/tags/C/"/>
    
      <category term="HttpHelper" scheme="https://www.tnidea.com/tags/HttpHelper/"/>
    
      <category term="HttpWebRequest" scheme="https://www.tnidea.com/tags/HttpWebRequest/"/>
    
      <category term="csharp" scheme="https://www.tnidea.com/tags/csharp/"/>
    
      <category term="爬虫" scheme="https://www.tnidea.com/categories/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
</feed>
